//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
import axios from "axios"
export class EmailClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param groupId (optional)
   * @param statuses (optional)
   * @param includeContents (optional)
   */
  getAll(search, skip, take, groupId, statuses, includeContents, cancelToken) {
    let url_ = this.baseUrl + "/v1/Email?"
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (groupId !== undefined && groupId !== null)
      url_ += "groupId=" + encodeURIComponent("" + groupId) + "&"
    if (statuses !== undefined && statuses !== null)
      statuses &&
        statuses.forEach(item => {
          url_ += "statuses=" + encodeURIComponent("" + item) + "&"
        })
    if (includeContents === null)
      throw new Error("The parameter 'includeContents' cannot be null.")
    else if (includeContents !== undefined)
      url_ +=
        "includeContents=" + encodeURIComponent("" + includeContents) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAll(_response)
      })
  }
  processGetAll(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
   * This is a webhook called by SendGrid
   */
  update(cancelToken) {
    let url_ = this.baseUrl + "/v1/Email"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "POST",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param statuses (optional)
   * @param includeContents (optional)
   */
  getAllByUser(
    userId,
    search,
    skip,
    take,
    statuses,
    includeContents,
    cancelToken
  ) {
    let url_ = this.baseUrl + "/v1/Email/User/{userId}?"
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.")
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId))
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (statuses !== undefined && statuses !== null)
      statuses &&
        statuses.forEach(item => {
          url_ += "statuses=" + encodeURIComponent("" + item) + "&"
        })
    if (includeContents === null)
      throw new Error("The parameter 'includeContents' cannot be null.")
    else if (includeContents !== undefined)
      url_ +=
        "includeContents=" + encodeURIComponent("" + includeContents) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllByUser(_response)
      })
  }
  processGetAllByUser(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(emailId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Email/{emailId}"
    if (emailId === undefined || emailId === null)
      throw new Error("The parameter 'emailId' must be defined.")
    url_ = url_.replace("{emailId}", encodeURIComponent("" + emailId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class GroupAttendanceClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param status (optional)
   */
  getAll(groupId, search, skip, take, status, cancelToken) {
    let url_ = this.baseUrl + "/v1/Group/{groupId}/Attendance?"
    if (groupId === undefined || groupId === null)
      throw new Error("The parameter 'groupId' must be defined.")
    url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId))
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (status !== undefined && status !== null)
      url_ += "status=" + encodeURIComponent("" + status) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAll(_response)
      })
  }
  processGetAll(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(groupId, userId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Group/{groupId}/Attendance/{userId}"
    if (groupId === undefined || groupId === null)
      throw new Error("The parameter 'groupId' must be defined.")
    url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId))
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.")
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(groupId, userId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Group/{groupId}/Attendance/{userId}"
    if (groupId === undefined || groupId === null)
      throw new Error("The parameter 'groupId' must be defined.")
    url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId))
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.")
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class MeetingClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param parentId (optional)
   * @param from (optional)
   * @param to (optional)
   */
  getAll(search, skip, take, parentId, from, to, cancelToken) {
    let url_ = this.baseUrl + "/v1/Meeting?"
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (parentId !== undefined && parentId !== null)
      url_ += "parentId=" + encodeURIComponent("" + parentId) + "&"
    if (from !== undefined && from !== null)
      url_ +=
        "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&"
    if (to !== undefined && to !== null)
      url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAll(_response)
      })
  }
  processGetAll(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Meeting"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(meetingId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Meeting/{meetingId}"
    if (meetingId === undefined || meetingId === null)
      throw new Error("The parameter 'meetingId' must be defined.")
    url_ = url_.replace("{meetingId}", encodeURIComponent("" + meetingId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(meetingId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Meeting/{meetingId}"
    if (meetingId === undefined || meetingId === null)
      throw new Error("The parameter 'meetingId' must be defined.")
    url_ = url_.replace("{meetingId}", encodeURIComponent("" + meetingId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(meetingId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Meeting/{meetingId}"
    if (meetingId === undefined || meetingId === null)
      throw new Error("The parameter 'meetingId' must be defined.")
    url_ = url_.replace("{meetingId}", encodeURIComponent("" + meetingId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  getAllFiles(meetingId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Meeting/{meetingId}/File"
    if (meetingId === undefined || meetingId === null)
      throw new Error("The parameter 'meetingId' must be defined.")
    url_ = url_.replace("{meetingId}", encodeURIComponent("" + meetingId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllFiles(_response)
      })
  }
  processGetAllFiles(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  createFile(meetingId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Meeting/{meetingId}/File"
    if (meetingId === undefined || meetingId === null)
      throw new Error("The parameter 'meetingId' must be defined.")
    url_ = url_.replace("{meetingId}", encodeURIComponent("" + meetingId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreateFile(_response)
      })
  }
  processCreateFile(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  getFile(meetingId, fileId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Meeting/{meetingId}/File/{fileId}"
    if (meetingId === undefined || meetingId === null)
      throw new Error("The parameter 'meetingId' must be defined.")
    url_ = url_.replace("{meetingId}", encodeURIComponent("" + meetingId))
    if (fileId === undefined || fileId === null)
      throw new Error("The parameter 'fileId' must be defined.")
    url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetFile(_response)
      })
  }
  processGetFile(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  updateFile(meetingId, fileId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Meeting/{meetingId}/File/{fileId}"
    if (meetingId === undefined || meetingId === null)
      throw new Error("The parameter 'meetingId' must be defined.")
    url_ = url_.replace("{meetingId}", encodeURIComponent("" + meetingId))
    if (fileId === undefined || fileId === null)
      throw new Error("The parameter 'fileId' must be defined.")
    url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdateFile(_response)
      })
  }
  processUpdateFile(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  deleteFile(meetingId, fileId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Meeting/{meetingId}/File/{fileId}"
    if (meetingId === undefined || meetingId === null)
      throw new Error("The parameter 'meetingId' must be defined.")
    url_ = url_.replace("{meetingId}", encodeURIComponent("" + meetingId))
    if (fileId === undefined || fileId === null)
      throw new Error("The parameter 'fileId' must be defined.")
    url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDeleteFile(_response)
      })
  }
  processDeleteFile(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  downloadFile(meetingId, fileId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Meeting/{meetingId}/File/{fileId}/Download"
    if (meetingId === undefined || meetingId === null)
      throw new Error("The parameter 'meetingId' must be defined.")
    url_ = url_.replace("{meetingId}", encodeURIComponent("" + meetingId))
    if (fileId === undefined || fileId === null)
      throw new Error("The parameter 'fileId' must be defined.")
    url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      responseType: "blob",
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/octet-stream",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDownloadFile(_response)
      })
  }
  processDownloadFile(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Promise.resolve({
        fileName: fileName,
        status: status,
        data: new Blob([response.data], {
          type: response.headers["content-type"],
        }),
        headers: _headers,
      })
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class UserAttendanceClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param status (optional)
   */
  getAll(userId, search, skip, take, status, cancelToken) {
    let url_ = this.baseUrl + "/v1/User/{userId}/Attendance?"
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.")
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId))
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (status !== undefined && status !== null)
      url_ += "status=" + encodeURIComponent("" + status) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAll(_response)
      })
  }
  processGetAll(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(userId, groupId, cancelToken) {
    let url_ = this.baseUrl + "/v1/User/{userId}/Attendance/{groupId}"
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.")
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId))
    if (groupId === undefined || groupId === null)
      throw new Error("The parameter 'groupId' must be defined.")
    url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(userId, groupId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/User/{userId}/Attendance/{groupId}"
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.")
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId))
    if (groupId === undefined || groupId === null)
      throw new Error("The parameter 'groupId' must be defined.")
    url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class BackupClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   */
  getAll(skip, take, cancelToken) {
    let url_ = this.baseUrl + "/v1/Backup?"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAll(_response)
      })
  }
  processGetAll(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(cancelToken) {
    let url_ = this.baseUrl + "/v1/Backup"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "POST",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(id, cancelToken) {
    let url_ = this.baseUrl + "/v1/Backup/{id}"
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class ExternalApplicationClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   */
  getAll(search, skip, take, cancelToken) {
    let url_ = this.baseUrl + "/v1/ExternalApplication?"
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAll(_response)
      })
  }
  processGetAll(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/ExternalApplication"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(applicationId, cancelToken) {
    let url_ = this.baseUrl + "/v1/ExternalApplication/{applicationId}"
    if (applicationId === undefined || applicationId === null)
      throw new Error("The parameter 'applicationId' must be defined.")
    url_ = url_.replace(
      "{applicationId}",
      encodeURIComponent("" + applicationId)
    )
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(applicationId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/ExternalApplication/{applicationId}"
    if (applicationId === undefined || applicationId === null)
      throw new Error("The parameter 'applicationId' must be defined.")
    url_ = url_.replace(
      "{applicationId}",
      encodeURIComponent("" + applicationId)
    )
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(applicationId, cancelToken) {
    let url_ = this.baseUrl + "/v1/ExternalApplication/{applicationId}"
    if (applicationId === undefined || applicationId === null)
      throw new Error("The parameter 'applicationId' must be defined.")
    url_ = url_.replace(
      "{applicationId}",
      encodeURIComponent("" + applicationId)
    )
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class ImageClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * Resizes the given image to the specified size.
   * @param uri (optional) Uri of the image to resize.
   * @param size (optional) The default width and height of the result image in pixels.
   * @param width (optional) A custom width to override the default size.
   * @param height (optional) A custom height to override the default size.
   * @return Uri of the resized image.
   */
  get(uri, size, width, height, cancelToken) {
    let url_ = this.baseUrl + "/v1/Image?"
    if (uri !== undefined && uri !== null)
      url_ += "uri=" + encodeURIComponent("" + uri) + "&"
    if (size !== undefined && size !== null)
      url_ += "size=" + encodeURIComponent("" + size) + "&"
    if (width !== undefined && width !== null)
      url_ += "width=" + encodeURIComponent("" + width) + "&"
    if (height !== undefined && height !== null)
      url_ += "height=" + encodeURIComponent("" + height) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class LogClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param logLevel (optional)
   */
  getAll(search, skip, take, logLevel, cancelToken) {
    let url_ = this.baseUrl + "/v1/Log?"
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (logLevel === null)
      throw new Error("The parameter 'logLevel' cannot be null.")
    else if (logLevel !== undefined)
      url_ += "logLevel=" + encodeURIComponent("" + logLevel) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAll(_response)
      })
  }
  processGetAll(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(logId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Log/{logId}"
    if (logId === undefined || logId === null)
      throw new Error("The parameter 'logId' must be defined.")
    url_ = url_.replace("{logId}", encodeURIComponent("" + logId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class PlatformClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  get(cancelToken) {
    let url_ = this.baseUrl + "/v1/Platform"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  terms(cancelToken) {
    let url_ = this.baseUrl + "/v1/Platform/Terms"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processTerms(_response)
      })
  }
  processTerms(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  defaultSettings(environment, cancelToken) {
    let url_ = this.baseUrl + "/v1/Platform/DefaultSettings?"
    if (environment !== undefined && environment !== null)
      url_ += "environment=" + encodeURIComponent("" + environment) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDefaultSettings(_response)
      })
  }
  processDefaultSettings(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class ProjectionClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param status (optional)
   */
  getAll(search, skip, take, status, cancelToken) {
    let url_ = this.baseUrl + "/v1/Projection?"
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (status !== undefined && status !== null)
      url_ += "status=" + encodeURIComponent("" + status) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAll(_response)
      })
  }
  processGetAll(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(projectionId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Projection/{projectionId}"
    if (projectionId === undefined || projectionId === null)
      throw new Error("The parameter 'projectionId' must be defined.")
    url_ = url_.replace("{projectionId}", encodeURIComponent("" + projectionId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class NotificationClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param type (optional)
   * @param seen (optional)
   * @param read (optional)
   * @param from (optional)
   * @param to (optional)
   */
  getAll(skip, take, type, seen, read, from, to, cancelToken) {
    let url_ = this.baseUrl + "/v1/Notification?"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (type !== undefined && type !== null)
      url_ += "type=" + encodeURIComponent("" + type) + "&"
    if (seen !== undefined && seen !== null)
      url_ += "seen=" + encodeURIComponent("" + seen) + "&"
    if (read !== undefined && read !== null)
      url_ += "read=" + encodeURIComponent("" + read) + "&"
    if (from !== undefined && from !== null)
      url_ +=
        "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&"
    if (to !== undefined && to !== null)
      url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAll(_response)
      })
  }
  processGetAll(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(notificationId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Notification/{notificationId}"
    if (notificationId === undefined || notificationId === null)
      throw new Error("The parameter 'notificationId' must be defined.")
    url_ = url_.replace(
      "{notificationId}",
      encodeURIComponent("" + notificationId)
    )
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(notificationId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Notification/{notificationId}"
    if (notificationId === undefined || notificationId === null)
      throw new Error("The parameter 'notificationId' must be defined.")
    url_ = url_.replace(
      "{notificationId}",
      encodeURIComponent("" + notificationId)
    )
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(notificationId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Notification/{notificationId}"
    if (notificationId === undefined || notificationId === null)
      throw new Error("The parameter 'notificationId' must be defined.")
    url_ = url_.replace(
      "{notificationId}",
      encodeURIComponent("" + notificationId)
    )
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  markAllAsSeen(cancelToken) {
    let url_ = this.baseUrl + "/v1/Notification/MarkAllAsSeen"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "POST",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processMarkAllAsSeen(_response)
      })
  }
  processMarkAllAsSeen(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  markAllAsRead(cancelToken) {
    let url_ = this.baseUrl + "/v1/Notification/MarkAllAsRead"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "POST",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processMarkAllAsRead(_response)
      })
  }
  processMarkAllAsRead(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class ScheduledEmailClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param groupId (optional)
   */
  getAll(skip, take, groupId, cancelToken) {
    let url_ = this.baseUrl + "/v1/ScheduledEmail?"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (groupId !== undefined && groupId !== null)
      url_ += "groupId=" + encodeURIComponent("" + groupId) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAll(_response)
      })
  }
  processGetAll(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   */
  getAllForRecipient(recipientId, skip, take, cancelToken) {
    let url_ = this.baseUrl + "/v1/ScheduledEmail/Recipient/{recipientId}?"
    if (recipientId === undefined || recipientId === null)
      throw new Error("The parameter 'recipientId' must be defined.")
    url_ = url_.replace("{recipientId}", encodeURIComponent("" + recipientId))
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllForRecipient(_response)
      })
  }
  processGetAllForRecipient(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(scheduleId, cancelToken) {
    let url_ = this.baseUrl + "/v1/ScheduledEmail/{scheduleId}"
    if (scheduleId === undefined || scheduleId === null)
      throw new Error("The parameter 'scheduleId' must be defined.")
    url_ = url_.replace("{scheduleId}", encodeURIComponent("" + scheduleId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/ScheduledEmail/Create"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(scheduleId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/ScheduledEmail/{scheduleId}/Update"
    if (scheduleId === undefined || scheduleId === null)
      throw new Error("The parameter 'scheduleId' must be defined.")
    url_ = url_.replace("{scheduleId}", encodeURIComponent("" + scheduleId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(scheduleId, cancelToken) {
    let url_ = this.baseUrl + "/v1/ScheduledEmail/{scheduleId}/Delete"
    if (scheduleId === undefined || scheduleId === null)
      throw new Error("The parameter 'scheduleId' must be defined.")
    url_ = url_.replace("{scheduleId}", encodeURIComponent("" + scheduleId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  leave(scheduleId, cancelToken) {
    let url_ = this.baseUrl + "/v1/ScheduledEmail/{scheduleId}/Leave"
    if (scheduleId === undefined || scheduleId === null)
      throw new Error("The parameter 'scheduleId' must be defined.")
    url_ = url_.replace("{scheduleId}", encodeURIComponent("" + scheduleId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "POST",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processLeave(_response)
      })
  }
  processLeave(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class ObservationContentClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param published (optional)
   */
  getAll(definitionId, skip, take, published, cancelToken) {
    let url_ =
      this.baseUrl + "/v1/ObservationDefinition/{definitionId}/Content?"
    if (definitionId === undefined || definitionId === null)
      throw new Error("The parameter 'definitionId' must be defined.")
    url_ = url_.replace("{definitionId}", encodeURIComponent("" + definitionId))
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (published !== undefined && published !== null)
      url_ += "published=" + encodeURIComponent("" + published) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAll(_response)
      })
  }
  processGetAll(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(contentId, cancelToken) {
    let url_ = this.baseUrl + "/v1/ObservationContent/{contentId}"
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(contentId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/ObservationContent/{contentId}"
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(contentId, cancelToken) {
    let url_ = this.baseUrl + "/v1/ObservationContent/{contentId}"
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/ObservationContent"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  publish(contentId, cancelToken) {
    let url_ = this.baseUrl + "/v1/ObservationContent/{contentId}/Publish"
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "POST",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processPublish(_response)
      })
  }
  processPublish(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class ObservationClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  getAllForArea(options, cancelToken) {
    let url_ = this.baseUrl + "/v1/Observation/GetAllForArea"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(options)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllForArea(_response)
      })
  }
  processGetAllForArea(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param definitionId (optional)
   * @param from (optional)
   * @param to (optional)
   * @param friendly (optional)
   * @param anonymousUser (optional)
   */
  getAllForGroup(
    groupId,
    search,
    skip,
    take,
    definitionId,
    from,
    to,
    friendly,
    anonymousUser,
    cancelToken
  ) {
    let url_ = this.baseUrl + "/v1/Observation/Group/{groupId}?"
    if (groupId === undefined || groupId === null)
      throw new Error("The parameter 'groupId' must be defined.")
    url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId))
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (definitionId !== undefined && definitionId !== null)
      url_ += "definitionId=" + encodeURIComponent("" + definitionId) + "&"
    if (from !== undefined && from !== null)
      url_ +=
        "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&"
    if (to !== undefined && to !== null)
      url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&"
    if (friendly !== undefined && friendly !== null)
      url_ += "friendly=" + encodeURIComponent("" + friendly) + "&"
    if (anonymousUser !== undefined && anonymousUser !== null)
      url_ += "anonymousUser=" + encodeURIComponent("" + anonymousUser) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllForGroup(_response)
      })
  }
  processGetAllForGroup(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param definitionId (optional)
   * @param groupId (optional)
   * @param from (optional)
   * @param to (optional)
   * @param friendly (optional)
   */
  getAllForPublisher(
    publisherId,
    search,
    skip,
    take,
    definitionId,
    groupId,
    from,
    to,
    friendly,
    cancelToken
  ) {
    let url_ = this.baseUrl + "/v1/Observation/Publisher/{publisherId}?"
    if (publisherId === undefined || publisherId === null)
      throw new Error("The parameter 'publisherId' must be defined.")
    url_ = url_.replace("{publisherId}", encodeURIComponent("" + publisherId))
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (definitionId !== undefined && definitionId !== null)
      url_ += "definitionId=" + encodeURIComponent("" + definitionId) + "&"
    if (groupId !== undefined && groupId !== null)
      url_ += "groupId=" + encodeURIComponent("" + groupId) + "&"
    if (from !== undefined && from !== null)
      url_ +=
        "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&"
    if (to !== undefined && to !== null)
      url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&"
    if (friendly !== undefined && friendly !== null)
      url_ += "friendly=" + encodeURIComponent("" + friendly) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllForPublisher(_response)
      })
  }
  processGetAllForPublisher(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(observationId, friendly, cancelToken) {
    let url_ = this.baseUrl + "/v1/Observation/{observationId}?"
    if (observationId === undefined || observationId === null)
      throw new Error("The parameter 'observationId' must be defined.")
    url_ = url_.replace(
      "{observationId}",
      encodeURIComponent("" + observationId)
    )
    if (friendly !== undefined && friendly !== null)
      url_ += "friendly=" + encodeURIComponent("" + friendly) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(observationId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Observation/{observationId}"
    if (observationId === undefined || observationId === null)
      throw new Error("The parameter 'observationId' must be defined.")
    url_ = url_.replace(
      "{observationId}",
      encodeURIComponent("" + observationId)
    )
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(observationId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Observation/{observationId}"
    if (observationId === undefined || observationId === null)
      throw new Error("The parameter 'observationId' must be defined.")
    url_ = url_.replace(
      "{observationId}",
      encodeURIComponent("" + observationId)
    )
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Observation"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  predict(observationContentId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Observation/{observationContentId}/Predict"
    if (observationContentId === undefined || observationContentId === null)
      throw new Error("The parameter 'observationContentId' must be defined.")
    url_ = url_.replace(
      "{observationContentId}",
      encodeURIComponent("" + observationContentId)
    )
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processPredict(_response)
      })
  }
  processPredict(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  downloadFile(observationId, fileId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Observation/{observationId}/File/{fileId}"
    if (observationId === undefined || observationId === null)
      throw new Error("The parameter 'observationId' must be defined.")
    url_ = url_.replace(
      "{observationId}",
      encodeURIComponent("" + observationId)
    )
    if (fileId === undefined || fileId === null)
      throw new Error("The parameter 'fileId' must be defined.")
    url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      responseType: "blob",
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/octet-stream",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDownloadFile(_response)
      })
  }
  processDownloadFile(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Promise.resolve({
        fileName: fileName,
        status: status,
        data: new Blob([response.data], {
          type: response.headers["content-type"],
        }),
        headers: _headers,
      })
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class ObservationDefinitionClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
     * @param search (optional)
     * @param skip (optional)
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param programId (optional) - null/empty to show all
    - program ID to filter to specific program
    - "none" to filter to items not in any program
     */
  getAllForPublisher(publisherId, search, skip, take, programId, cancelToken) {
    let url_ =
      this.baseUrl + "/v1/ObservationDefinition/Publisher/{publisherId}?"
    if (publisherId === undefined || publisherId === null)
      throw new Error("The parameter 'publisherId' must be defined.")
    url_ = url_.replace("{publisherId}", encodeURIComponent("" + publisherId))
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (programId !== undefined && programId !== null)
      url_ += "programId=" + encodeURIComponent("" + programId) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllForPublisher(_response)
      })
  }
  processGetAllForPublisher(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/ObservationDefinition"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
     * @param search (optional)
     * @param skip (optional)
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param consumerId (optional)
     * @param publisherId (optional)
     * @param programId (optional) - null/empty to show all
    - program ID to filter to specific program
    - "none" to filter to items not in any program
     * @param itemId (optional)
     * @param activated (optional)
     */
  getAllByActivation(
    search,
    skip,
    take,
    consumerId,
    publisherId,
    programId,
    itemId,
    activated,
    cancelToken
  ) {
    let url_ = this.baseUrl + "/v1/ObservationDefinition?"
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (consumerId !== undefined && consumerId !== null)
      url_ += "consumerId=" + encodeURIComponent("" + consumerId) + "&"
    if (publisherId !== undefined && publisherId !== null)
      url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&"
    if (programId !== undefined && programId !== null)
      url_ += "programId=" + encodeURIComponent("" + programId) + "&"
    if (itemId !== undefined && itemId !== null)
      url_ += "itemId=" + encodeURIComponent("" + itemId) + "&"
    if (activated !== undefined && activated !== null)
      url_ += "activated=" + encodeURIComponent("" + activated) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllByActivation(_response)
      })
  }
  processGetAllByActivation(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(observationDefinitionId, settings, cancelToken) {
    let url_ =
      this.baseUrl + "/v1/ObservationDefinition/{observationDefinitionId}"
    if (
      observationDefinitionId === undefined ||
      observationDefinitionId === null
    )
      throw new Error(
        "The parameter 'observationDefinitionId' must be defined."
      )
    url_ = url_.replace(
      "{observationDefinitionId}",
      encodeURIComponent("" + observationDefinitionId)
    )
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(observationDefinitionId, cancelToken) {
    let url_ =
      this.baseUrl + "/v1/ObservationDefinition/{observationDefinitionId}"
    if (
      observationDefinitionId === undefined ||
      observationDefinitionId === null
    )
      throw new Error(
        "The parameter 'observationDefinitionId' must be defined."
      )
    url_ = url_.replace(
      "{observationDefinitionId}",
      encodeURIComponent("" + observationDefinitionId)
    )
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
     * @param search (optional)
     * @param skip (optional)
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param publisherId (optional)
     * @param programId (optional) - null/empty to show all
    - program ID to filter to specific program
    - "none" to filter to items not in any program
     * @param countryCode (optional)
     */
  getAllPublished(
    search,
    skip,
    take,
    publisherId,
    programId,
    countryCode,
    cancelToken
  ) {
    let url_ = this.baseUrl + "/v1/ObservationDefinition/Published?"
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (publisherId !== undefined && publisherId !== null)
      url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&"
    if (programId !== undefined && programId !== null)
      url_ += "programId=" + encodeURIComponent("" + programId) + "&"
    if (countryCode !== undefined && countryCode !== null)
      url_ += "countryCode=" + encodeURIComponent("" + countryCode) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllPublished(_response)
      })
  }
  processGetAllPublished(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(id, cancelToken) {
    let url_ = this.baseUrl + "/v1/ObservationDefinition/{id}"
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class ObservationFormClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   */
  getAllForObservationContent(contentId, skip, take, cancelToken) {
    let url_ = this.baseUrl + "/v1/ObservationContent/{contentId}/Form?"
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllForObservationContent(_response)
      })
  }
  processGetAllForObservationContent(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(observationFormId, cancelToken) {
    let url_ = this.baseUrl + "/v1/ObservationForm/{observationFormId}"
    if (observationFormId === undefined || observationFormId === null)
      throw new Error("The parameter 'observationFormId' must be defined.")
    url_ = url_.replace(
      "{observationFormId}",
      encodeURIComponent("" + observationFormId)
    )
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(observationFormId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/ObservationForm/{observationFormId}"
    if (observationFormId === undefined || observationFormId === null)
      throw new Error("The parameter 'observationFormId' must be defined.")
    url_ = url_.replace(
      "{observationFormId}",
      encodeURIComponent("" + observationFormId)
    )
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(observationFormId, cancelToken) {
    let url_ = this.baseUrl + "/v1/ObservationForm/{observationFormId}"
    if (observationFormId === undefined || observationFormId === null)
      throw new Error("The parameter 'observationFormId' must be defined.")
    url_ = url_.replace(
      "{observationFormId}",
      encodeURIComponent("" + observationFormId)
    )
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/ObservationForm"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class ObservationMigrationClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
     * Change the ownership (publisher) of an given observation definition, all related data including
    activations and observation will be transferred to the new publisher as well.
     */
  migrateObservationDefinition(observationDefinitionId, settings, cancelToken) {
    let url_ =
      this.baseUrl +
      "/v1/ObservationDefinition/{observationDefinitionId}/Migrate"
    if (
      observationDefinitionId === undefined ||
      observationDefinitionId === null
    )
      throw new Error(
        "The parameter 'observationDefinitionId' must be defined."
      )
    url_ = url_.replace(
      "{observationDefinitionId}",
      encodeURIComponent("" + observationDefinitionId)
    )
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processMigrateObservationDefinition(_response)
      })
  }
  processMigrateObservationDefinition(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
     * Create a duplicate copy of an observation definition under the same publisher.
            
    NOTE: this might run for a while if there are a lot of observations need to be migrated, when tested
    locally, 2400 observations took about 3 minutes to finish, as such, the command would be timeout but it
    will finish eventually, check the logs for progress.
     */
  duplicateObservationDefinition(
    observationDefinitionId,
    settings,
    cancelToken
  ) {
    let url_ =
      this.baseUrl +
      "/v1/ObservationDefinition/{observationDefinitionId}/Duplicate"
    if (
      observationDefinitionId === undefined ||
      observationDefinitionId === null
    )
      throw new Error(
        "The parameter 'observationDefinitionId' must be defined."
      )
    url_ = url_.replace(
      "{observationDefinitionId}",
      encodeURIComponent("" + observationDefinitionId)
    )
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDuplicateObservationDefinition(_response)
      })
  }
  processDuplicateObservationDefinition(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
   * @param definitionId (optional)
   * @param groupId (optional)
   * @deprecated
   */
  getObservationAnonymousUsers(definitionId, groupId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Observation/AnonymousUser?"
    if (definitionId !== undefined && definitionId !== null)
      url_ += "definitionId=" + encodeURIComponent("" + definitionId) + "&"
    if (groupId !== undefined && groupId !== null)
      url_ += "groupId=" + encodeURIComponent("" + groupId) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetObservationAnonymousUsers(_response)
      })
  }
  processGetObservationAnonymousUsers(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
   * @deprecated
   */
  batchMergeObservationAnonymousUsers(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Observation/AnonymousUser/BatchMerge"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processBatchMergeObservationAnonymousUsers(_response)
      })
  }
  processBatchMergeObservationAnonymousUsers(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class ObservationSettingsClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param definitionId (optional)
   * @param organisationId (optional)
   */
  getAll(skip, take, definitionId, organisationId, cancelToken) {
    let url_ = this.baseUrl + "/v1/ObservationSettings?"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (definitionId !== undefined && definitionId !== null)
      url_ += "definitionId=" + encodeURIComponent("" + definitionId) + "&"
    if (organisationId !== undefined && organisationId !== null)
      url_ += "organisationId=" + encodeURIComponent("" + organisationId) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAll(_response)
      })
  }
  processGetAll(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/ObservationSettings"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(settingsId, cancelToken) {
    let url_ = this.baseUrl + "/v1/ObservationSettings/{settingsId}"
    if (settingsId === undefined || settingsId === null)
      throw new Error("The parameter 'settingsId' must be defined.")
    url_ = url_.replace("{settingsId}", encodeURIComponent("" + settingsId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(settingsId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/ObservationSettings/{settingsId}"
    if (settingsId === undefined || settingsId === null)
      throw new Error("The parameter 'settingsId' must be defined.")
    url_ = url_.replace("{settingsId}", encodeURIComponent("" + settingsId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(settingsId, cancelToken) {
    let url_ = this.baseUrl + "/v1/ObservationSettings/{settingsId}"
    if (settingsId === undefined || settingsId === null)
      throw new Error("The parameter 'settingsId' must be defined.")
    url_ = url_.replace("{settingsId}", encodeURIComponent("" + settingsId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class CustomerClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  get(customerId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Customer/{customerId}"
    if (customerId === undefined || customerId === null)
      throw new Error("The parameter 'customerId' must be defined.")
    url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  getForUser(userId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Customer/User/{userId}"
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.")
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetForUser(_response)
      })
  }
  processGetForUser(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class MerchantClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  get(merchantId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Merchant/{merchantId}"
    if (merchantId === undefined || merchantId === null)
      throw new Error("The parameter 'merchantId' must be defined.")
    url_ = url_.replace("{merchantId}", encodeURIComponent("" + merchantId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  getForOrganisation(organisationId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Merchant/Organisation/{organisationId}"
    if (organisationId === undefined || organisationId === null)
      throw new Error("The parameter 'organisationId' must be defined.")
    url_ = url_.replace(
      "{organisationId}",
      encodeURIComponent("" + organisationId)
    )
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetForOrganisation(_response)
      })
  }
  processGetForOrganisation(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  createUrl(publisherId, redirectUrl, cancelToken) {
    let url_ = this.baseUrl + "/v1/Merchant/CreateUrl?"
    if (publisherId !== undefined && publisherId !== null)
      url_ += "PublisherId=" + encodeURIComponent("" + publisherId) + "&"
    if (redirectUrl !== undefined && redirectUrl !== null)
      url_ += "RedirectUrl=" + encodeURIComponent("" + redirectUrl) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreateUrl(_response)
      })
  }
  processCreateUrl(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(scope, state, code, cancelToken) {
    let url_ = this.baseUrl + "/v1/Merchant?"
    if (scope !== undefined && scope !== null)
      url_ += "scope=" + encodeURIComponent("" + scope) + "&"
    if (state !== undefined && state !== null)
      url_ += "state=" + encodeURIComponent("" + state) + "&"
    if (code !== undefined && code !== null)
      url_ += "code=" + encodeURIComponent("" + code) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      responseType: "blob",
      method: "POST",
      url: url_,
      headers: {
        Accept: "application/octet-stream",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Promise.resolve({
        fileName: fileName,
        status: status,
        data: new Blob([response.data], {
          type: response.headers["content-type"],
        }),
        headers: _headers,
      })
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class PaymentClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  get(paymentId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Payment/{paymentId}"
    if (paymentId === undefined || paymentId === null)
      throw new Error("The parameter 'paymentId' must be defined.")
    url_ = url_.replace("{paymentId}", encodeURIComponent("" + paymentId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Payment"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class PaymentSettingsClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  publicKey(cancelToken) {
    let url_ = this.baseUrl + "/v1/PaymentSettings/PublicKey"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processPublicKey(_response)
      })
  }
  processPublicKey(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  regions(cancelToken) {
    let url_ = this.baseUrl + "/v1/PaymentSettings/Regions"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processRegions(_response)
      })
  }
  processRegions(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  countries(cancelToken) {
    let url_ = this.baseUrl + "/v1/PaymentSettings/Countries"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCountries(_response)
      })
  }
  processCountries(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  currencies(cancelToken) {
    let url_ = this.baseUrl + "/v1/PaymentSettings/Currencies"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCurrencies(_response)
      })
  }
  processCurrencies(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class ProductClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param publisherId (optional)
   * @param countryCode (optional)
   */
  getAll(search, skip, take, publisherId, countryCode, cancelToken) {
    let url_ = this.baseUrl + "/v1/Product?"
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (publisherId !== undefined && publisherId !== null)
      url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&"
    if (countryCode !== undefined && countryCode !== null)
      url_ += "countryCode=" + encodeURIComponent("" + countryCode) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAll(_response)
      })
  }
  processGetAll(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Product"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(productId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Product/{productId}"
    if (productId === undefined || productId === null)
      throw new Error("The parameter 'productId' must be defined.")
    url_ = url_.replace("{productId}", encodeURIComponent("" + productId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(productId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Product/{productId}"
    if (productId === undefined || productId === null)
      throw new Error("The parameter 'productId' must be defined.")
    url_ = url_.replace("{productId}", encodeURIComponent("" + productId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(productId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Product/{productId}"
    if (productId === undefined || productId === null)
      throw new Error("The parameter 'productId' must be defined.")
    url_ = url_.replace("{productId}", encodeURIComponent("" + productId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class PublisherClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   */
  getAll(search, skip, take, cancelToken) {
    let url_ = this.baseUrl + "/v1/Publisher?"
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAll(_response)
      })
  }
  processGetAll(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(publisherId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Publisher/{publisherId}"
    if (publisherId === undefined || publisherId === null)
      throw new Error("The parameter 'publisherId' must be defined.")
    url_ = url_.replace("{publisherId}", encodeURIComponent("" + publisherId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  request(publisherId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Publisher/{publisherId}/Request"
    if (publisherId === undefined || publisherId === null)
      throw new Error("The parameter 'publisherId' must be defined.")
    url_ = url_.replace("{publisherId}", encodeURIComponent("" + publisherId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processRequest(_response)
      })
  }
  processRequest(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  approve(publisherId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Publisher/{publisherId}/Approve"
    if (publisherId === undefined || publisherId === null)
      throw new Error("The parameter 'publisherId' must be defined.")
    url_ = url_.replace("{publisherId}", encodeURIComponent("" + publisherId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processApprove(_response)
      })
  }
  processApprove(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class StripeClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  event(cancelToken) {
    let url_ = this.baseUrl + "/v1/Stripe/Event"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      responseType: "blob",
      method: "POST",
      url: url_,
      headers: {
        Accept: "application/octet-stream",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processEvent(_response)
      })
  }
  processEvent(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Promise.resolve({
        fileName: fileName,
        status: status,
        data: new Blob([response.data], {
          type: response.headers["content-type"],
        }),
        headers: _headers,
      })
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class TaskFileClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  getAll(taskId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Task/{taskId}/File"
    if (taskId === undefined || taskId === null)
      throw new Error("The parameter 'taskId' must be defined.")
    url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAll(_response)
      })
  }
  processGetAll(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(taskId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Task/{taskId}/File"
    if (taskId === undefined || taskId === null)
      throw new Error("The parameter 'taskId' must be defined.")
    url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(taskId, fileId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Task/{taskId}/File/{fileId}"
    if (taskId === undefined || taskId === null)
      throw new Error("The parameter 'taskId' must be defined.")
    url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId))
    if (fileId === undefined || fileId === null)
      throw new Error("The parameter 'fileId' must be defined.")
    url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(taskId, fileId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Task/{taskId}/File/{fileId}"
    if (taskId === undefined || taskId === null)
      throw new Error("The parameter 'taskId' must be defined.")
    url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId))
    if (fileId === undefined || fileId === null)
      throw new Error("The parameter 'fileId' must be defined.")
    url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(taskId, fileId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Task/{taskId}/File/{fileId}"
    if (taskId === undefined || taskId === null)
      throw new Error("The parameter 'taskId' must be defined.")
    url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId))
    if (fileId === undefined || fileId === null)
      throw new Error("The parameter 'fileId' must be defined.")
    url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  download(taskId, fileId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Task/{taskId}/File/{fileId}/Download"
    if (taskId === undefined || taskId === null)
      throw new Error("The parameter 'taskId' must be defined.")
    url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId))
    if (fileId === undefined || fileId === null)
      throw new Error("The parameter 'fileId' must be defined.")
    url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      responseType: "blob",
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/octet-stream",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDownload(_response)
      })
  }
  processDownload(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Promise.resolve({
        fileName: fileName,
        status: status,
        data: new Blob([response.data], {
          type: response.headers["content-type"],
        }),
        headers: _headers,
      })
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class ImplementationClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param publisherId (optional)
   * @param consumerId (optional)
   * @param teamId (optional)
   */
  getAll(search, skip, take, publisherId, consumerId, teamId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Implementation?"
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (publisherId !== undefined && publisherId !== null)
      url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&"
    if (consumerId !== undefined && consumerId !== null)
      url_ += "consumerId=" + encodeURIComponent("" + consumerId) + "&"
    if (teamId !== undefined && teamId !== null)
      url_ += "teamId=" + encodeURIComponent("" + teamId) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAll(_response)
      })
  }
  processGetAll(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Implementation"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(implementationId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Implementation/{implementationId}"
    if (implementationId === undefined || implementationId === null)
      throw new Error("The parameter 'implementationId' must be defined.")
    url_ = url_.replace(
      "{implementationId}",
      encodeURIComponent("" + implementationId)
    )
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(implementationId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Implementation/{implementationId}"
    if (implementationId === undefined || implementationId === null)
      throw new Error("The parameter 'implementationId' must be defined.")
    url_ = url_.replace(
      "{implementationId}",
      encodeURIComponent("" + implementationId)
    )
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(implementationId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Implementation/{implementationId}"
    if (implementationId === undefined || implementationId === null)
      throw new Error("The parameter 'implementationId' must be defined.")
    url_ = url_.replace(
      "{implementationId}",
      encodeURIComponent("" + implementationId)
    )
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   */
  getAllTasks(implementationId, search, skip, take, cancelToken) {
    let url_ = this.baseUrl + "/v1/Implementation/{implementationId}/Task?"
    if (implementationId === undefined || implementationId === null)
      throw new Error("The parameter 'implementationId' must be defined.")
    url_ = url_.replace(
      "{implementationId}",
      encodeURIComponent("" + implementationId)
    )
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllTasks(_response)
      })
  }
  processGetAllTasks(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class ItemActivationClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
     * @param search (optional)
     * @param skip (optional)
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param itemType (optional)
     * @param programId (optional) - null/empty to show all
    - program ID to filter to specific program
    - "none" to filter to items not in any program
     * @param consumerId (optional)
     * @param includeDeactivated (optional)
     */
  getAllForPublisher(
    publisherId,
    search,
    skip,
    take,
    itemType,
    programId,
    consumerId,
    includeDeactivated,
    cancelToken
  ) {
    let url_ = this.baseUrl + "/v1/ItemActivation/Publisher/{publisherId}?"
    if (publisherId === undefined || publisherId === null)
      throw new Error("The parameter 'publisherId' must be defined.")
    url_ = url_.replace("{publisherId}", encodeURIComponent("" + publisherId))
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (itemType !== undefined && itemType !== null)
      url_ += "itemType=" + encodeURIComponent("" + itemType) + "&"
    if (programId !== undefined && programId !== null)
      url_ += "programId=" + encodeURIComponent("" + programId) + "&"
    if (consumerId !== undefined && consumerId !== null)
      url_ += "consumerId=" + encodeURIComponent("" + consumerId) + "&"
    if (includeDeactivated !== undefined && includeDeactivated !== null)
      url_ +=
        "includeDeactivated=" +
        encodeURIComponent("" + includeDeactivated) +
        "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllForPublisher(_response)
      })
  }
  processGetAllForPublisher(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
     * @param search (optional)
     * @param skip (optional)
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param consumerId (optional)
     * @param itemType (optional)
     * @param itemId (optional)
     * @param programId (optional) - null/empty to show all
    - program ID to filter to specific program
    - "none" to filter to items not in any program
     * @param publisherId (optional)
     */
  getAllByActivation(
    search,
    skip,
    take,
    consumerId,
    itemType,
    itemId,
    programId,
    publisherId,
    cancelToken
  ) {
    let url_ = this.baseUrl + "/v1/ItemActivation?"
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (consumerId !== undefined && consumerId !== null)
      url_ += "consumerId=" + encodeURIComponent("" + consumerId) + "&"
    if (itemType !== undefined && itemType !== null)
      url_ += "itemType=" + encodeURIComponent("" + itemType) + "&"
    if (itemId !== undefined && itemId !== null)
      url_ += "itemId=" + encodeURIComponent("" + itemId) + "&"
    if (programId !== undefined && programId !== null)
      url_ += "programId=" + encodeURIComponent("" + programId) + "&"
    if (publisherId !== undefined && publisherId !== null)
      url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllByActivation(_response)
      })
  }
  processGetAllByActivation(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(consumerId, itemId, cancelToken) {
    let url_ = this.baseUrl + "/v1/ItemActivation?"
    if (consumerId !== undefined && consumerId !== null)
      url_ += "consumerId=" + encodeURIComponent("" + consumerId) + "&"
    if (itemId !== undefined && itemId !== null)
      url_ += "itemId=" + encodeURIComponent("" + itemId) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "POST",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(itemActivationId, cancelToken) {
    let url_ = this.baseUrl + "/v1/ItemActivation/{itemActivationId}"
    if (itemActivationId === undefined || itemActivationId === null)
      throw new Error("The parameter 'itemActivationId' must be defined.")
    url_ = url_.replace(
      "{itemActivationId}",
      encodeURIComponent("" + itemActivationId)
    )
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(itemActivationId, activated, cancelToken) {
    let url_ = this.baseUrl + "/v1/ItemActivation/{itemActivationId}?"
    if (itemActivationId === undefined || itemActivationId === null)
      throw new Error("The parameter 'itemActivationId' must be defined.")
    url_ = url_.replace(
      "{itemActivationId}",
      encodeURIComponent("" + itemActivationId)
    )
    if (activated === null)
      throw new Error("The parameter 'activated' cannot be null.")
    else if (activated !== undefined)
      url_ += "activated=" + encodeURIComponent("" + activated) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "PUT",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get2(itemId, consumerId, cancelToken) {
    let url_ =
      this.baseUrl + "/v1/ItemActivation/Item/{itemId}/Consumer/{consumerId}"
    if (itemId === undefined || itemId === null)
      throw new Error("The parameter 'itemId' must be defined.")
    url_ = url_.replace("{itemId}", encodeURIComponent("" + itemId))
    if (consumerId === undefined || consumerId === null)
      throw new Error("The parameter 'consumerId' must be defined.")
    url_ = url_.replace("{consumerId}", encodeURIComponent("" + consumerId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet2(_response)
      })
  }
  processGet2(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class ProgramActivationClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param programId (optional)
   * @param consumerId (optional)
   */
  getAll(search, skip, take, programId, consumerId, cancelToken) {
    let url_ = this.baseUrl + "/v1/ProgramActivation?"
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (programId !== undefined && programId !== null)
      url_ += "programId=" + encodeURIComponent("" + programId) + "&"
    if (consumerId !== undefined && consumerId !== null)
      url_ += "consumerId=" + encodeURIComponent("" + consumerId) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAll(_response)
      })
  }
  processGetAll(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param programId (optional)
   */
  getAllForPublisher(publisherId, search, skip, take, programId, cancelToken) {
    let url_ = this.baseUrl + "/v1/ProgramActivation/Publisher/{publisherId}?"
    if (publisherId === undefined || publisherId === null)
      throw new Error("The parameter 'publisherId' must be defined.")
    url_ = url_.replace("{publisherId}", encodeURIComponent("" + publisherId))
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (programId !== undefined && programId !== null)
      url_ += "programId=" + encodeURIComponent("" + programId) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllForPublisher(_response)
      })
  }
  processGetAllForPublisher(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(id, cancelToken) {
    let url_ = this.baseUrl + "/v1/ProgramActivation/{id}"
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get2(programId, consumerId, cancelToken) {
    let url_ =
      this.baseUrl +
      "/v1/ProgramActivation/Program/{programId}/Consumer/{consumerId}"
    if (programId === undefined || programId === null)
      throw new Error("The parameter 'programId' must be defined.")
    url_ = url_.replace("{programId}", encodeURIComponent("" + programId))
    if (consumerId === undefined || consumerId === null)
      throw new Error("The parameter 'consumerId' must be defined.")
    url_ = url_.replace("{consumerId}", encodeURIComponent("" + consumerId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet2(_response)
      })
  }
  processGet2(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  createByPhase(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/ProgramActivation/ProgramPhase"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreateByPhase(_response)
      })
  }
  processCreateByPhase(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  setCurrentPhase(programActivationId, programPhaseId, cancelToken) {
    let url_ =
      this.baseUrl +
      "/v1/ProgramActivation/{programActivationId}/ProgramPhase/{programPhaseId}/SetCurrent"
    if (programActivationId === undefined || programActivationId === null)
      throw new Error("The parameter 'programActivationId' must be defined.")
    url_ = url_.replace(
      "{programActivationId}",
      encodeURIComponent("" + programActivationId)
    )
    if (programPhaseId === undefined || programPhaseId === null)
      throw new Error("The parameter 'programPhaseId' must be defined.")
    url_ = url_.replace(
      "{programPhaseId}",
      encodeURIComponent("" + programPhaseId)
    )
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "POST",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processSetCurrentPhase(_response)
      })
  }
  processSetCurrentPhase(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  deactivate(programActivationId, programPhaseId, cancelToken) {
    let url_ =
      this.baseUrl +
      "/v1/ProgramActivation/{programActivationId}/ProgramPhase/{programPhaseId}/Deactivate"
    if (programActivationId === undefined || programActivationId === null)
      throw new Error("The parameter 'programActivationId' must be defined.")
    url_ = url_.replace(
      "{programActivationId}",
      encodeURIComponent("" + programActivationId)
    )
    if (programPhaseId === undefined || programPhaseId === null)
      throw new Error("The parameter 'programPhaseId' must be defined.")
    url_ = url_.replace(
      "{programPhaseId}",
      encodeURIComponent("" + programPhaseId)
    )
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "POST",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDeactivate(_response)
      })
  }
  processDeactivate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class ProgramClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   */
  getAllForPublisher(publisherId, search, skip, take, cancelToken) {
    let url_ = this.baseUrl + "/v1/Program/Publisher/{publisherId}?"
    if (publisherId === undefined || publisherId === null)
      throw new Error("The parameter 'publisherId' must be defined.")
    url_ = url_.replace("{publisherId}", encodeURIComponent("" + publisherId))
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllForPublisher(_response)
      })
  }
  processGetAllForPublisher(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
     * @param search (optional)
     * @param skip (optional)
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param publisherId (optional)
     * @param programId (optional) - null/empty to show all
    - program ID to filter to specific program
     * @param countryCode (optional)
     */
  getAllPublished(
    search,
    skip,
    take,
    publisherId,
    programId,
    countryCode,
    cancelToken
  ) {
    let url_ = this.baseUrl + "/v1/Program/Published?"
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (publisherId !== undefined && publisherId !== null)
      url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&"
    if (programId !== undefined && programId !== null)
      url_ += "programId=" + encodeURIComponent("" + programId) + "&"
    if (countryCode !== undefined && countryCode !== null)
      url_ += "countryCode=" + encodeURIComponent("" + countryCode) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllPublished(_response)
      })
  }
  processGetAllPublished(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param consumerId (optional)
   * @param publisherId (optional)
   * @param itemId (optional)
   * @param activated (optional)
   */
  getAllByActivation(
    search,
    skip,
    take,
    consumerId,
    publisherId,
    itemId,
    activated,
    cancelToken
  ) {
    let url_ = this.baseUrl + "/v1/Program?"
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (consumerId !== undefined && consumerId !== null)
      url_ += "consumerId=" + encodeURIComponent("" + consumerId) + "&"
    if (publisherId !== undefined && publisherId !== null)
      url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&"
    if (itemId !== undefined && itemId !== null)
      url_ += "itemId=" + encodeURIComponent("" + itemId) + "&"
    if (activated !== undefined && activated !== null)
      url_ += "activated=" + encodeURIComponent("" + activated) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllByActivation(_response)
      })
  }
  processGetAllByActivation(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Program"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(id, cancelToken) {
    let url_ = this.baseUrl + "/v1/Program/{id}"
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(programId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Program/{programId}"
    if (programId === undefined || programId === null)
      throw new Error("The parameter 'programId' must be defined.")
    url_ = url_.replace("{programId}", encodeURIComponent("" + programId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(programId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Program/{programId}"
    if (programId === undefined || programId === null)
      throw new Error("The parameter 'programId' must be defined.")
    url_ = url_.replace("{programId}", encodeURIComponent("" + programId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class ProgramPhaseClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  get(id, cancelToken) {
    let url_ = this.baseUrl + "/v1/ProgramPhase/{id}"
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/ProgramPhase"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(programPhaseId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/ProgramPhase/{programPhaseId}"
    if (programPhaseId === undefined || programPhaseId === null)
      throw new Error("The parameter 'programPhaseId' must be defined.")
    url_ = url_.replace(
      "{programPhaseId}",
      encodeURIComponent("" + programPhaseId)
    )
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(programPhaseId, cancelToken) {
    let url_ = this.baseUrl + "/v1/ProgramPhase/{programPhaseId}"
    if (programPhaseId === undefined || programPhaseId === null)
      throw new Error("The parameter 'programPhaseId' must be defined.")
    url_ = url_.replace(
      "{programPhaseId}",
      encodeURIComponent("" + programPhaseId)
    )
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class TaskCommentClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   */
  getAll(taskId, search, skip, take, cancelToken) {
    let url_ = this.baseUrl + "/v1/Task/{taskId}/Comment?"
    if (taskId === undefined || taskId === null)
      throw new Error("The parameter 'taskId' must be defined.")
    url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId))
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAll(_response)
      })
  }
  processGetAll(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(taskId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Task/{taskId}/Comment"
    if (taskId === undefined || taskId === null)
      throw new Error("The parameter 'taskId' must be defined.")
    url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(taskId, commentId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Task/{taskId}/Comment/{commentId}"
    if (taskId === undefined || taskId === null)
      throw new Error("The parameter 'taskId' must be defined.")
    url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId))
    if (commentId === undefined || commentId === null)
      throw new Error("The parameter 'commentId' must be defined.")
    url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(taskId, commentId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Task/{taskId}/Comment/{commentId}"
    if (taskId === undefined || taskId === null)
      throw new Error("The parameter 'taskId' must be defined.")
    url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId))
    if (commentId === undefined || commentId === null)
      throw new Error("The parameter 'commentId' must be defined.")
    url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(taskId, commentId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Task/{taskId}/Comment/{commentId}"
    if (taskId === undefined || taskId === null)
      throw new Error("The parameter 'taskId' must be defined.")
    url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId))
    if (commentId === undefined || commentId === null)
      throw new Error("The parameter 'commentId' must be defined.")
    url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   */
  getAllReplies(taskId, commentId, search, skip, take, cancelToken) {
    let url_ = this.baseUrl + "/v1/Task/{taskId}/Comment/{commentId}/Reply?"
    if (taskId === undefined || taskId === null)
      throw new Error("The parameter 'taskId' must be defined.")
    url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId))
    if (commentId === undefined || commentId === null)
      throw new Error("The parameter 'commentId' must be defined.")
    url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId))
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllReplies(_response)
      })
  }
  processGetAllReplies(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class TaskClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param implementationId (optional)
   */
  getAll(search, skip, take, implementationId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Task?"
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (implementationId !== undefined && implementationId !== null)
      url_ +=
        "implementationId=" + encodeURIComponent("" + implementationId) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAll(_response)
      })
  }
  processGetAll(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Task"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(taskId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Task/{taskId}"
    if (taskId === undefined || taskId === null)
      throw new Error("The parameter 'taskId' must be defined.")
    url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(taskId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Task/{taskId}"
    if (taskId === undefined || taskId === null)
      throw new Error("The parameter 'taskId' must be defined.")
    url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(taskId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Task/{taskId}"
    if (taskId === undefined || taskId === null)
      throw new Error("The parameter 'taskId' must be defined.")
    url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class SharingClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  getByAlias(aliasId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Sharing/Alias/{aliasId}"
    if (aliasId === undefined || aliasId === null)
      throw new Error("The parameter 'aliasId' must be defined.")
    url_ = url_.replace("{aliasId}", encodeURIComponent("" + aliasId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetByAlias(_response)
      })
  }
  processGetByAlias(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(sharingId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Sharing/{sharingId}"
    if (sharingId === undefined || sharingId === null)
      throw new Error("The parameter 'sharingId' must be defined.")
    url_ = url_.replace("{sharingId}", encodeURIComponent("" + sharingId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   */
  getAllGroupInvitationsForGroup(groupId, search, skip, take, cancelToken) {
    let url_ = this.baseUrl + "/v1/Sharing/GroupInvitation/Group/{groupId}?"
    if (groupId === undefined || groupId === null)
      throw new Error("The parameter 'groupId' must be defined.")
    url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId))
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllGroupInvitationsForGroup(_response)
      })
  }
  processGetAllGroupInvitationsForGroup(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  createForGroupInvitation(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Sharing/GroupInvitation"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreateForGroupInvitation(_response)
      })
  }
  processCreateForGroupInvitation(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class TicketClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param userId (optional)
   */
  getAll(search, skip, take, userId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Ticket?"
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (userId !== undefined && userId !== null)
      url_ += "userId=" + encodeURIComponent("" + userId) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAll(_response)
      })
  }
  processGetAll(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Ticket"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(ticketId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Ticket/{ticketId}"
    if (ticketId === undefined || ticketId === null)
      throw new Error("The parameter 'ticketId' must be defined.")
    url_ = url_.replace("{ticketId}", encodeURIComponent("" + ticketId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(ticketId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Ticket/{ticketId}"
    if (ticketId === undefined || ticketId === null)
      throw new Error("The parameter 'ticketId' must be defined.")
    url_ = url_.replace("{ticketId}", encodeURIComponent("" + ticketId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class SurveyContentClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   */
  getAll(surveyId, skip, take, cancelToken) {
    let url_ = this.baseUrl + "/v1/Survey/{surveyId}/Content?"
    if (surveyId === undefined || surveyId === null)
      throw new Error("The parameter 'surveyId' must be defined.")
    url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId))
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAll(_response)
      })
  }
  processGetAll(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(surveyId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Survey/{surveyId}/Content"
    if (surveyId === undefined || surveyId === null)
      throw new Error("The parameter 'surveyId' must be defined.")
    url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(surveyId, contentId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Survey/{surveyId}/Content/{contentId}"
    if (surveyId === undefined || surveyId === null)
      throw new Error("The parameter 'surveyId' must be defined.")
    url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId))
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(surveyId, contentId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Survey/{surveyId}/Content/{contentId}"
    if (surveyId === undefined || surveyId === null)
      throw new Error("The parameter 'surveyId' must be defined.")
    url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId))
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(surveyId, contentId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Survey/{surveyId}/Content/{contentId}"
    if (surveyId === undefined || surveyId === null)
      throw new Error("The parameter 'surveyId' must be defined.")
    url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId))
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  publish(surveyId, contentId, cancelToken) {
    let url_ = this.baseUrl + "/v1/{contentId}/Publish?"
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    if (surveyId !== undefined && surveyId !== null)
      url_ += "surveyId=" + encodeURIComponent("" + surveyId) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "PUT",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processPublish(_response)
      })
  }
  processPublish(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  questionTypes(cancelToken) {
    let url_ = this.baseUrl + "/v1/SurveyContent/QuestionTypes"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processQuestionTypes(_response)
      })
  }
  processQuestionTypes(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  answerTypes(cancelToken) {
    let url_ = this.baseUrl + "/v1/SurveyContent/AnswerTypes"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processAnswerTypes(_response)
      })
  }
  processAnswerTypes(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  example(cancelToken) {
    let url_ = this.baseUrl + "/v1/SurveyContent/Example"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processExample(_response)
      })
  }
  processExample(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  schema(cancelToken) {
    let url_ = this.baseUrl + "/v1/SurveyContent/Schema"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      responseType: "blob",
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/octet-stream",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processSchema(_response)
      })
  }
  processSchema(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Promise.resolve({
        fileName: fileName,
        status: status,
        data: new Blob([response.data], {
          type: response.headers["content-type"],
        }),
        headers: _headers,
      })
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class SurveyClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   */
  getAllForPublisher(publisherId, search, skip, take, cancelToken) {
    let url_ = this.baseUrl + "/v1/Survey/Publisher/{publisherId}?"
    if (publisherId === undefined || publisherId === null)
      throw new Error("The parameter 'publisherId' must be defined.")
    url_ = url_.replace("{publisherId}", encodeURIComponent("" + publisherId))
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllForPublisher(_response)
      })
  }
  processGetAllForPublisher(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Survey"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
     * @param search (optional)
     * @param skip (optional)
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param consumerId (optional)
     * @param publisherId (optional)
     * @param programId (optional) - null/empty to show all
    - program ID to filter to specific program
    - "none" to filter to items not in any program
     * @param itemId (optional)
     * @param activated (optional)
     */
  getAllByActivation(
    search,
    skip,
    take,
    consumerId,
    publisherId,
    programId,
    itemId,
    activated,
    cancelToken
  ) {
    let url_ = this.baseUrl + "/v1/Survey?"
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (consumerId !== undefined && consumerId !== null)
      url_ += "consumerId=" + encodeURIComponent("" + consumerId) + "&"
    if (publisherId !== undefined && publisherId !== null)
      url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&"
    if (programId !== undefined && programId !== null)
      url_ += "programId=" + encodeURIComponent("" + programId) + "&"
    if (itemId !== undefined && itemId !== null)
      url_ += "itemId=" + encodeURIComponent("" + itemId) + "&"
    if (activated !== undefined && activated !== null)
      url_ += "activated=" + encodeURIComponent("" + activated) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllByActivation(_response)
      })
  }
  processGetAllByActivation(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(id, cancelToken) {
    let url_ = this.baseUrl + "/v1/Survey/{id}"
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(surveyId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Survey/{surveyId}"
    if (surveyId === undefined || surveyId === null)
      throw new Error("The parameter 'surveyId' must be defined.")
    url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(surveyId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Survey/{surveyId}"
    if (surveyId === undefined || surveyId === null)
      throw new Error("The parameter 'surveyId' must be defined.")
    url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
     * @param search (optional)
     * @param skip (optional)
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param publisherId (optional)
     * @param programId (optional) - null/empty to show all
    - program ID to filter to specific program
    - "none" to filter to items not in any program
     * @param countryCode (optional)
     */
  getAllPublished(
    search,
    skip,
    take,
    publisherId,
    programId,
    countryCode,
    cancelToken
  ) {
    let url_ = this.baseUrl + "/v1/Survey/Published?"
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (publisherId !== undefined && publisherId !== null)
      url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&"
    if (programId !== undefined && programId !== null)
      url_ += "programId=" + encodeURIComponent("" + programId) + "&"
    if (countryCode !== undefined && countryCode !== null)
      url_ += "countryCode=" + encodeURIComponent("" + countryCode) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllPublished(_response)
      })
  }
  processGetAllPublished(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class SurveyRequestClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param surveyId (optional)
   */
  getAllForGroup(groupId, search, skip, take, surveyId, cancelToken) {
    let url_ = this.baseUrl + "/v1/SurveyRequest/Group/{groupId}?"
    if (groupId === undefined || groupId === null)
      throw new Error("The parameter 'groupId' must be defined.")
    url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId))
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (surveyId !== undefined && surveyId !== null)
      url_ += "surveyId=" + encodeURIComponent("" + surveyId) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllForGroup(_response)
      })
  }
  processGetAllForGroup(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(requestId, cancelToken) {
    let url_ = this.baseUrl + "/v1/SurveyRequest/{requestId}"
    if (requestId === undefined || requestId === null)
      throw new Error("The parameter 'requestId' must be defined.")
    url_ = url_.replace("{requestId}", encodeURIComponent("" + requestId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(requestId, cancelToken) {
    let url_ = this.baseUrl + "/v1/SurveyRequest/{requestId}"
    if (requestId === undefined || requestId === null)
      throw new Error("The parameter 'requestId' must be defined.")
    url_ = url_.replace("{requestId}", encodeURIComponent("" + requestId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  getForToken(token, cancelToken) {
    let url_ = this.baseUrl + "/v1/SurveyRequest/Token/{token}"
    if (token === undefined || token === null)
      throw new Error("The parameter 'token' must be defined.")
    url_ = url_.replace("{token}", encodeURIComponent("" + token))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetForToken(_response)
      })
  }
  processGetForToken(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/SurveyRequest"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class SurveyResponseClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param groupId (optional)
   * @param publisherId (optional)
   * @param contentId (optional)
   * @param jobTypeId (optional)
   * @param submitted (optional)
   */
  getAllForSurvey(
    surveyId,
    search,
    skip,
    take,
    groupId,
    publisherId,
    contentId,
    jobTypeId,
    submitted,
    cancelToken
  ) {
    let url_ = this.baseUrl + "/v1/SurveyResponse/Survey/{surveyId}?"
    if (surveyId === undefined || surveyId === null)
      throw new Error("The parameter 'surveyId' must be defined.")
    url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId))
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (groupId !== undefined && groupId !== null)
      url_ += "groupId=" + encodeURIComponent("" + groupId) + "&"
    if (publisherId !== undefined && publisherId !== null)
      url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&"
    if (contentId !== undefined && contentId !== null)
      url_ += "contentId=" + encodeURIComponent("" + contentId) + "&"
    if (jobTypeId !== undefined && jobTypeId !== null)
      url_ += "jobTypeId=" + encodeURIComponent("" + jobTypeId) + "&"
    if (submitted !== undefined && submitted !== null)
      url_ += "submitted=" + encodeURIComponent("" + submitted) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllForSurvey(_response)
      })
  }
  processGetAllForSurvey(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param surveyId (optional)
   * @param submitted (optional)
   */
  getAllForRespondent(
    respondentId,
    search,
    skip,
    take,
    surveyId,
    submitted,
    cancelToken
  ) {
    let url_ = this.baseUrl + "/v1/SurveyResponse/Respondent/{respondentId}?"
    if (respondentId === undefined || respondentId === null)
      throw new Error("The parameter 'respondentId' must be defined.")
    url_ = url_.replace("{respondentId}", encodeURIComponent("" + respondentId))
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (surveyId !== undefined && surveyId !== null)
      url_ += "surveyId=" + encodeURIComponent("" + surveyId) + "&"
    if (submitted !== undefined && submitted !== null)
      url_ += "submitted=" + encodeURIComponent("" + submitted) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllForRespondent(_response)
      })
  }
  processGetAllForRespondent(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(responseId, cancelToken) {
    let url_ = this.baseUrl + "/v1/SurveyResponse/{responseId}"
    if (responseId === undefined || responseId === null)
      throw new Error("The parameter 'responseId' must be defined.")
    url_ = url_.replace("{responseId}", encodeURIComponent("" + responseId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(responseId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/SurveyResponse/{responseId}"
    if (responseId === undefined || responseId === null)
      throw new Error("The parameter 'responseId' must be defined.")
    url_ = url_.replace("{responseId}", encodeURIComponent("" + responseId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(surveyId, responseId, cancelToken) {
    let url_ = this.baseUrl + "/v1/SurveyResponse/{responseId}?"
    if (responseId === undefined || responseId === null)
      throw new Error("The parameter 'responseId' must be defined.")
    url_ = url_.replace("{responseId}", encodeURIComponent("" + responseId))
    if (surveyId !== undefined && surveyId !== null)
      url_ += "surveyId=" + encodeURIComponent("" + surveyId) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/SurveyResponse"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class ActorClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  get(actorId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Actor/{actorId}"
    if (actorId === undefined || actorId === null)
      throw new Error("The parameter 'actorId' must be defined.")
    url_ = url_.replace("{actorId}", encodeURIComponent("" + actorId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class BookAttemptClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param moduleId (optional)
   */
  getAllForActor(actorId, search, skip, take, moduleId, cancelToken) {
    let url_ = this.baseUrl + "/v1/BookAttempt/Actor/{actorId}?"
    if (actorId === undefined || actorId === null)
      throw new Error("The parameter 'actorId' must be defined.")
    url_ = url_.replace("{actorId}", encodeURIComponent("" + actorId))
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (moduleId !== undefined && moduleId !== null)
      url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllForActor(_response)
      })
  }
  processGetAllForActor(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param moduleId (optional)
   * @param actorType (optional)
   * @param from (optional)
   * @param to (optional)
   */
  getAllForGroup(
    groupId,
    search,
    skip,
    take,
    moduleId,
    actorType,
    from,
    to,
    cancelToken
  ) {
    let url_ = this.baseUrl + "/v1/BookAttempt/Group/{groupId}?"
    if (groupId === undefined || groupId === null)
      throw new Error("The parameter 'groupId' must be defined.")
    url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId))
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (moduleId !== undefined && moduleId !== null)
      url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&"
    if (actorType !== undefined && actorType !== null)
      url_ += "actorType=" + encodeURIComponent("" + actorType) + "&"
    if (from !== undefined && from !== null)
      url_ +=
        "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&"
    if (to !== undefined && to !== null)
      url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllForGroup(_response)
      })
  }
  processGetAllForGroup(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(moduleAttemptId, cancelToken) {
    let url_ = this.baseUrl + "/v1/BookAttempt/{moduleAttemptId}"
    if (moduleAttemptId === undefined || moduleAttemptId === null)
      throw new Error("The parameter 'moduleAttemptId' must be defined.")
    url_ = url_.replace(
      "{moduleAttemptId}",
      encodeURIComponent("" + moduleAttemptId)
    )
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(moduleAttemptId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/BookAttempt/{moduleAttemptId}"
    if (moduleAttemptId === undefined || moduleAttemptId === null)
      throw new Error("The parameter 'moduleAttemptId' must be defined.")
    url_ = url_.replace(
      "{moduleAttemptId}",
      encodeURIComponent("" + moduleAttemptId)
    )
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(moduleAttemptId, cancelToken) {
    let url_ = this.baseUrl + "/v1/BookAttempt/{moduleAttemptId}"
    if (moduleAttemptId === undefined || moduleAttemptId === null)
      throw new Error("The parameter 'moduleAttemptId' must be defined.")
    url_ = url_.replace(
      "{moduleAttemptId}",
      encodeURIComponent("" + moduleAttemptId)
    )
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/BookAttempt"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  examplePass(moduleId, contentId, cancelToken) {
    let url_ =
      this.baseUrl +
      "/v1/BookAttempt/{moduleId}/Content/{contentId}/ExamplePass"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processExamplePass(_response)
      })
  }
  processExamplePass(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class BookContentClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   */
  getAll(moduleId, skip, take, cancelToken) {
    let url_ = this.baseUrl + "/v1/BookContent/{moduleId}/Content?"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAll(_response)
      })
  }
  processGetAll(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(moduleId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/BookContent/{moduleId}/Content"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(moduleId, contentId, cancelToken) {
    let url_ = this.baseUrl + "/v1/BookContent/{moduleId}/Content/{contentId}"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(moduleId, contentId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/BookContent/{moduleId}/Content/{contentId}"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(moduleId, contentId, cancelToken) {
    let url_ = this.baseUrl + "/v1/BookContent/{moduleId}/Content/{contentId}"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  createFromZip(moduleId, file, cancelToken) {
    let url_ = this.baseUrl + "/v1/BookContent/{moduleId}/Content/FromZip"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = new FormData()
    if (file !== null && file !== undefined)
      content_.append("file", file.data, file.fileName ? file.fileName : "file")
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreateFromZip(_response)
      })
  }
  processCreateFromZip(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  updateFromZip(moduleId, contentId, file, cancelToken) {
    let url_ =
      this.baseUrl + "/v1/BookContent/{moduleId}/Content/{contentId}/FromZip"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = new FormData()
    if (file !== null && file !== undefined)
      content_.append("file", file.data, file.fileName ? file.fileName : "file")
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdateFromZip(_response)
      })
  }
  processUpdateFromZip(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  publish(moduleId, contentId, cancelToken) {
    let url_ =
      this.baseUrl + "/v1/BookContent/{moduleId}/Content/{contentId}/Publish"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "POST",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processPublish(_response)
      })
  }
  processPublish(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  downloadFile(moduleId, contentId, fileId, cancelToken) {
    let url_ =
      this.baseUrl +
      "/v1/BookContent/{moduleId}/Content/{contentId}/File/{fileId}/Download"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    if (fileId === undefined || fileId === null)
      throw new Error("The parameter 'fileId' must be defined.")
    url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      responseType: "blob",
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/octet-stream",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDownloadFile(_response)
      })
  }
  processDownloadFile(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Promise.resolve({
        fileName: fileName,
        status: status,
        data: new Blob([response.data], {
          type: response.headers["content-type"],
        }),
        headers: _headers,
      })
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  export(moduleId, contentId, cancelToken) {
    let url_ =
      this.baseUrl + "/v1/BookContent/{moduleId}/Content/{contentId}/Export"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processExport(_response)
      })
  }
  processExport(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  example(cancelToken) {
    let url_ = this.baseUrl + "/v1/BookContent/Example"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processExample(_response)
      })
  }
  processExample(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  schema(cancelToken) {
    let url_ = this.baseUrl + "/v1/BookContent/Schema"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      responseType: "blob",
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/octet-stream",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processSchema(_response)
      })
  }
  processSchema(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Promise.resolve({
        fileName: fileName,
        status: status,
        data: new Blob([response.data], {
          type: response.headers["content-type"],
        }),
        headers: _headers,
      })
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class CertificateClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param publisherId (optional)
   */
  getAll(search, skip, take, publisherId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Certificate?"
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (publisherId !== undefined && publisherId !== null)
      url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAll(_response)
      })
  }
  processGetAll(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Certificate"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(certificateId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Certificate/{certificateId}"
    if (certificateId === undefined || certificateId === null)
      throw new Error("The parameter 'certificateId' must be defined.")
    url_ = url_.replace(
      "{certificateId}",
      encodeURIComponent("" + certificateId)
    )
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(certificateId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Certificate/{certificateId}"
    if (certificateId === undefined || certificateId === null)
      throw new Error("The parameter 'certificateId' must be defined.")
    url_ = url_.replace(
      "{certificateId}",
      encodeURIComponent("" + certificateId)
    )
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(certificateId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Certificate/{certificateId}"
    if (certificateId === undefined || certificateId === null)
      throw new Error("The parameter 'certificateId' must be defined.")
    url_ = url_.replace(
      "{certificateId}",
      encodeURIComponent("" + certificateId)
    )
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class CertificationClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   */
  getAllForTrainee(traineeId, search, skip, take, cancelToken) {
    let url_ = this.baseUrl + "/v1/Certification/Trainee/{traineeId}?"
    if (traineeId === undefined || traineeId === null)
      throw new Error("The parameter 'traineeId' must be defined.")
    url_ = url_.replace("{traineeId}", encodeURIComponent("" + traineeId))
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllForTrainee(_response)
      })
  }
  processGetAllForTrainee(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
   * Gets the certifications for a trainee at the given time.
   * @param traineeId The user id of the trainee.
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param at (optional) The UTC time at which to get certificates. If not specified, the current time is used.
   */
  getAllHistoryForTrainee(traineeId, skip, take, at, cancelToken) {
    let url_ = this.baseUrl + "/v1/Certification/Trainee/{traineeId}/History?"
    if (traineeId === undefined || traineeId === null)
      throw new Error("The parameter 'traineeId' must be defined.")
    url_ = url_.replace("{traineeId}", encodeURIComponent("" + traineeId))
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (at !== undefined && at !== null)
      url_ += "at=" + encodeURIComponent(at ? "" + at.toISOString() : "") + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllHistoryForTrainee(_response)
      })
  }
  processGetAllHistoryForTrainee(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
   * Gets the list of users with a certificate in a group at a specified time, optionally filtered by their status and roles in the group.
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param certificateId (optional)
   * @param memberStatus (optional)
   * @param role (optional)
   * @param at (optional) The UTC time at which to get certificates. If not specified, the current time is used.
   */
  getAllHistoryForGroup(
    groupId,
    skip,
    take,
    certificateId,
    memberStatus,
    role,
    at,
    cancelToken
  ) {
    let url_ = this.baseUrl + "/v1/Certification/Group/{groupId}/History?"
    if (groupId === undefined || groupId === null)
      throw new Error("The parameter 'groupId' must be defined.")
    url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId))
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (certificateId !== undefined && certificateId !== null)
      url_ += "certificateId=" + encodeURIComponent("" + certificateId) + "&"
    if (memberStatus !== undefined && memberStatus !== null)
      url_ += "memberStatus=" + encodeURIComponent("" + memberStatus) + "&"
    if (role !== undefined && role !== null)
      url_ += "role=" + encodeURIComponent("" + role) + "&"
    if (at !== undefined && at !== null)
      url_ += "at=" + encodeURIComponent(at ? "" + at.toISOString() : "") + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllHistoryForGroup(_response)
      })
  }
  processGetAllHistoryForGroup(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(certificationId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Certification/{certificationId}"
    if (certificationId === undefined || certificationId === null)
      throw new Error("The parameter 'certificationId' must be defined.")
    url_ = url_.replace(
      "{certificationId}",
      encodeURIComponent("" + certificationId)
    )
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  export(certificationId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Certification/{certificationId}/Export"
    if (certificationId === undefined || certificationId === null)
      throw new Error("The parameter 'certificationId' must be defined.")
    url_ = url_.replace(
      "{certificationId}",
      encodeURIComponent("" + certificationId)
    )
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      responseType: "blob",
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/octet-stream",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processExport(_response)
      })
  }
  processExport(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Promise.resolve({
        fileName: fileName,
        status: status,
        data: new Blob([response.data], {
          type: response.headers["content-type"],
        }),
        headers: _headers,
      })
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  download(token, cancelToken) {
    let url_ = this.baseUrl + "/v1/Certification/Download?"
    if (token !== undefined && token !== null)
      url_ += "token=" + encodeURIComponent("" + token) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      responseType: "blob",
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/octet-stream",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDownload(_response)
      })
  }
  processDownload(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Promise.resolve({
        fileName: fileName,
        status: status,
        data: new Blob([response.data], {
          type: response.headers["content-type"],
        }),
        headers: _headers,
      })
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class ClassClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
     * Get a list of all classes
     * @param search (optional)
     * @param skip (optional)
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param organisationId (optional) Optional organisation id filter
     * @param teamId (optional) Optional team id filter
     * @param publisherId (optional) Optional publisher id filter
     * @param courseId (optional) Optional course id filter
     * @param programId (optional) - null/empty to show all
    - program ID to filter to specific program
    - "none" to filter to items not in any program
     * @param activated (optional) Optional filter by class activation state
     */
  getAll(
    search,
    skip,
    take,
    organisationId,
    teamId,
    publisherId,
    courseId,
    programId,
    activated,
    cancelToken
  ) {
    let url_ = this.baseUrl + "/v1/Class?"
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (organisationId !== undefined && organisationId !== null)
      url_ += "organisationId=" + encodeURIComponent("" + organisationId) + "&"
    if (teamId !== undefined && teamId !== null)
      url_ += "teamId=" + encodeURIComponent("" + teamId) + "&"
    if (publisherId !== undefined && publisherId !== null)
      url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&"
    if (courseId !== undefined && courseId !== null)
      url_ += "courseId=" + encodeURIComponent("" + courseId) + "&"
    if (programId !== undefined && programId !== null)
      url_ += "programId=" + encodeURIComponent("" + programId) + "&"
    if (activated !== undefined && activated !== null)
      url_ += "activated=" + encodeURIComponent("" + activated) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAll(_response)
      })
  }
  processGetAll(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Class"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(classId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Class/{classId}"
    if (classId === undefined || classId === null)
      throw new Error("The parameter 'classId' must be defined.")
    url_ = url_.replace("{classId}", encodeURIComponent("" + classId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(classId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Class/{classId}"
    if (classId === undefined || classId === null)
      throw new Error("The parameter 'classId' must be defined.")
    url_ = url_.replace("{classId}", encodeURIComponent("" + classId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(classId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Class/{classId}"
    if (classId === undefined || classId === null)
      throw new Error("The parameter 'classId' must be defined.")
    url_ = url_.replace("{classId}", encodeURIComponent("" + classId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
   * Send assessment requested notification to trainers
   */
  notifyAssessors(classId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Class/{classId}/NotifyAssessors"
    if (classId === undefined || classId === null)
      throw new Error("The parameter 'classId' must be defined.")
    url_ = url_.replace("{classId}", encodeURIComponent("" + classId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processNotifyAssessors(_response)
      })
  }
  processNotifyAssessors(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class CourseClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
     * @param search (optional)
     * @param skip (optional)
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param programId (optional) - null/empty to show all
    - program ID to filter to specific program
    - "none" to filter to items not in any program
     */
  getAllForPublisher(publisherId, search, skip, take, programId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Course/Publisher/{publisherId}?"
    if (publisherId === undefined || publisherId === null)
      throw new Error("The parameter 'publisherId' must be defined.")
    url_ = url_.replace("{publisherId}", encodeURIComponent("" + publisherId))
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (programId !== undefined && programId !== null)
      url_ += "programId=" + encodeURIComponent("" + programId) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllForPublisher(_response)
      })
  }
  processGetAllForPublisher(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Course"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
     * @param search (optional)
     * @param skip (optional)
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param consumerId (optional)
     * @param publisherId (optional)
     * @param programId (optional) - null/empty to show all
    - program ID to filter to specific program
    - "none" to filter to items not in any program
     * @param itemId (optional)
     * @param activated (optional)
     */
  getAllByActivation(
    search,
    skip,
    take,
    consumerId,
    publisherId,
    programId,
    itemId,
    activated,
    cancelToken
  ) {
    let url_ = this.baseUrl + "/v1/Course?"
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (consumerId !== undefined && consumerId !== null)
      url_ += "consumerId=" + encodeURIComponent("" + consumerId) + "&"
    if (publisherId !== undefined && publisherId !== null)
      url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&"
    if (programId !== undefined && programId !== null)
      url_ += "programId=" + encodeURIComponent("" + programId) + "&"
    if (itemId !== undefined && itemId !== null)
      url_ += "itemId=" + encodeURIComponent("" + itemId) + "&"
    if (activated !== undefined && activated !== null)
      url_ += "activated=" + encodeURIComponent("" + activated) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllByActivation(_response)
      })
  }
  processGetAllByActivation(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(courseId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Course/{courseId}"
    if (courseId === undefined || courseId === null)
      throw new Error("The parameter 'courseId' must be defined.")
    url_ = url_.replace("{courseId}", encodeURIComponent("" + courseId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(courseId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Course/{courseId}"
    if (courseId === undefined || courseId === null)
      throw new Error("The parameter 'courseId' must be defined.")
    url_ = url_.replace("{courseId}", encodeURIComponent("" + courseId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
     * @param search (optional)
     * @param skip (optional)
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param publisherId (optional)
     * @param programId (optional) - null/empty to show all
    - program ID to filter to specific program
    - "none" to filter to items not in any program
     * @param countryCode (optional)
     */
  getAllPublished(
    search,
    skip,
    take,
    publisherId,
    programId,
    countryCode,
    cancelToken
  ) {
    let url_ = this.baseUrl + "/v1/Course/Published?"
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (publisherId !== undefined && publisherId !== null)
      url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&"
    if (programId !== undefined && programId !== null)
      url_ += "programId=" + encodeURIComponent("" + programId) + "&"
    if (countryCode !== undefined && countryCode !== null)
      url_ += "countryCode=" + encodeURIComponent("" + countryCode) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllPublished(_response)
      })
  }
  processGetAllPublished(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(id, cancelToken) {
    let url_ = this.baseUrl + "/v1/Course/{id}"
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class EnrolmentClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
     * @param search (optional)
     * @param skip (optional)
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param activated (optional)
     * @param programId (optional) - null/empty to show all
    - program ID to filter to specific program
    - "none" to filter to items not in any program
     */
  getAllForTrainee(
    traineeId,
    search,
    skip,
    take,
    activated,
    programId,
    cancelToken
  ) {
    let url_ = this.baseUrl + "/v1/Enrolment/Trainee/{traineeId}?"
    if (traineeId === undefined || traineeId === null)
      throw new Error("The parameter 'traineeId' must be defined.")
    url_ = url_.replace("{traineeId}", encodeURIComponent("" + traineeId))
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (activated !== undefined && activated !== null)
      url_ += "activated=" + encodeURIComponent("" + activated) + "&"
    if (programId !== undefined && programId !== null)
      url_ += "programId=" + encodeURIComponent("" + programId) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllForTrainee(_response)
      })
  }
  processGetAllForTrainee(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   */
  getAllForClass(classId, search, skip, take, cancelToken) {
    let url_ = this.baseUrl + "/v1/Enrolment/Class/{classId}?"
    if (classId === undefined || classId === null)
      throw new Error("The parameter 'classId' must be defined.")
    url_ = url_.replace("{classId}", encodeURIComponent("" + classId))
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllForClass(_response)
      })
  }
  processGetAllForClass(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(enrolmentId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Enrolment/{enrolmentId}"
    if (enrolmentId === undefined || enrolmentId === null)
      throw new Error("The parameter 'enrolmentId' must be defined.")
    url_ = url_.replace("{enrolmentId}", encodeURIComponent("" + enrolmentId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class ModuleAttemptClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param moduleId (optional)
   */
  getAllForActor(actorId, search, skip, take, moduleId, cancelToken) {
    let url_ = this.baseUrl + "/v1/ModuleAttempt/Actor/{actorId}?"
    if (actorId === undefined || actorId === null)
      throw new Error("The parameter 'actorId' must be defined.")
    url_ = url_.replace("{actorId}", encodeURIComponent("" + actorId))
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (moduleId !== undefined && moduleId !== null)
      url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllForActor(_response)
      })
  }
  processGetAllForActor(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
   * Gets all module attempts within the given group.
   * @param groupId The group to get module attempts from
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param moduleId (optional) Filter the results by module id
   * @param actorType (optional) Filter the results by actor type i.e. User, TrainingSession or Team. If left null, all actor types will be searched for.
   * @param from (optional) Start time of the module attempts
   * @param to (optional) End time of the module attempts
   */
  getAllForGroup(
    groupId,
    search,
    skip,
    take,
    moduleId,
    actorType,
    from,
    to,
    cancelToken
  ) {
    let url_ = this.baseUrl + "/v1/ModuleAttempt/Group/{groupId}?"
    if (groupId === undefined || groupId === null)
      throw new Error("The parameter 'groupId' must be defined.")
    url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId))
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (moduleId !== undefined && moduleId !== null)
      url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&"
    if (actorType !== undefined && actorType !== null)
      url_ += "actorType=" + encodeURIComponent("" + actorType) + "&"
    if (from !== undefined && from !== null)
      url_ +=
        "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&"
    if (to !== undefined && to !== null)
      url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllForGroup(_response)
      })
  }
  processGetAllForGroup(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(moduleAttemptId, cancelToken) {
    let url_ = this.baseUrl + "/v1/ModuleAttempt/{moduleAttemptId}"
    if (moduleAttemptId === undefined || moduleAttemptId === null)
      throw new Error("The parameter 'moduleAttemptId' must be defined.")
    url_ = url_.replace(
      "{moduleAttemptId}",
      encodeURIComponent("" + moduleAttemptId)
    )
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(moduleAttemptId, cancelToken) {
    let url_ = this.baseUrl + "/v1/ModuleAttempt/{moduleAttemptId}"
    if (moduleAttemptId === undefined || moduleAttemptId === null)
      throw new Error("The parameter 'moduleAttemptId' must be defined.")
    url_ = url_.replace(
      "{moduleAttemptId}",
      encodeURIComponent("" + moduleAttemptId)
    )
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class ModuleClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param publisherId (optional)
   * @param type (optional)
   */
  getAll(search, skip, take, publisherId, type, cancelToken) {
    let url_ = this.baseUrl + "/v1/Module?"
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (publisherId !== undefined && publisherId !== null)
      url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&"
    if (type !== undefined && type !== null)
      url_ += "type=" + encodeURIComponent("" + type) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAll(_response)
      })
  }
  processGetAll(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
   * Creates a module using the given data
   * @param settings The data used to create the module
   */
  create(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Module"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(moduleId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Module/{moduleId}"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(moduleId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Module/{moduleId}"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(moduleId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Module/{moduleId}"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  getAllFiles(moduleId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Module/{moduleId}/File"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllFiles(_response)
      })
  }
  processGetAllFiles(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
   * Creates a file and attaches it to the module
   * @param moduleId Id of the module to attach the file to
   * @param settings Data used to create the file
   * @return Information about the created file
   */
  createFile(moduleId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Module/{moduleId}/File"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreateFile(_response)
      })
  }
  processCreateFile(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  getFile(moduleId, fileId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Module/{moduleId}/File/{fileId}"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (fileId === undefined || fileId === null)
      throw new Error("The parameter 'fileId' must be defined.")
    url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetFile(_response)
      })
  }
  processGetFile(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  updateFile(moduleId, fileId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Module/{moduleId}/File/{fileId}"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (fileId === undefined || fileId === null)
      throw new Error("The parameter 'fileId' must be defined.")
    url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdateFile(_response)
      })
  }
  processUpdateFile(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  deleteFile(moduleId, fileId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Module/{moduleId}/File/{fileId}"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (fileId === undefined || fileId === null)
      throw new Error("The parameter 'fileId' must be defined.")
    url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDeleteFile(_response)
      })
  }
  processDeleteFile(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  downloadFile(moduleId, fileId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Module/{moduleId}/File/{fileId}/Download"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (fileId === undefined || fileId === null)
      throw new Error("The parameter 'fileId' must be defined.")
    url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      responseType: "blob",
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/octet-stream",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDownloadFile(_response)
      })
  }
  processDownloadFile(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Promise.resolve({
        fileName: fileName,
        status: status,
        data: new Blob([response.data], {
          type: response.headers["content-type"],
        }),
        headers: _headers,
      })
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class ModuleNpsClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  getAllForPublisher(publisherId, search, from, to, cancelToken) {
    let url_ = this.baseUrl + "/v1/ModuleNps/Publisher/{publisherId}?"
    if (publisherId === undefined || publisherId === null)
      throw new Error("The parameter 'publisherId' must be defined.")
    url_ = url_.replace("{publisherId}", encodeURIComponent("" + publisherId))
    if (search !== undefined && search !== null)
      url_ += "search=" + encodeURIComponent("" + search) + "&"
    if (from !== undefined && from !== null)
      url_ +=
        "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&"
    if (to !== undefined && to !== null)
      url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllForPublisher(_response)
      })
  }
  processGetAllForPublisher(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  getAllForModule(moduleId, from, to, cancelToken) {
    let url_ = this.baseUrl + "/v1/ModuleNps/Module/{moduleId}?"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (from !== undefined && from !== null)
      url_ +=
        "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&"
    if (to !== undefined && to !== null)
      url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllForModule(_response)
      })
  }
  processGetAllForModule(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(npsId, cancelToken) {
    let url_ = this.baseUrl + "/v1/ModuleNps/{npsId}"
    if (npsId === undefined || npsId === null)
      throw new Error("The parameter 'npsId' must be defined.")
    url_ = url_.replace("{npsId}", encodeURIComponent("" + npsId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(npsId, cancelToken) {
    let url_ = this.baseUrl + "/v1/ModuleNps/{npsId}"
    if (npsId === undefined || npsId === null)
      throw new Error("The parameter 'npsId' must be defined.")
    url_ = url_.replace("{npsId}", encodeURIComponent("" + npsId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/ModuleNps"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class QuizAttemptClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param moduleId (optional)
   */
  getAllForActor(actorId, search, skip, take, moduleId, cancelToken) {
    let url_ = this.baseUrl + "/v1/QuizAttempt/Actor/{actorId}?"
    if (actorId === undefined || actorId === null)
      throw new Error("The parameter 'actorId' must be defined.")
    url_ = url_.replace("{actorId}", encodeURIComponent("" + actorId))
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (moduleId !== undefined && moduleId !== null)
      url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllForActor(_response)
      })
  }
  processGetAllForActor(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param moduleId (optional)
   * @param actorType (optional)
   * @param from (optional)
   * @param to (optional)
   */
  getAllForGroup(
    groupId,
    search,
    skip,
    take,
    moduleId,
    actorType,
    from,
    to,
    cancelToken
  ) {
    let url_ = this.baseUrl + "/v1/QuizAttempt/Group/{groupId}?"
    if (groupId === undefined || groupId === null)
      throw new Error("The parameter 'groupId' must be defined.")
    url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId))
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (moduleId !== undefined && moduleId !== null)
      url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&"
    if (actorType !== undefined && actorType !== null)
      url_ += "actorType=" + encodeURIComponent("" + actorType) + "&"
    if (from !== undefined && from !== null)
      url_ +=
        "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&"
    if (to !== undefined && to !== null)
      url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllForGroup(_response)
      })
  }
  processGetAllForGroup(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(moduleAttemptId, cancelToken) {
    let url_ = this.baseUrl + "/v1/QuizAttempt/{moduleAttemptId}"
    if (moduleAttemptId === undefined || moduleAttemptId === null)
      throw new Error("The parameter 'moduleAttemptId' must be defined.")
    url_ = url_.replace(
      "{moduleAttemptId}",
      encodeURIComponent("" + moduleAttemptId)
    )
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(moduleAttemptId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/QuizAttempt/{moduleAttemptId}"
    if (moduleAttemptId === undefined || moduleAttemptId === null)
      throw new Error("The parameter 'moduleAttemptId' must be defined.")
    url_ = url_.replace(
      "{moduleAttemptId}",
      encodeURIComponent("" + moduleAttemptId)
    )
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(moduleAttemptId, cancelToken) {
    let url_ = this.baseUrl + "/v1/QuizAttempt/{moduleAttemptId}"
    if (moduleAttemptId === undefined || moduleAttemptId === null)
      throw new Error("The parameter 'moduleAttemptId' must be defined.")
    url_ = url_.replace(
      "{moduleAttemptId}",
      encodeURIComponent("" + moduleAttemptId)
    )
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/QuizAttempt"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  examplePass(moduleId, contentId, cancelToken) {
    let url_ =
      this.baseUrl +
      "/v1/QuizAttempt/{moduleId}/Content/{contentId}/ExamplePass"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processExamplePass(_response)
      })
  }
  processExamplePass(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class QuizContentClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   */
  getAll(moduleId, skip, take, cancelToken) {
    let url_ = this.baseUrl + "/v1/QuizContent/{moduleId}/Content?"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAll(_response)
      })
  }
  processGetAll(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(moduleId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/QuizContent/{moduleId}/Content"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(moduleId, contentId, cancelToken) {
    let url_ = this.baseUrl + "/v1/QuizContent/{moduleId}/Content/{contentId}"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(moduleId, contentId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/QuizContent/{moduleId}/Content/{contentId}"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(moduleId, contentId, cancelToken) {
    let url_ = this.baseUrl + "/v1/QuizContent/{moduleId}/Content/{contentId}"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  createFromZip(moduleId, file, cancelToken) {
    let url_ = this.baseUrl + "/v1/QuizContent/{moduleId}/Content/FromZip"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = new FormData()
    if (file !== null && file !== undefined)
      content_.append("file", file.data, file.fileName ? file.fileName : "file")
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreateFromZip(_response)
      })
  }
  processCreateFromZip(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  updateFromZip(moduleId, contentId, file, cancelToken) {
    let url_ =
      this.baseUrl + "/v1/QuizContent/{moduleId}/Content/{contentId}/FromZip"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = new FormData()
    if (file !== null && file !== undefined)
      content_.append("file", file.data, file.fileName ? file.fileName : "file")
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdateFromZip(_response)
      })
  }
  processUpdateFromZip(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  publish(moduleId, contentId, cancelToken) {
    let url_ =
      this.baseUrl + "/v1/QuizContent/{moduleId}/Content/{contentId}/Publish"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "POST",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processPublish(_response)
      })
  }
  processPublish(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  downloadFile(moduleId, contentId, fileId, cancelToken) {
    let url_ =
      this.baseUrl +
      "/v1/QuizContent/{moduleId}/Content/{contentId}/File/{fileId}/Download"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    if (fileId === undefined || fileId === null)
      throw new Error("The parameter 'fileId' must be defined.")
    url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      responseType: "blob",
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/octet-stream",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDownloadFile(_response)
      })
  }
  processDownloadFile(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Promise.resolve({
        fileName: fileName,
        status: status,
        data: new Blob([response.data], {
          type: response.headers["content-type"],
        }),
        headers: _headers,
      })
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  export(moduleId, contentId, cancelToken) {
    let url_ =
      this.baseUrl + "/v1/QuizContent/{moduleId}/Content/{contentId}/Export"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processExport(_response)
      })
  }
  processExport(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  example(cancelToken) {
    let url_ = this.baseUrl + "/v1/QuizContent/Example"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processExample(_response)
      })
  }
  processExample(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  schema(cancelToken) {
    let url_ = this.baseUrl + "/v1/QuizContent/Schema"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      responseType: "blob",
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/octet-stream",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processSchema(_response)
      })
  }
  processSchema(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Promise.resolve({
        fileName: fileName,
        status: status,
        data: new Blob([response.data], {
          type: response.headers["content-type"],
        }),
        headers: _headers,
      })
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class RevisionAttemptClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param moduleId (optional)
   */
  getAllForActor(actorId, search, skip, take, moduleId, cancelToken) {
    let url_ = this.baseUrl + "/v1/RevisionAttempt/Actor/{actorId}?"
    if (actorId === undefined || actorId === null)
      throw new Error("The parameter 'actorId' must be defined.")
    url_ = url_.replace("{actorId}", encodeURIComponent("" + actorId))
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (moduleId !== undefined && moduleId !== null)
      url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllForActor(_response)
      })
  }
  processGetAllForActor(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param moduleId (optional)
   * @param actorType (optional)
   * @param from (optional)
   * @param to (optional)
   */
  getAllForGroup(
    groupId,
    search,
    skip,
    take,
    moduleId,
    actorType,
    from,
    to,
    cancelToken
  ) {
    let url_ = this.baseUrl + "/v1/RevisionAttempt/Group/{groupId}?"
    if (groupId === undefined || groupId === null)
      throw new Error("The parameter 'groupId' must be defined.")
    url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId))
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (moduleId !== undefined && moduleId !== null)
      url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&"
    if (actorType !== undefined && actorType !== null)
      url_ += "actorType=" + encodeURIComponent("" + actorType) + "&"
    if (from !== undefined && from !== null)
      url_ +=
        "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&"
    if (to !== undefined && to !== null)
      url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllForGroup(_response)
      })
  }
  processGetAllForGroup(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(moduleAttemptId, cancelToken) {
    let url_ = this.baseUrl + "/v1/RevisionAttempt/{moduleAttemptId}"
    if (moduleAttemptId === undefined || moduleAttemptId === null)
      throw new Error("The parameter 'moduleAttemptId' must be defined.")
    url_ = url_.replace(
      "{moduleAttemptId}",
      encodeURIComponent("" + moduleAttemptId)
    )
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(moduleAttemptId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/RevisionAttempt/{moduleAttemptId}"
    if (moduleAttemptId === undefined || moduleAttemptId === null)
      throw new Error("The parameter 'moduleAttemptId' must be defined.")
    url_ = url_.replace(
      "{moduleAttemptId}",
      encodeURIComponent("" + moduleAttemptId)
    )
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(moduleAttemptId, cancelToken) {
    let url_ = this.baseUrl + "/v1/RevisionAttempt/{moduleAttemptId}"
    if (moduleAttemptId === undefined || moduleAttemptId === null)
      throw new Error("The parameter 'moduleAttemptId' must be defined.")
    url_ = url_.replace(
      "{moduleAttemptId}",
      encodeURIComponent("" + moduleAttemptId)
    )
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/RevisionAttempt"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  examplePass(moduleId, contentId, cancelToken) {
    let url_ =
      this.baseUrl +
      "/v1/RevisionAttempt/{moduleId}/Content/{contentId}/ExamplePass"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processExamplePass(_response)
      })
  }
  processExamplePass(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class RevisionContentClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   */
  getAll(moduleId, skip, take, cancelToken) {
    let url_ = this.baseUrl + "/v1/RevisionContent/{moduleId}/Content?"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAll(_response)
      })
  }
  processGetAll(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(moduleId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/RevisionContent/{moduleId}/Content"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(moduleId, contentId, cancelToken) {
    let url_ =
      this.baseUrl + "/v1/RevisionContent/{moduleId}/Content/{contentId}"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(moduleId, contentId, settings, cancelToken) {
    let url_ =
      this.baseUrl + "/v1/RevisionContent/{moduleId}/Content/{contentId}"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(moduleId, contentId, cancelToken) {
    let url_ =
      this.baseUrl + "/v1/RevisionContent/{moduleId}/Content/{contentId}"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  createFromZip(moduleId, file, cancelToken) {
    let url_ = this.baseUrl + "/v1/RevisionContent/{moduleId}/Content/FromZip"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = new FormData()
    if (file !== null && file !== undefined)
      content_.append("file", file.data, file.fileName ? file.fileName : "file")
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreateFromZip(_response)
      })
  }
  processCreateFromZip(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  updateFromZip(moduleId, contentId, file, cancelToken) {
    let url_ =
      this.baseUrl +
      "/v1/RevisionContent/{moduleId}/Content/{contentId}/FromZip"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = new FormData()
    if (file !== null && file !== undefined)
      content_.append("file", file.data, file.fileName ? file.fileName : "file")
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdateFromZip(_response)
      })
  }
  processUpdateFromZip(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  publish(moduleId, contentId, cancelToken) {
    let url_ =
      this.baseUrl +
      "/v1/RevisionContent/{moduleId}/Content/{contentId}/Publish"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "POST",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processPublish(_response)
      })
  }
  processPublish(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  downloadFile(moduleId, contentId, fileId, cancelToken) {
    let url_ =
      this.baseUrl +
      "/v1/RevisionContent/{moduleId}/Content/{contentId}/File/{fileId}/Download"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    if (fileId === undefined || fileId === null)
      throw new Error("The parameter 'fileId' must be defined.")
    url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      responseType: "blob",
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/octet-stream",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDownloadFile(_response)
      })
  }
  processDownloadFile(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Promise.resolve({
        fileName: fileName,
        status: status,
        data: new Blob([response.data], {
          type: response.headers["content-type"],
        }),
        headers: _headers,
      })
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  export(moduleId, contentId, cancelToken) {
    let url_ =
      this.baseUrl + "/v1/RevisionContent/{moduleId}/Content/{contentId}/Export"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processExport(_response)
      })
  }
  processExport(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  example(cancelToken) {
    let url_ = this.baseUrl + "/v1/RevisionContent/Example"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processExample(_response)
      })
  }
  processExample(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  schema(cancelToken) {
    let url_ = this.baseUrl + "/v1/RevisionContent/Schema"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      responseType: "blob",
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/octet-stream",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processSchema(_response)
      })
  }
  processSchema(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Promise.resolve({
        fileName: fileName,
        status: status,
        data: new Blob([response.data], {
          type: response.headers["content-type"],
        }),
        headers: _headers,
      })
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class TrainingSessionClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param groupId (optional)
   * @param from (optional)
   * @param status (optional)
   */
  getAll(search, skip, take, groupId, from, status, cancelToken) {
    let url_ = this.baseUrl + "/v1/TrainingSession?"
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (groupId !== undefined && groupId !== null)
      url_ += "groupId=" + encodeURIComponent("" + groupId) + "&"
    if (from !== undefined && from !== null)
      url_ +=
        "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&"
    if (status !== undefined && status !== null)
      url_ += "status=" + encodeURIComponent("" + status) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAll(_response)
      })
  }
  processGetAll(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/TrainingSession"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(trainingSessionId, cancelToken) {
    let url_ = this.baseUrl + "/v1/TrainingSession/{trainingSessionId}"
    if (trainingSessionId === undefined || trainingSessionId === null)
      throw new Error("The parameter 'trainingSessionId' must be defined.")
    url_ = url_.replace(
      "{trainingSessionId}",
      encodeURIComponent("" + trainingSessionId)
    )
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(trainingSessionId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/TrainingSession/{trainingSessionId}"
    if (trainingSessionId === undefined || trainingSessionId === null)
      throw new Error("The parameter 'trainingSessionId' must be defined.")
    url_ = url_.replace(
      "{trainingSessionId}",
      encodeURIComponent("" + trainingSessionId)
    )
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(trainingSessionId, cancelToken) {
    let url_ = this.baseUrl + "/v1/TrainingSession/{trainingSessionId}"
    if (trainingSessionId === undefined || trainingSessionId === null)
      throw new Error("The parameter 'trainingSessionId' must be defined.")
    url_ = url_.replace(
      "{trainingSessionId}",
      encodeURIComponent("" + trainingSessionId)
    )
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class VideoAttemptClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param moduleId (optional)
   */
  getAllForActor(actorId, search, skip, take, moduleId, cancelToken) {
    let url_ = this.baseUrl + "/v1/VideoAttempt/Actor/{actorId}?"
    if (actorId === undefined || actorId === null)
      throw new Error("The parameter 'actorId' must be defined.")
    url_ = url_.replace("{actorId}", encodeURIComponent("" + actorId))
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (moduleId !== undefined && moduleId !== null)
      url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllForActor(_response)
      })
  }
  processGetAllForActor(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param moduleId (optional)
   * @param actorType (optional)
   * @param from (optional)
   * @param to (optional)
   */
  getAllForGroup(
    groupId,
    search,
    skip,
    take,
    moduleId,
    actorType,
    from,
    to,
    cancelToken
  ) {
    let url_ = this.baseUrl + "/v1/VideoAttempt/Group/{groupId}?"
    if (groupId === undefined || groupId === null)
      throw new Error("The parameter 'groupId' must be defined.")
    url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId))
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (moduleId !== undefined && moduleId !== null)
      url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&"
    if (actorType !== undefined && actorType !== null)
      url_ += "actorType=" + encodeURIComponent("" + actorType) + "&"
    if (from !== undefined && from !== null)
      url_ +=
        "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&"
    if (to !== undefined && to !== null)
      url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllForGroup(_response)
      })
  }
  processGetAllForGroup(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(moduleAttemptId, cancelToken) {
    let url_ = this.baseUrl + "/v1/VideoAttempt/{moduleAttemptId}"
    if (moduleAttemptId === undefined || moduleAttemptId === null)
      throw new Error("The parameter 'moduleAttemptId' must be defined.")
    url_ = url_.replace(
      "{moduleAttemptId}",
      encodeURIComponent("" + moduleAttemptId)
    )
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(moduleAttemptId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/VideoAttempt/{moduleAttemptId}"
    if (moduleAttemptId === undefined || moduleAttemptId === null)
      throw new Error("The parameter 'moduleAttemptId' must be defined.")
    url_ = url_.replace(
      "{moduleAttemptId}",
      encodeURIComponent("" + moduleAttemptId)
    )
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(moduleAttemptId, cancelToken) {
    let url_ = this.baseUrl + "/v1/VideoAttempt/{moduleAttemptId}"
    if (moduleAttemptId === undefined || moduleAttemptId === null)
      throw new Error("The parameter 'moduleAttemptId' must be defined.")
    url_ = url_.replace(
      "{moduleAttemptId}",
      encodeURIComponent("" + moduleAttemptId)
    )
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/VideoAttempt"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  examplePass(moduleId, contentId, cancelToken) {
    let url_ =
      this.baseUrl +
      "/v1/VideoAttempt/{moduleId}/Content/{contentId}/ExamplePass"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processExamplePass(_response)
      })
  }
  processExamplePass(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class VideoContentClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   */
  getAll(moduleId, skip, take, cancelToken) {
    let url_ = this.baseUrl + "/v1/VideoContent/{moduleId}/Content?"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAll(_response)
      })
  }
  processGetAll(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(moduleId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/VideoContent/{moduleId}/Content"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(moduleId, contentId, cancelToken) {
    let url_ = this.baseUrl + "/v1/VideoContent/{moduleId}/Content/{contentId}"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(moduleId, contentId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/VideoContent/{moduleId}/Content/{contentId}"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(moduleId, contentId, cancelToken) {
    let url_ = this.baseUrl + "/v1/VideoContent/{moduleId}/Content/{contentId}"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  createFromZip(moduleId, file, cancelToken) {
    let url_ = this.baseUrl + "/v1/VideoContent/{moduleId}/Content/FromZip"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = new FormData()
    if (file !== null && file !== undefined)
      content_.append("file", file.data, file.fileName ? file.fileName : "file")
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreateFromZip(_response)
      })
  }
  processCreateFromZip(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  updateFromZip(moduleId, contentId, file, cancelToken) {
    let url_ =
      this.baseUrl + "/v1/VideoContent/{moduleId}/Content/{contentId}/FromZip"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = new FormData()
    if (file !== null && file !== undefined)
      content_.append("file", file.data, file.fileName ? file.fileName : "file")
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdateFromZip(_response)
      })
  }
  processUpdateFromZip(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  publish(moduleId, contentId, cancelToken) {
    let url_ =
      this.baseUrl + "/v1/VideoContent/{moduleId}/Content/{contentId}/Publish"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "POST",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processPublish(_response)
      })
  }
  processPublish(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  downloadFile(moduleId, contentId, fileId, cancelToken) {
    let url_ =
      this.baseUrl +
      "/v1/VideoContent/{moduleId}/Content/{contentId}/File/{fileId}/Download"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    if (fileId === undefined || fileId === null)
      throw new Error("The parameter 'fileId' must be defined.")
    url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      responseType: "blob",
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/octet-stream",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDownloadFile(_response)
      })
  }
  processDownloadFile(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Promise.resolve({
        fileName: fileName,
        status: status,
        data: new Blob([response.data], {
          type: response.headers["content-type"],
        }),
        headers: _headers,
      })
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  export(moduleId, contentId, cancelToken) {
    let url_ =
      this.baseUrl + "/v1/VideoContent/{moduleId}/Content/{contentId}/Export"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processExport(_response)
      })
  }
  processExport(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  example(cancelToken) {
    let url_ = this.baseUrl + "/v1/VideoContent/Example"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processExample(_response)
      })
  }
  processExample(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  schema(cancelToken) {
    let url_ = this.baseUrl + "/v1/VideoContent/Schema"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      responseType: "blob",
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/octet-stream",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processSchema(_response)
      })
  }
  processSchema(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Promise.resolve({
        fileName: fileName,
        status: status,
        data: new Blob([response.data], {
          type: response.headers["content-type"],
        }),
        headers: _headers,
      })
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class AssessmentAttemptClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param moduleId (optional)
   */
  getAllForActor(actorId, search, skip, take, moduleId, cancelToken) {
    let url_ = this.baseUrl + "/v1/AssessmentAttempt/Actor/{actorId}?"
    if (actorId === undefined || actorId === null)
      throw new Error("The parameter 'actorId' must be defined.")
    url_ = url_.replace("{actorId}", encodeURIComponent("" + actorId))
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (moduleId !== undefined && moduleId !== null)
      url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllForActor(_response)
      })
  }
  processGetAllForActor(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param moduleId (optional)
   * @param actorType (optional)
   * @param from (optional)
   * @param to (optional)
   */
  getAllForGroup(
    groupId,
    search,
    skip,
    take,
    moduleId,
    actorType,
    from,
    to,
    cancelToken
  ) {
    let url_ = this.baseUrl + "/v1/AssessmentAttempt/Group/{groupId}?"
    if (groupId === undefined || groupId === null)
      throw new Error("The parameter 'groupId' must be defined.")
    url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId))
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (moduleId !== undefined && moduleId !== null)
      url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&"
    if (actorType !== undefined && actorType !== null)
      url_ += "actorType=" + encodeURIComponent("" + actorType) + "&"
    if (from !== undefined && from !== null)
      url_ +=
        "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&"
    if (to !== undefined && to !== null)
      url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllForGroup(_response)
      })
  }
  processGetAllForGroup(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(moduleAttemptId, cancelToken) {
    let url_ = this.baseUrl + "/v1/AssessmentAttempt/{moduleAttemptId}"
    if (moduleAttemptId === undefined || moduleAttemptId === null)
      throw new Error("The parameter 'moduleAttemptId' must be defined.")
    url_ = url_.replace(
      "{moduleAttemptId}",
      encodeURIComponent("" + moduleAttemptId)
    )
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(moduleAttemptId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/AssessmentAttempt/{moduleAttemptId}"
    if (moduleAttemptId === undefined || moduleAttemptId === null)
      throw new Error("The parameter 'moduleAttemptId' must be defined.")
    url_ = url_.replace(
      "{moduleAttemptId}",
      encodeURIComponent("" + moduleAttemptId)
    )
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(moduleAttemptId, cancelToken) {
    let url_ = this.baseUrl + "/v1/AssessmentAttempt/{moduleAttemptId}"
    if (moduleAttemptId === undefined || moduleAttemptId === null)
      throw new Error("The parameter 'moduleAttemptId' must be defined.")
    url_ = url_.replace(
      "{moduleAttemptId}",
      encodeURIComponent("" + moduleAttemptId)
    )
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/AssessmentAttempt"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  examplePass(moduleId, contentId, cancelToken) {
    let url_ =
      this.baseUrl +
      "/v1/AssessmentAttempt/{moduleId}/Content/{contentId}/ExamplePass"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processExamplePass(_response)
      })
  }
  processExamplePass(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class AssessmentContentClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   */
  getAll(moduleId, skip, take, cancelToken) {
    let url_ = this.baseUrl + "/v1/AssessmentContent/{moduleId}/Content?"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAll(_response)
      })
  }
  processGetAll(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(moduleId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/AssessmentContent/{moduleId}/Content"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(moduleId, contentId, cancelToken) {
    let url_ =
      this.baseUrl + "/v1/AssessmentContent/{moduleId}/Content/{contentId}"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(moduleId, contentId, settings, cancelToken) {
    let url_ =
      this.baseUrl + "/v1/AssessmentContent/{moduleId}/Content/{contentId}"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(moduleId, contentId, cancelToken) {
    let url_ =
      this.baseUrl + "/v1/AssessmentContent/{moduleId}/Content/{contentId}"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  createFromZip(moduleId, file, cancelToken) {
    let url_ = this.baseUrl + "/v1/AssessmentContent/{moduleId}/Content/FromZip"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = new FormData()
    if (file !== null && file !== undefined)
      content_.append("file", file.data, file.fileName ? file.fileName : "file")
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreateFromZip(_response)
      })
  }
  processCreateFromZip(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  updateFromZip(moduleId, contentId, file, cancelToken) {
    let url_ =
      this.baseUrl +
      "/v1/AssessmentContent/{moduleId}/Content/{contentId}/FromZip"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = new FormData()
    if (file !== null && file !== undefined)
      content_.append("file", file.data, file.fileName ? file.fileName : "file")
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdateFromZip(_response)
      })
  }
  processUpdateFromZip(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  publish(moduleId, contentId, cancelToken) {
    let url_ =
      this.baseUrl +
      "/v1/AssessmentContent/{moduleId}/Content/{contentId}/Publish"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "POST",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processPublish(_response)
      })
  }
  processPublish(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  downloadFile(moduleId, contentId, fileId, cancelToken) {
    let url_ =
      this.baseUrl +
      "/v1/AssessmentContent/{moduleId}/Content/{contentId}/File/{fileId}/Download"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    if (fileId === undefined || fileId === null)
      throw new Error("The parameter 'fileId' must be defined.")
    url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      responseType: "blob",
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/octet-stream",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDownloadFile(_response)
      })
  }
  processDownloadFile(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Promise.resolve({
        fileName: fileName,
        status: status,
        data: new Blob([response.data], {
          type: response.headers["content-type"],
        }),
        headers: _headers,
      })
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  export(moduleId, contentId, cancelToken) {
    let url_ =
      this.baseUrl +
      "/v1/AssessmentContent/{moduleId}/Content/{contentId}/Export"
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId))
    if (contentId === undefined || contentId === null)
      throw new Error("The parameter 'contentId' must be defined.")
    url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processExport(_response)
      })
  }
  processExport(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  example(cancelToken) {
    let url_ = this.baseUrl + "/v1/AssessmentContent/Example"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processExample(_response)
      })
  }
  processExample(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  schema(cancelToken) {
    let url_ = this.baseUrl + "/v1/AssessmentContent/Schema"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      responseType: "blob",
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/octet-stream",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processSchema(_response)
      })
  }
  processSchema(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Promise.resolve({
        fileName: fileName,
        status: status,
        data: new Blob([response.data], {
          type: response.headers["content-type"],
        }),
        headers: _headers,
      })
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class AssessmentSubAttemptClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param assessmentId (optional)
   */
  getAllForActor(actorId, search, skip, take, assessmentId, cancelToken) {
    let url_ = this.baseUrl + "/v1/AssessmentSubAttempt/Actor/{actorId}?"
    if (actorId === undefined || actorId === null)
      throw new Error("The parameter 'actorId' must be defined.")
    url_ = url_.replace("{actorId}", encodeURIComponent("" + actorId))
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (assessmentId !== undefined && assessmentId !== null)
      url_ += "assessmentId=" + encodeURIComponent("" + assessmentId) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllForActor(_response)
      })
  }
  processGetAllForActor(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param assessmentId (optional)
   * @param actorType (optional)
   * @param from (optional)
   * @param to (optional)
   */
  getAllForGroup(
    groupId,
    search,
    skip,
    take,
    assessmentId,
    actorType,
    from,
    to,
    cancelToken
  ) {
    let url_ = this.baseUrl + "/v1/AssessmentSubAttempt/Group/{groupId}?"
    if (groupId === undefined || groupId === null)
      throw new Error("The parameter 'groupId' must be defined.")
    url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId))
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (assessmentId !== undefined && assessmentId !== null)
      url_ += "assessmentId=" + encodeURIComponent("" + assessmentId) + "&"
    if (actorType !== undefined && actorType !== null)
      url_ += "actorType=" + encodeURIComponent("" + actorType) + "&"
    if (from !== undefined && from !== null)
      url_ +=
        "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&"
    if (to !== undefined && to !== null)
      url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllForGroup(_response)
      })
  }
  processGetAllForGroup(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(subAttemptId, cancelToken) {
    let url_ = this.baseUrl + "/v1/AssessmentSubAttempt/{subAttemptId}"
    if (subAttemptId === undefined || subAttemptId === null)
      throw new Error("The parameter 'subAttemptId' must be defined.")
    url_ = url_.replace("{subAttemptId}", encodeURIComponent("" + subAttemptId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(subAttemptId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/AssessmentSubAttempt/{subAttemptId}"
    if (subAttemptId === undefined || subAttemptId === null)
      throw new Error("The parameter 'subAttemptId' must be defined.")
    url_ = url_.replace("{subAttemptId}", encodeURIComponent("" + subAttemptId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(subAttemptId, cancelToken) {
    let url_ = this.baseUrl + "/v1/AssessmentSubAttempt/{subAttemptId}"
    if (subAttemptId === undefined || subAttemptId === null)
      throw new Error("The parameter 'subAttemptId' must be defined.")
    url_ = url_.replace("{subAttemptId}", encodeURIComponent("" + subAttemptId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/AssessmentSubAttempt"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class AuthenticationClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * Set authentication cookie
   */
  signIn(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Authentication/SignIn"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      responseType: "blob",
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/octet-stream",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processSignIn(_response)
      })
  }
  processSignIn(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Promise.resolve({
        fileName: fileName,
        status: status,
        data: new Blob([response.data], {
          type: response.headers["content-type"],
        }),
        headers: _headers,
      })
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
   * Clear authentication cookie
   */
  signOut(cancelToken) {
    let url_ = this.baseUrl + "/v1/Authentication/SignOut"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "POST",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processSignOut(_response)
      })
  }
  processSignOut(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
   * Generate a TokenModel
   */
  token(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Authentication/Token"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processToken(_response)
      })
  }
  processToken(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  refreshToken(cancelToken) {
    let url_ = this.baseUrl + "/v1/Authentication/RefreshToken"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processRefreshToken(_response)
      })
  }
  processRefreshToken(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
   * Generate a TokenModel on behalf of userId
   */
  impersonate(userId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Authentication/Impersonate/{userId}"
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.")
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "POST",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processImpersonate(_response)
      })
  }
  processImpersonate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
     * Revert the supplied TokenModel to one with no
    impersonating data
     */
  unimpersonate(cancelToken) {
    let url_ = this.baseUrl + "/v1/Authentication/Unimpersonate"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "POST",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUnimpersonate(_response)
      })
  }
  processUnimpersonate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
   * Gets the Identity
   */
  identity(cancelToken) {
    let url_ = this.baseUrl + "/v1/Authentication/Identity"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processIdentity(_response)
      })
  }
  processIdentity(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
     * Checks if the authenticated Identity has the given permission
     * @param permission (optional) The required permission
     * @param groupId (optional) The GroupId. If this is null or empty, all the current identity's
    groups will be searched.
     * @param orChildren (optional) If groupId is provided and orChildren
    is true, all child groups of groupId
    will also be checked
     * @return Returns true if the current identity is permitted
     * @deprecated
     */
  permitted(permission, groupId, orChildren, cancelToken) {
    let url_ = this.baseUrl + "/v1/Authentication/Permitted?"
    if (permission !== undefined && permission !== null)
      url_ += "permission=" + encodeURIComponent("" + permission) + "&"
    if (groupId !== undefined && groupId !== null)
      url_ += "groupId=" + encodeURIComponent("" + groupId) + "&"
    if (orChildren !== undefined && orChildren !== null)
      url_ += "orChildren=" + encodeURIComponent("" + orChildren) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processPermitted(_response)
      })
  }
  processPermitted(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
   * @param permission The required permission
   * @return Returns true if the current identity is permitted
   */
  permittedAll(permission, groupIds, cancelToken) {
    let url_ = this.baseUrl + "/v1/Authentication/Permitted/{permission}"
    if (permission === undefined || permission === null)
      throw new Error("The parameter 'permission' must be defined.")
    url_ = url_.replace("{permission}", encodeURIComponent("" + permission))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(groupIds)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processPermittedAll(_response)
      })
  }
  processPermittedAll(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class CommunicationPreferencesClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  get(userId, cancelToken) {
    let url_ = this.baseUrl + "/v1/CommunicationPreferences/{userId}"
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.")
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(userId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/CommunicationPreferences/{userId}"
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.")
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  unsubscribe(token, cancelToken) {
    let url_ = this.baseUrl + "/v1/CommunicationPreferences/Unsubscribe?"
    if (token !== undefined && token !== null)
      url_ += "token=" + encodeURIComponent("" + token) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUnsubscribe(_response)
      })
  }
  processUnsubscribe(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  unsubscribe2(token, cancelToken) {
    let url_ = this.baseUrl + "/v1/CommunicationPreferences/Unsubscribe?"
    if (token !== undefined && token !== null)
      url_ += "token=" + encodeURIComponent("" + token) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "POST",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUnsubscribe2(_response)
      })
  }
  processUnsubscribe2(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class EmailRegistrationClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * Check if the given email is registered in the system.
   * @return 200 OK if the email is found, else a 404
   */
  get(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/EmailRegistration"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      responseType: "blob",
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/octet-stream",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Promise.resolve({
        fileName: fileName,
        status: status,
        data: new Blob([response.data], {
          type: response.headers["content-type"],
        }),
        headers: _headers,
      })
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class GroupCommentClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param includeChildGroups (optional)
   */
  getAll(groupId, search, skip, take, includeChildGroups, cancelToken) {
    let url_ = this.baseUrl + "/v1/Group/{groupId}/Comment?"
    if (groupId === undefined || groupId === null)
      throw new Error("The parameter 'groupId' must be defined.")
    url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId))
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (includeChildGroups === null)
      throw new Error("The parameter 'includeChildGroups' cannot be null.")
    else if (includeChildGroups !== undefined)
      url_ +=
        "includeChildGroups=" +
        encodeURIComponent("" + includeChildGroups) +
        "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAll(_response)
      })
  }
  processGetAll(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(groupId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Group/{groupId}/Comment"
    if (groupId === undefined || groupId === null)
      throw new Error("The parameter 'groupId' must be defined.")
    url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(groupId, commentId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Group/{groupId}/Comment/{commentId}"
    if (groupId === undefined || groupId === null)
      throw new Error("The parameter 'groupId' must be defined.")
    url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId))
    if (commentId === undefined || commentId === null)
      throw new Error("The parameter 'commentId' must be defined.")
    url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(groupId, commentId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Group/{groupId}/Comment/{commentId}"
    if (groupId === undefined || groupId === null)
      throw new Error("The parameter 'groupId' must be defined.")
    url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId))
    if (commentId === undefined || commentId === null)
      throw new Error("The parameter 'commentId' must be defined.")
    url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(groupId, commentId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Group/{groupId}/Comment/{commentId}"
    if (groupId === undefined || groupId === null)
      throw new Error("The parameter 'groupId' must be defined.")
    url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId))
    if (commentId === undefined || commentId === null)
      throw new Error("The parameter 'commentId' must be defined.")
    url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   */
  getAllReplies(groupId, commentId, search, skip, take, cancelToken) {
    let url_ = this.baseUrl + "/v1/Group/{groupId}/Comment/{commentId}/Reply?"
    if (groupId === undefined || groupId === null)
      throw new Error("The parameter 'groupId' must be defined.")
    url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId))
    if (commentId === undefined || commentId === null)
      throw new Error("The parameter 'commentId' must be defined.")
    url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId))
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllReplies(_response)
      })
  }
  processGetAllReplies(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class GroupClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  get(groupId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Group/{groupId}"
    if (groupId === undefined || groupId === null)
      throw new Error("The parameter 'groupId' must be defined.")
    url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class GroupFileClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param includeChildGroups (optional)
   */
  getAll(groupId, search, skip, take, includeChildGroups, cancelToken) {
    let url_ = this.baseUrl + "/v1/Group/{groupId}/File?"
    if (groupId === undefined || groupId === null)
      throw new Error("The parameter 'groupId' must be defined.")
    url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId))
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (includeChildGroups === null)
      throw new Error("The parameter 'includeChildGroups' cannot be null.")
    else if (includeChildGroups !== undefined)
      url_ +=
        "includeChildGroups=" +
        encodeURIComponent("" + includeChildGroups) +
        "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAll(_response)
      })
  }
  processGetAll(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(groupId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Group/{groupId}/File"
    if (groupId === undefined || groupId === null)
      throw new Error("The parameter 'groupId' must be defined.")
    url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(groupId, fileId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Group/{groupId}/File/{fileId}"
    if (groupId === undefined || groupId === null)
      throw new Error("The parameter 'groupId' must be defined.")
    url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId))
    if (fileId === undefined || fileId === null)
      throw new Error("The parameter 'fileId' must be defined.")
    url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(groupId, fileId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Group/{groupId}/File/{fileId}"
    if (groupId === undefined || groupId === null)
      throw new Error("The parameter 'groupId' must be defined.")
    url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId))
    if (fileId === undefined || fileId === null)
      throw new Error("The parameter 'fileId' must be defined.")
    url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(groupId, fileId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Group/{groupId}/File/{fileId}"
    if (groupId === undefined || groupId === null)
      throw new Error("The parameter 'groupId' must be defined.")
    url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId))
    if (fileId === undefined || fileId === null)
      throw new Error("The parameter 'fileId' must be defined.")
    url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  download(groupId, fileId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Group/{groupId}/File/{fileId}/Download"
    if (groupId === undefined || groupId === null)
      throw new Error("The parameter 'groupId' must be defined.")
    url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId))
    if (fileId === undefined || fileId === null)
      throw new Error("The parameter 'fileId' must be defined.")
    url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      responseType: "blob",
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/octet-stream",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDownload(_response)
      })
  }
  processDownload(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Promise.resolve({
        fileName: fileName,
        status: status,
        data: new Blob([response.data], {
          type: response.headers["content-type"],
        }),
        headers: _headers,
      })
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class JobTypeClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   */
  getAll(search, skip, take, cancelToken) {
    let url_ = this.baseUrl + "/v1/JobType?"
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAll(_response)
      })
  }
  processGetAll(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/JobType"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(jobTypeId, cancelToken) {
    let url_ = this.baseUrl + "/v1/JobType/{jobTypeId}"
    if (jobTypeId === undefined || jobTypeId === null)
      throw new Error("The parameter 'jobTypeId' must be defined.")
    url_ = url_.replace("{jobTypeId}", encodeURIComponent("" + jobTypeId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(jobTypeId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/JobType/{jobTypeId}"
    if (jobTypeId === undefined || jobTypeId === null)
      throw new Error("The parameter 'jobTypeId' must be defined.")
    url_ = url_.replace("{jobTypeId}", encodeURIComponent("" + jobTypeId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(jobTypeId, version, cancelToken) {
    let url_ = this.baseUrl + "/v1/JobType/{jobTypeId}?"
    if (jobTypeId === undefined || jobTypeId === null)
      throw new Error("The parameter 'jobTypeId' must be defined.")
    url_ = url_.replace("{jobTypeId}", encodeURIComponent("" + jobTypeId))
    if (version === null)
      throw new Error("The parameter 'version' cannot be null.")
    else if (version !== undefined)
      url_ += "version=" + encodeURIComponent("" + version) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class LabelClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   */
  getAllForGroup(groupId, search, skip, take, cancelToken) {
    let url_ = this.baseUrl + "/v1/Label/Group/{groupId}?"
    if (groupId === undefined || groupId === null)
      throw new Error("The parameter 'groupId' must be defined.")
    url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId))
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllForGroup(_response)
      })
  }
  processGetAllForGroup(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(labelId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Label/{labelId}"
    if (labelId === undefined || labelId === null)
      throw new Error("The parameter 'labelId' must be defined.")
    url_ = url_.replace("{labelId}", encodeURIComponent("" + labelId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(labelId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Label/{labelId}"
    if (labelId === undefined || labelId === null)
      throw new Error("The parameter 'labelId' must be defined.")
    url_ = url_.replace("{labelId}", encodeURIComponent("" + labelId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(labelId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Label/{labelId}"
    if (labelId === undefined || labelId === null)
      throw new Error("The parameter 'labelId' must be defined.")
    url_ = url_.replace("{labelId}", encodeURIComponent("" + labelId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Label"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class MemberClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param status (optional)
   * @param jobTypeIds (optional)
   * @param jobCategories (optional)
   * @param roles (optional)
   * @param includeDeactivated (optional)
   */
  getAllForGroup(
    groupId,
    search,
    skip,
    take,
    status,
    jobTypeIds,
    jobCategories,
    roles,
    includeDeactivated,
    cancelToken
  ) {
    let url_ = this.baseUrl + "/v1/Member/Group/{groupId}?"
    if (groupId === undefined || groupId === null)
      throw new Error("The parameter 'groupId' must be defined.")
    url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId))
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (status !== undefined && status !== null)
      url_ += "status=" + encodeURIComponent("" + status) + "&"
    if (jobTypeIds !== undefined && jobTypeIds !== null)
      jobTypeIds &&
        jobTypeIds.forEach(item => {
          url_ += "jobTypeIds=" + encodeURIComponent("" + item) + "&"
        })
    if (jobCategories !== undefined && jobCategories !== null)
      jobCategories &&
        jobCategories.forEach(item => {
          url_ += "jobCategories=" + encodeURIComponent("" + item) + "&"
        })
    if (roles !== undefined && roles !== null)
      roles &&
        roles.forEach(item => {
          url_ += "roles=" + encodeURIComponent("" + item) + "&"
        })
    if (includeDeactivated !== undefined && includeDeactivated !== null)
      url_ +=
        "includeDeactivated=" +
        encodeURIComponent("" + includeDeactivated) +
        "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllForGroup(_response)
      })
  }
  processGetAllForGroup(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param status (optional)
   * @param jobTypeIds (optional)
   * @param jobCategories (optional)
   * @param memberRoles (optional)
   * @param identityPermission (optional)
   * @param includeDeactivated (optional)
   */
  getAllForChildGroups(
    groupId,
    childGroupType,
    search,
    skip,
    take,
    status,
    jobTypeIds,
    jobCategories,
    memberRoles,
    identityPermission,
    includeDeactivated,
    cancelToken
  ) {
    let url_ =
      this.baseUrl + "/v1/Member/Group/{groupId}/Child/{childGroupType}?"
    if (groupId === undefined || groupId === null)
      throw new Error("The parameter 'groupId' must be defined.")
    url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId))
    if (childGroupType === undefined || childGroupType === null)
      throw new Error("The parameter 'childGroupType' must be defined.")
    url_ = url_.replace(
      "{childGroupType}",
      encodeURIComponent("" + childGroupType)
    )
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (status !== undefined && status !== null)
      url_ += "status=" + encodeURIComponent("" + status) + "&"
    if (jobTypeIds !== undefined && jobTypeIds !== null)
      jobTypeIds &&
        jobTypeIds.forEach(item => {
          url_ += "jobTypeIds=" + encodeURIComponent("" + item) + "&"
        })
    if (jobCategories !== undefined && jobCategories !== null)
      jobCategories &&
        jobCategories.forEach(item => {
          url_ += "jobCategories=" + encodeURIComponent("" + item) + "&"
        })
    if (memberRoles !== undefined && memberRoles !== null)
      memberRoles &&
        memberRoles.forEach(item => {
          url_ += "memberRoles=" + encodeURIComponent("" + item) + "&"
        })
    if (identityPermission !== undefined && identityPermission !== null)
      url_ +=
        "identityPermission=" +
        encodeURIComponent("" + identityPermission) +
        "&"
    if (includeDeactivated !== undefined && includeDeactivated !== null)
      url_ +=
        "includeDeactivated=" +
        encodeURIComponent("" + includeDeactivated) +
        "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllForChildGroups(_response)
      })
  }
  processGetAllForChildGroups(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param status (optional)
   */
  getAllForUser(userId, search, skip, take, status, cancelToken) {
    let url_ = this.baseUrl + "/v1/Member/User/{userId}?"
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.")
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId))
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (status !== undefined && status !== null)
      url_ += "status=" + encodeURIComponent("" + status) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllForUser(_response)
      })
  }
  processGetAllForUser(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
   * Gets the list of users in a group at the given time.
   * @param groupId Id of the group to get the users from.
   * @param at (optional) The UTC time at which to get users. If not specified, the current time is used.
   * @param status (optional) The status used to filter the result.
   * @param role (optional) The role used to filter the result
   * @return The list of users with their membership status and roles within the group at the given time.
   */
  getAllGroupHistory(groupId, at, status, role, cancelToken) {
    let url_ = this.baseUrl + "/v1/Member/Group/{groupId}/History?"
    if (groupId === undefined || groupId === null)
      throw new Error("The parameter 'groupId' must be defined.")
    url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId))
    if (at !== undefined && at !== null)
      url_ += "at=" + encodeURIComponent(at ? "" + at.toISOString() : "") + "&"
    if (status !== undefined && status !== null)
      url_ += "status=" + encodeURIComponent("" + status) + "&"
    if (role !== undefined && role !== null)
      url_ += "role=" + encodeURIComponent("" + role) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllGroupHistory(_response)
      })
  }
  processGetAllGroupHistory(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(groupId, userId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Member/Group/{groupId}/User/{userId}"
    if (groupId === undefined || groupId === null)
      throw new Error("The parameter 'groupId' must be defined.")
    url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId))
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.")
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  add(groupId, userId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Member/Group/{groupId}/User/{userId}/Add"
    if (groupId === undefined || groupId === null)
      throw new Error("The parameter 'groupId' must be defined.")
    url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId))
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.")
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processAdd(_response)
      })
  }
  processAdd(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  join(groupId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Member/Group/{groupId}/User/Join"
    if (groupId === undefined || groupId === null)
      throw new Error("The parameter 'groupId' must be defined.")
    url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "POST",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processJoin(_response)
      })
  }
  processJoin(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(groupId, userId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Member/Group/{groupId}/User/{userId}/Update"
    if (groupId === undefined || groupId === null)
      throw new Error("The parameter 'groupId' must be defined.")
    url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId))
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.")
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  remove(groupId, userId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Member/Group/{groupId}/User/{userId}/Remove"
    if (groupId === undefined || groupId === null)
      throw new Error("The parameter 'groupId' must be defined.")
    url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId))
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.")
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "PUT",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processRemove(_response)
      })
  }
  processRemove(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  ban(groupId, userId, reason, cancelToken) {
    let url_ = this.baseUrl + "/v1/Member/Group/{groupId}/User/{userId}/Ban?"
    if (groupId === undefined || groupId === null)
      throw new Error("The parameter 'groupId' must be defined.")
    url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId))
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.")
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId))
    if (reason !== undefined && reason !== null)
      url_ += "reason=" + encodeURIComponent("" + reason) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "PUT",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processBan(_response)
      })
  }
  processBan(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  leave(groupId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Member/Group/{groupId}/User/Leave"
    if (groupId === undefined || groupId === null)
      throw new Error("The parameter 'groupId' must be defined.")
    url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "PUT",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processLeave(_response)
      })
  }
  processLeave(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  acceptGroupInvitation(invitationId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Member/GroupInvitation/{invitationId}/Accept"
    if (invitationId === undefined || invitationId === null)
      throw new Error("The parameter 'invitationId' must be defined.")
    url_ = url_.replace("{invitationId}", encodeURIComponent("" + invitationId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "PUT",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processAcceptGroupInvitation(_response)
      })
  }
  processAcceptGroupInvitation(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  emailAll(groupId, message, role, cancelToken) {
    let url_ = this.baseUrl + "/v1/Member/Email?"
    if (groupId !== undefined && groupId !== null)
      url_ += "groupId=" + encodeURIComponent("" + groupId) + "&"
    if (message !== undefined && message !== null)
      url_ += "message=" + encodeURIComponent("" + message) + "&"
    if (role !== undefined && role !== null)
      url_ += "role=" + encodeURIComponent("" + role) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "POST",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processEmailAll(_response)
      })
  }
  processEmailAll(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  email(groupId, userId, message, cancelToken) {
    let url_ = this.baseUrl + "/v1/Member/Group/{groupId}/User/{userId}/Email?"
    if (groupId === undefined || groupId === null)
      throw new Error("The parameter 'groupId' must be defined.")
    url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId))
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.")
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId))
    if (message !== undefined && message !== null)
      url_ += "message=" + encodeURIComponent("" + message) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "POST",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processEmail(_response)
      })
  }
  processEmail(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class OrganisationAccessTokenClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param organisationId (optional)
   */
  getAll(search, skip, take, organisationId, cancelToken) {
    let url_ = this.baseUrl + "/v1/OrganisationAccessToken?"
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (organisationId !== undefined && organisationId !== null)
      url_ += "organisationId=" + encodeURIComponent("" + organisationId) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAll(_response)
      })
  }
  processGetAll(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/OrganisationAccessToken"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  getAll2(tokenId, cancelToken) {
    let url_ = this.baseUrl + "/v1/OrganisationAccessToken/{tokenId}"
    if (tokenId === undefined || tokenId === null)
      throw new Error("The parameter 'tokenId' must be defined.")
    url_ = url_.replace("{tokenId}", encodeURIComponent("" + tokenId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAll2(_response)
      })
  }
  processGetAll2(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(tokenId, cancelToken) {
    let url_ = this.baseUrl + "/v1/OrganisationAccessToken/{tokenId}"
    if (tokenId === undefined || tokenId === null)
      throw new Error("The parameter 'tokenId' must be defined.")
    url_ = url_.replace("{tokenId}", encodeURIComponent("" + tokenId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class OrganisationClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param identityPermissions (optional)
   */
  getAll(search, skip, take, identityPermissions, cancelToken) {
    let url_ = this.baseUrl + "/v1/Organisation?"
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (identityPermissions !== undefined && identityPermissions !== null)
      identityPermissions &&
        identityPermissions.forEach(item => {
          url_ += "identityPermissions=" + encodeURIComponent("" + item) + "&"
        })
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAll(_response)
      })
  }
  processGetAll(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Organisation"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(organisationId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Organisation/{organisationId}"
    if (organisationId === undefined || organisationId === null)
      throw new Error("The parameter 'organisationId' must be defined.")
    url_ = url_.replace(
      "{organisationId}",
      encodeURIComponent("" + organisationId)
    )
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(organisationId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Organisation/{organisationId}"
    if (organisationId === undefined || organisationId === null)
      throw new Error("The parameter 'organisationId' must be defined.")
    url_ = url_.replace(
      "{organisationId}",
      encodeURIComponent("" + organisationId)
    )
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(organisationId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Organisation/{organisationId}"
    if (organisationId === undefined || organisationId === null)
      throw new Error("The parameter 'organisationId' must be defined.")
    url_ = url_.replace(
      "{organisationId}",
      encodeURIComponent("" + organisationId)
    )
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class PasswordClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  get(userId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Password/{userId}"
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.")
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(userId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Password/{userId}"
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.")
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  updateTwoFactorAuthentication(userId, settings, cancelToken) {
    let url_ =
      this.baseUrl + "/v1/Password/{userId}/UpdateTwoFactorAuthentication"
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.")
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdateTwoFactorAuthentication(_response)
      })
  }
  processUpdateTwoFactorAuthentication(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  requestReset(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Password/RequestReset"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processRequestReset(_response)
      })
  }
  processRequestReset(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  reset(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Password/Reset"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processReset(_response)
      })
  }
  processReset(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class PhoneNumberRegistrationClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * Check if the phoneNumber is registered in the system
   * @return 200 OK if the phoneNumber is found, else a 404
   */
  get(phoneNumber, cancelToken) {
    let url_ = this.baseUrl + "/v1/PhoneNumberRegistration/{phoneNumber}"
    if (phoneNumber === undefined || phoneNumber === null)
      throw new Error("The parameter 'phoneNumber' must be defined.")
    url_ = url_.replace("{phoneNumber}", encodeURIComponent("" + phoneNumber))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      responseType: "blob",
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/octet-stream",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Promise.resolve({
        fileName: fileName,
        status: status,
        data: new Blob([response.data], {
          type: response.headers["content-type"],
        }),
        headers: _headers,
      })
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class RoleClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  getAll(groupType, cancelToken) {
    let url_ = this.baseUrl + "/v1/Role?"
    if (groupType !== undefined && groupType !== null)
      url_ += "groupType=" + encodeURIComponent("" + groupType) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAll(_response)
      })
  }
  processGetAll(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(roleName, cancelToken) {
    let url_ = this.baseUrl + "/v1/Role/{roleName}"
    if (roleName === undefined || roleName === null)
      throw new Error("The parameter 'roleName' must be defined.")
    url_ = url_.replace("{roleName}", encodeURIComponent("" + roleName))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class TeamClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param organisationId (optional)
   * @param identityPermissions (optional)
   */
  getAll(search, skip, take, organisationId, identityPermissions, cancelToken) {
    let url_ = this.baseUrl + "/v1/Team?"
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (organisationId !== undefined && organisationId !== null)
      url_ += "organisationId=" + encodeURIComponent("" + organisationId) + "&"
    if (identityPermissions !== undefined && identityPermissions !== null)
      identityPermissions &&
        identityPermissions.forEach(item => {
          url_ += "identityPermissions=" + encodeURIComponent("" + item) + "&"
        })
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAll(_response)
      })
  }
  processGetAll(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Team"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(teamId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Team/{teamId}"
    if (teamId === undefined || teamId === null)
      throw new Error("The parameter 'teamId' must be defined.")
    url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(teamId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/Team/{teamId}"
    if (teamId === undefined || teamId === null)
      throw new Error("The parameter 'teamId' must be defined.")
    url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(teamId, cancelToken) {
    let url_ = this.baseUrl + "/v1/Team/{teamId}"
    if (teamId === undefined || teamId === null)
      throw new Error("The parameter 'teamId' must be defined.")
    url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class UserActivityClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param moduleType (optional)
   * @param programId (optional)
   * @param from (optional)
   * @param to (optional)
   */
  getAllForGroup(
    groupId,
    search,
    skip,
    take,
    moduleType,
    programId,
    from,
    to,
    cancelToken
  ) {
    let url_ = this.baseUrl + "/v1/UserActivity/Group/{groupId}?"
    if (groupId === undefined || groupId === null)
      throw new Error("The parameter 'groupId' must be defined.")
    url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId))
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (moduleType !== undefined && moduleType !== null)
      url_ += "moduleType=" + encodeURIComponent("" + moduleType) + "&"
    if (programId !== undefined && programId !== null)
      url_ += "programId=" + encodeURIComponent("" + programId) + "&"
    if (from !== undefined && from !== null)
      url_ +=
        "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&"
    if (to !== undefined && to !== null)
      url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllForGroup(_response)
      })
  }
  processGetAllForGroup(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   * @param moduleType (optional)
   * @param programId (optional)
   * @param from (optional)
   * @param to (optional)
   */
  getAllForPublisher(
    publisherId,
    search,
    skip,
    take,
    moduleType,
    programId,
    from,
    to,
    cancelToken
  ) {
    let url_ = this.baseUrl + "/v1/UserActivity/Publisher/{publisherId}?"
    if (publisherId === undefined || publisherId === null)
      throw new Error("The parameter 'publisherId' must be defined.")
    url_ = url_.replace("{publisherId}", encodeURIComponent("" + publisherId))
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    if (moduleType !== undefined && moduleType !== null)
      url_ += "moduleType=" + encodeURIComponent("" + moduleType) + "&"
    if (programId !== undefined && programId !== null)
      url_ += "programId=" + encodeURIComponent("" + programId) + "&"
    if (from !== undefined && from !== null)
      url_ +=
        "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&"
    if (to !== undefined && to !== null)
      url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAllForPublisher(_response)
      })
  }
  processGetAllForPublisher(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class UserClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  /**
   * @param search (optional)
   * @param skip (optional)
   * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
   */
  getAll(search, skip, take, cancelToken) {
    let url_ = this.baseUrl + "/v1/User?"
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&"
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.")
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&"
    if (take === null) throw new Error("The parameter 'take' cannot be null.")
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGetAll(_response)
      })
  }
  processGetAll(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  create(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/User"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processCreate(_response)
      })
  }
  processCreate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  get(userId, cancelToken) {
    let url_ = this.baseUrl + "/v1/User/{userId}"
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.")
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(userId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/User/{userId}"
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.")
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  delete(userId, cancelToken) {
    let url_ = this.baseUrl + "/v1/User/{userId}"
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.")
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "DELETE",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processDelete(_response)
      })
  }
  processDelete(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  onboard(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/User/Onboard"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processOnboard(_response)
      })
  }
  processOnboard(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  activate(userId, cancelToken) {
    let url_ = this.baseUrl + "/v1/User/{userId}/Activate"
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.")
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "POST",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processActivate(_response)
      })
  }
  processActivate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  merge(settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/User/Merge"
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processMerge(_response)
      })
  }
  processMerge(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  contact(userId, message, cancelToken) {
    let url_ = this.baseUrl + "/v1/User/{userId}/Contact?"
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.")
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId))
    if (message !== undefined && message !== null)
      url_ += "message=" + encodeURIComponent("" + message) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "POST",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processContact(_response)
      })
  }
  processContact(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  sendWelcomeEmail(userId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/User/{userId}/SendWelcomeEmail"
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.")
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      responseType: "blob",
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/octet-stream",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processSendWelcomeEmail(_response)
      })
  }
  processSendWelcomeEmail(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Promise.resolve({
        fileName: fileName,
        status: status,
        data: new Blob([response.data], {
          type: response.headers["content-type"],
        }),
        headers: _headers,
      })
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  welcomeEmailTemplate(
    userName,
    userEmail,
    creatorName,
    message_CreatorName,
    message_CreatorImageUri,
    message_CreatorDescription,
    message_Message,
    welcomeButtonUri,
    welcomeButtonText,
    group_Title,
    group_ImageUri,
    group_Uri,
    group_Description,
    group_Subtitle,
    group_SubtitleImageUri,
    group_ActionButton,
    group_ActionUri,
    applicationName,
    productName,
    supportUri,
    termOfServiceUri,
    cancelToken
  ) {
    let url_ = this.baseUrl + "/v1/User/WelcomeEmailTemplate?"
    if (userName !== undefined && userName !== null)
      url_ += "UserName=" + encodeURIComponent("" + userName) + "&"
    if (userEmail !== undefined && userEmail !== null)
      url_ += "UserEmail=" + encodeURIComponent("" + userEmail) + "&"
    if (creatorName !== undefined && creatorName !== null)
      url_ += "CreatorName=" + encodeURIComponent("" + creatorName) + "&"
    if (message_CreatorName !== undefined && message_CreatorName !== null)
      url_ +=
        "Message.CreatorName=" +
        encodeURIComponent("" + message_CreatorName) +
        "&"
    if (
      message_CreatorImageUri !== undefined &&
      message_CreatorImageUri !== null
    )
      url_ +=
        "Message.CreatorImageUri=" +
        encodeURIComponent("" + message_CreatorImageUri) +
        "&"
    if (
      message_CreatorDescription !== undefined &&
      message_CreatorDescription !== null
    )
      url_ +=
        "Message.CreatorDescription=" +
        encodeURIComponent("" + message_CreatorDescription) +
        "&"
    if (message_Message !== undefined && message_Message !== null)
      url_ +=
        "Message.Message=" + encodeURIComponent("" + message_Message) + "&"
    if (welcomeButtonUri !== undefined && welcomeButtonUri !== null)
      url_ +=
        "WelcomeButtonUri=" + encodeURIComponent("" + welcomeButtonUri) + "&"
    if (welcomeButtonText !== undefined && welcomeButtonText !== null)
      url_ +=
        "WelcomeButtonText=" + encodeURIComponent("" + welcomeButtonText) + "&"
    if (group_Title !== undefined && group_Title !== null)
      url_ += "Group.Title=" + encodeURIComponent("" + group_Title) + "&"
    if (group_ImageUri !== undefined && group_ImageUri !== null)
      url_ += "Group.ImageUri=" + encodeURIComponent("" + group_ImageUri) + "&"
    if (group_Uri !== undefined && group_Uri !== null)
      url_ += "Group.Uri=" + encodeURIComponent("" + group_Uri) + "&"
    if (group_Description !== undefined && group_Description !== null)
      url_ +=
        "Group.Description=" + encodeURIComponent("" + group_Description) + "&"
    if (group_Subtitle !== undefined && group_Subtitle !== null)
      url_ += "Group.Subtitle=" + encodeURIComponent("" + group_Subtitle) + "&"
    if (group_SubtitleImageUri !== undefined && group_SubtitleImageUri !== null)
      url_ +=
        "Group.SubtitleImageUri=" +
        encodeURIComponent("" + group_SubtitleImageUri) +
        "&"
    if (group_ActionButton !== undefined && group_ActionButton !== null)
      url_ +=
        "Group.ActionButton=" +
        encodeURIComponent("" + group_ActionButton) +
        "&"
    if (group_ActionUri !== undefined && group_ActionUri !== null)
      url_ +=
        "Group.ActionUri=" + encodeURIComponent("" + group_ActionUri) + "&"
    if (applicationName !== undefined && applicationName !== null)
      url_ +=
        "ApplicationName=" + encodeURIComponent("" + applicationName) + "&"
    if (productName !== undefined && productName !== null)
      url_ += "ProductName=" + encodeURIComponent("" + productName) + "&"
    if (supportUri !== undefined && supportUri !== null)
      url_ += "SupportUri=" + encodeURIComponent("" + supportUri) + "&"
    if (termOfServiceUri !== undefined && termOfServiceUri !== null)
      url_ +=
        "TermOfServiceUri=" + encodeURIComponent("" + termOfServiceUri) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      responseType: "blob",
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/octet-stream",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processWelcomeEmailTemplate(_response)
      })
  }
  processWelcomeEmailTemplate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Promise.resolve({
        fileName: fileName,
        status: status,
        data: new Blob([response.data], {
          type: response.headers["content-type"],
        }),
        headers: _headers,
      })
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  contactEmailTemplate(
    userName,
    creatorEmail,
    creatorName,
    message_CreatorName,
    message_CreatorImageUri,
    message_CreatorDescription,
    message_Message,
    group_Title,
    group_ImageUri,
    group_Uri,
    group_Description,
    group_Subtitle,
    group_SubtitleImageUri,
    group_ActionButton,
    group_ActionUri,
    cancelToken
  ) {
    let url_ = this.baseUrl + "/v1/User/ContactEmailTemplate?"
    if (userName !== undefined && userName !== null)
      url_ += "UserName=" + encodeURIComponent("" + userName) + "&"
    if (creatorEmail !== undefined && creatorEmail !== null)
      url_ += "CreatorEmail=" + encodeURIComponent("" + creatorEmail) + "&"
    if (creatorName !== undefined && creatorName !== null)
      url_ += "CreatorName=" + encodeURIComponent("" + creatorName) + "&"
    if (message_CreatorName !== undefined && message_CreatorName !== null)
      url_ +=
        "Message.CreatorName=" +
        encodeURIComponent("" + message_CreatorName) +
        "&"
    if (
      message_CreatorImageUri !== undefined &&
      message_CreatorImageUri !== null
    )
      url_ +=
        "Message.CreatorImageUri=" +
        encodeURIComponent("" + message_CreatorImageUri) +
        "&"
    if (
      message_CreatorDescription !== undefined &&
      message_CreatorDescription !== null
    )
      url_ +=
        "Message.CreatorDescription=" +
        encodeURIComponent("" + message_CreatorDescription) +
        "&"
    if (message_Message !== undefined && message_Message !== null)
      url_ +=
        "Message.Message=" + encodeURIComponent("" + message_Message) + "&"
    if (group_Title !== undefined && group_Title !== null)
      url_ += "Group.Title=" + encodeURIComponent("" + group_Title) + "&"
    if (group_ImageUri !== undefined && group_ImageUri !== null)
      url_ += "Group.ImageUri=" + encodeURIComponent("" + group_ImageUri) + "&"
    if (group_Uri !== undefined && group_Uri !== null)
      url_ += "Group.Uri=" + encodeURIComponent("" + group_Uri) + "&"
    if (group_Description !== undefined && group_Description !== null)
      url_ +=
        "Group.Description=" + encodeURIComponent("" + group_Description) + "&"
    if (group_Subtitle !== undefined && group_Subtitle !== null)
      url_ += "Group.Subtitle=" + encodeURIComponent("" + group_Subtitle) + "&"
    if (group_SubtitleImageUri !== undefined && group_SubtitleImageUri !== null)
      url_ +=
        "Group.SubtitleImageUri=" +
        encodeURIComponent("" + group_SubtitleImageUri) +
        "&"
    if (group_ActionButton !== undefined && group_ActionButton !== null)
      url_ +=
        "Group.ActionButton=" +
        encodeURIComponent("" + group_ActionButton) +
        "&"
    if (group_ActionUri !== undefined && group_ActionUri !== null)
      url_ +=
        "Group.ActionUri=" + encodeURIComponent("" + group_ActionUri) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      responseType: "blob",
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/octet-stream",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processContactEmailTemplate(_response)
      })
  }
  processContactEmailTemplate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined
      return Promise.resolve({
        fileName: fileName,
        status: status,
        data: new Blob([response.data], {
          type: response.headers["content-type"],
        }),
        headers: _headers,
      })
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class UserEmailClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  get(userId, cancelToken) {
    let url_ = this.baseUrl + "/v1/UserEmail/{userId}"
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.")
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  add(userId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/UserEmail/{userId}"
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.")
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processAdd(_response)
      })
  }
  processAdd(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  remove(userId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/UserEmail/{userId}"
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.")
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "DELETE",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processRemove(_response)
      })
  }
  processRemove(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  changePrimary(userId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/UserEmail/{userId}/ChangePrimary"
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.")
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processChangePrimary(_response)
      })
  }
  processChangePrimary(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  sendVerification(userId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/UserEmail/{userId}/SendVerification"
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.")
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processSendVerification(_response)
      })
  }
  processSendVerification(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  verify(verificationToken, cancelToken) {
    let url_ = this.baseUrl + "/v1/UserEmail/Verify?"
    if (verificationToken !== undefined && verificationToken !== null)
      url_ +=
        "verificationToken=" + encodeURIComponent("" + verificationToken) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processVerify(_response)
      })
  }
  processVerify(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  verify2(verificationToken, cancelToken) {
    let url_ = this.baseUrl + "/v1/UserEmail/Verify/{verificationToken}"
    if (verificationToken === undefined || verificationToken === null)
      throw new Error("The parameter 'verificationToken' must be defined.")
    url_ = url_.replace(
      "{verificationToken}",
      encodeURIComponent("" + verificationToken)
    )
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "POST",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processVerify2(_response)
      })
  }
  processVerify2(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  contact(userId, message, groupId, cancelToken) {
    let url_ = this.baseUrl + "/v1/UserEmail/{userId}/Contact?"
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.")
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId))
    if (message !== undefined && message !== null)
      url_ += "message=" + encodeURIComponent("" + message) + "&"
    if (groupId !== undefined && groupId !== null)
      url_ += "groupId=" + encodeURIComponent("" + groupId) + "&"
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "POST",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processContact(_response)
      })
  }
  processContact(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export class UserPhoneNumberClient {
  constructor(baseUrl, instance) {
    this.jsonParseReviver = undefined
    this.instance = instance ? instance : axios.create()
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }
  get(userId, cancelToken) {
    let url_ = this.baseUrl + "/v1/UserPhoneNumber/{userId}"
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.")
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processGet(_response)
      })
  }
  processGet(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  update(userId, settings, cancelToken) {
    let url_ = this.baseUrl + "/v1/UserPhoneNumber/{userId}"
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.")
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId))
    url_ = url_.replace(/[?&]$/, "")
    const content_ = JSON.stringify(settings)
    let options_ = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processUpdate(_response)
      })
  }
  processUpdate(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  sendVerification(userId, cancelToken) {
    let url_ = this.baseUrl + "/v1/UserPhoneNumber/{userId}/SendVerification"
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.")
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId))
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "POST",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processSendVerification(_response)
      })
  }
  processSendVerification(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 200) {
      return Promise.resolve(response.data)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
  verify(verificationCode, cancelToken) {
    let url_ = this.baseUrl + "/v1/UserPhoneNumber/Verify/{verificationCode}"
    if (verificationCode === undefined || verificationCode === null)
      throw new Error("The parameter 'verificationCode' must be defined.")
    url_ = url_.replace(
      "{verificationCode}",
      encodeURIComponent("" + verificationCode)
    )
    url_ = url_.replace(/[?&]$/, "")
    let options_ = {
      method: "POST",
      url: url_,
      headers: {},
      cancelToken,
    }
    return this.instance
      .request(options_)
      .catch(_error => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response
        } else {
          throw _error
        }
      })
      .then(_response => {
        return this.processVerify(_response)
      })
  }
  processVerify(response) {
    const status = response.status
    let _headers = {}
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k]
        }
      }
    }
    if (status === 204) {
      return Promise.resolve(null)
    } else if (status === 401) {
      return throwException("", status, response.data, _headers)
    } else if (status === 403) {
      return throwException("", status, response.data, _headers)
    } else if (status === 404) {
      return throwException("", status, response.data, _headers)
    } else if (status === 503) {
      return throwException("", status, response.data, _headers)
    } else if (status === 504) {
      return throwException("", status, response.data, _headers)
    } else if (status !== 200 && status !== 204) {
      return throwException("", status, response.data, _headers)
    }
    return Promise.resolve(null)
  }
}
export var EmailType
;(function (EmailType) {
  EmailType["None"] = "None"
  EmailType["EventInvite"] = "EventInvite"
  EmailType["EventChanged"] = "EventChanged"
  EmailType["ScheduledLink"] = "ScheduledLink"
  EmailType["RequestSurvey"] = "RequestSurvey"
  EmailType["AddedToGroup"] = "AddedToGroup"
  EmailType["AddedToClass"] = "AddedToClass"
  EmailType["ModuleAttempt"] = "ModuleAttempt"
  EmailType["Authentication"] = "Authentication"
  EmailType["Confirm"] = "Confirm"
  EmailType["ContactUser"] = "ContactUser"
  EmailType["PublishingRequested"] = "PublishingRequested"
  EmailType["PublishingRequestApproved"] = "PublishingRequestApproved"
  EmailType["PublishingRequestRejected"] = "PublishingRequestRejected"
  EmailType["RequestResetPassword"] = "RequestResetPassword"
  EmailType["Welcome"] = "Welcome"
  EmailType["Support"] = "Support"
  EmailType["SupportConfirmation"] = "SupportConfirmation"
  EmailType["SupportStatusChanged"] = "SupportStatusChanged"
  EmailType["RequestResetPasswordFailed"] = "RequestResetPasswordFailed"
})(EmailType || (EmailType = {}))
/** 0 = None 1 = Submitted 2 = Received 3 = Read 4 = Clicked 5 = Spammed 6 = Error */
export var EmailStatus
;(function (EmailStatus) {
  EmailStatus[(EmailStatus["None"] = 0)] = "None"
  EmailStatus[(EmailStatus["Submitted"] = 1)] = "Submitted"
  EmailStatus[(EmailStatus["Received"] = 2)] = "Received"
  EmailStatus[(EmailStatus["Read"] = 3)] = "Read"
  EmailStatus[(EmailStatus["Clicked"] = 4)] = "Clicked"
  EmailStatus[(EmailStatus["Spammed"] = 5)] = "Spammed"
  EmailStatus[(EmailStatus["Error"] = 6)] = "Error"
})(EmailStatus || (EmailStatus = {}))
/** 0 = None 1 = Yes 2 = No 3 = Maybe */
export var AttendanceStatus
;(function (AttendanceStatus) {
  AttendanceStatus[(AttendanceStatus["None"] = 0)] = "None"
  AttendanceStatus[(AttendanceStatus["Yes"] = 1)] = "Yes"
  AttendanceStatus[(AttendanceStatus["No"] = 2)] = "No"
  AttendanceStatus[(AttendanceStatus["Maybe"] = 3)] = "Maybe"
})(AttendanceStatus || (AttendanceStatus = {}))
/** 0 = Running 1 = Completed 2 = Error */
export var BackupStatus
;(function (BackupStatus) {
  BackupStatus[(BackupStatus["Running"] = 0)] = "Running"
  BackupStatus[(BackupStatus["Completed"] = 1)] = "Completed"
  BackupStatus[(BackupStatus["Error"] = 2)] = "Error"
})(BackupStatus || (BackupStatus = {}))
/** 0 = Built 1 = Building 2 = Maintenance -1 = Failed */
export var ProjectionStatus
;(function (ProjectionStatus) {
  ProjectionStatus[(ProjectionStatus["Built"] = 0)] = "Built"
  ProjectionStatus[(ProjectionStatus["Building"] = 1)] = "Building"
  ProjectionStatus[(ProjectionStatus["Maintenance"] = 2)] = "Maintenance"
  ProjectionStatus[(ProjectionStatus["Failed"] = -1)] = "Failed"
})(ProjectionStatus || (ProjectionStatus = {}))
/** 0 = None 1 = Daily 2 = Weekly 3 = MonthlyByDay 4 = MonthlyByDayOfWeek 5 = Yearly */
export var RepeatType
;(function (RepeatType) {
  RepeatType[(RepeatType["None"] = 0)] = "None"
  RepeatType[(RepeatType["Daily"] = 1)] = "Daily"
  RepeatType[(RepeatType["Weekly"] = 2)] = "Weekly"
  RepeatType[(RepeatType["MonthlyByDay"] = 3)] = "MonthlyByDay"
  RepeatType[(RepeatType["MonthlyByDayOfWeek"] = 4)] = "MonthlyByDayOfWeek"
  RepeatType[(RepeatType["Yearly"] = 5)] = "Yearly"
})(RepeatType || (RepeatType = {}))
/** 0 = Public 1 = Closed 2 = Secret */
export var PrivacyLevel
;(function (PrivacyLevel) {
  PrivacyLevel[(PrivacyLevel["Public"] = 0)] = "Public"
  PrivacyLevel[(PrivacyLevel["Closed"] = 1)] = "Closed"
  PrivacyLevel[(PrivacyLevel["Secret"] = 2)] = "Secret"
})(PrivacyLevel || (PrivacyLevel = {}))
/** 0 = None 1 = Pending 2 = Succeeded 3 = Failed 4 = Refunded */
export var PaymentStatus
;(function (PaymentStatus) {
  PaymentStatus[(PaymentStatus["None"] = 0)] = "None"
  PaymentStatus[(PaymentStatus["Pending"] = 1)] = "Pending"
  PaymentStatus[(PaymentStatus["Succeeded"] = 2)] = "Succeeded"
  PaymentStatus[(PaymentStatus["Failed"] = 3)] = "Failed"
  PaymentStatus[(PaymentStatus["Refunded"] = 4)] = "Refunded"
})(PaymentStatus || (PaymentStatus = {}))
/** 0 = None 1 = NotStarted 2 = Started 3 = Complete 4 = Rejected */
export var TaskStatus
;(function (TaskStatus) {
  TaskStatus[(TaskStatus["None"] = 0)] = "None"
  TaskStatus[(TaskStatus["NotStarted"] = 1)] = "NotStarted"
  TaskStatus[(TaskStatus["Started"] = 2)] = "Started"
  TaskStatus[(TaskStatus["Complete"] = 3)] = "Complete"
  TaskStatus[(TaskStatus["Rejected"] = 4)] = "Rejected"
})(TaskStatus || (TaskStatus = {}))
/** 0 = NotActivated 1 = Requested 2 = Activated 3 = Deactivated */
export var ProgramPhaseActivationStatus
;(function (ProgramPhaseActivationStatus) {
  ProgramPhaseActivationStatus[
    (ProgramPhaseActivationStatus["NotActivated"] = 0)
  ] = "NotActivated"
  ProgramPhaseActivationStatus[
    (ProgramPhaseActivationStatus["Requested"] = 1)
  ] = "Requested"
  ProgramPhaseActivationStatus[
    (ProgramPhaseActivationStatus["Activated"] = 2)
  ] = "Activated"
  ProgramPhaseActivationStatus[
    (ProgramPhaseActivationStatus["Deactivated"] = 3)
  ] = "Deactivated"
})(ProgramPhaseActivationStatus || (ProgramPhaseActivationStatus = {}))
/** 0 = Course 1 = ObservationDefinition 2 = Survey 3 = Implementation */
export var ProgramResourceType
;(function (ProgramResourceType) {
  ProgramResourceType[(ProgramResourceType["Course"] = 0)] = "Course"
  ProgramResourceType[(ProgramResourceType["ObservationDefinition"] = 1)] =
    "ObservationDefinition"
  ProgramResourceType[(ProgramResourceType["Survey"] = 2)] = "Survey"
  ProgramResourceType[(ProgramResourceType["Implementation"] = 3)] =
    "Implementation"
})(ProgramResourceType || (ProgramResourceType = {}))
export var SharingType
;(function (SharingType) {
  SharingType["GroupInvitation"] = "GroupInvitation"
})(SharingType || (SharingType = {}))
/** 0 = None 1 = User 2 = Organisation */
export var IdentityType
;(function (IdentityType) {
  IdentityType[(IdentityType["None"] = 0)] = "None"
  IdentityType[(IdentityType["User"] = 1)] = "User"
  IdentityType[(IdentityType["Organisation"] = 2)] = "Organisation"
})(IdentityType || (IdentityType = {}))
/** 0 = None 1 = GeneralEnquiry */
export var TicketType
;(function (TicketType) {
  TicketType[(TicketType["None"] = 0)] = "None"
  TicketType[(TicketType["GeneralEnquiry"] = 1)] = "GeneralEnquiry"
})(TicketType || (TicketType = {}))
/** 0 = Open 1 = Resolved 2 = Rejected */
export var TicketStatus
;(function (TicketStatus) {
  TicketStatus[(TicketStatus["Open"] = 0)] = "Open"
  TicketStatus[(TicketStatus["Resolved"] = 1)] = "Resolved"
  TicketStatus[(TicketStatus["Rejected"] = 2)] = "Rejected"
})(TicketStatus || (TicketStatus = {}))
/** 0 = None 1 = Horizontal 2 = Vertical */
export var LayoutType
;(function (LayoutType) {
  LayoutType[(LayoutType["None"] = 0)] = "None"
  LayoutType[(LayoutType["Horizontal"] = 1)] = "Horizontal"
  LayoutType[(LayoutType["Vertical"] = 2)] = "Vertical"
})(LayoutType || (LayoutType = {}))
/** 0 = None 1 = Counter */
export var IntegerQuestionDisplayType
;(function (IntegerQuestionDisplayType) {
  IntegerQuestionDisplayType[(IntegerQuestionDisplayType["None"] = 0)] = "None"
  IntegerQuestionDisplayType[(IntegerQuestionDisplayType["Counter"] = 1)] =
    "Counter"
})(IntegerQuestionDisplayType || (IntegerQuestionDisplayType = {}))
/** 0 = None 1 = SingleLine 2 = MultiLine */
export var LineType
;(function (LineType) {
  LineType[(LineType["None"] = 0)] = "None"
  LineType[(LineType["SingleLine"] = 1)] = "SingleLine"
  LineType[(LineType["MultiLine"] = 2)] = "MultiLine"
})(LineType || (LineType = {}))
/** 0 = None 1 = Date */
export var DateTimeConstraintType
;(function (DateTimeConstraintType) {
  DateTimeConstraintType[(DateTimeConstraintType["None"] = 0)] = "None"
  DateTimeConstraintType[(DateTimeConstraintType["Date"] = 1)] = "Date"
})(DateTimeConstraintType || (DateTimeConstraintType = {}))
/** 0 = None 1 = Days 2 = Hours 3 = Minutes 4 = Seconds */
export var TimeSpanConstraintType
;(function (TimeSpanConstraintType) {
  TimeSpanConstraintType[(TimeSpanConstraintType["None"] = 0)] = "None"
  TimeSpanConstraintType[(TimeSpanConstraintType["Days"] = 1)] = "Days"
  TimeSpanConstraintType[(TimeSpanConstraintType["Hours"] = 2)] = "Hours"
  TimeSpanConstraintType[(TimeSpanConstraintType["Minutes"] = 3)] = "Minutes"
  TimeSpanConstraintType[(TimeSpanConstraintType["Seconds"] = 4)] = "Seconds"
})(TimeSpanConstraintType || (TimeSpanConstraintType = {}))
/** 0 = Black 1 = White */
export var DomainConstraintType
;(function (DomainConstraintType) {
  DomainConstraintType[(DomainConstraintType["Black"] = 0)] = "Black"
  DomainConstraintType[(DomainConstraintType["White"] = 1)] = "White"
})(DomainConstraintType || (DomainConstraintType = {}))
/** 0 = Id 1 = Name */
export var UserValueType
;(function (UserValueType) {
  UserValueType[(UserValueType["Id"] = 0)] = "Id"
  UserValueType[(UserValueType["Name"] = 1)] = "Name"
})(UserValueType || (UserValueType = {}))
/** 0 = None 1 = User 2 = TrainingSession 3 = Team */
export var ActorType
;(function (ActorType) {
  ActorType[(ActorType["None"] = 0)] = "None"
  ActorType[(ActorType["User"] = 1)] = "User"
  ActorType[(ActorType["TrainingSession"] = 2)] = "TrainingSession"
  ActorType[(ActorType["Team"] = 3)] = "Team"
})(ActorType || (ActorType = {}))
/** 0 = None 1 = Left 2 = Requested 3 = Joined 4 = Banned */
export var MemberStatus
;(function (MemberStatus) {
  MemberStatus[(MemberStatus["None"] = 0)] = "None"
  MemberStatus[(MemberStatus["Left"] = 1)] = "Left"
  MemberStatus[(MemberStatus["Requested"] = 2)] = "Requested"
  MemberStatus[(MemberStatus["Joined"] = 3)] = "Joined"
  MemberStatus[(MemberStatus["Banned"] = 4)] = "Banned"
})(MemberStatus || (MemberStatus = {}))
/** 0 = Flipcard 1 = TrueOrFalse 2 = MultipleChoices */
export var TopicForm
;(function (TopicForm) {
  TopicForm[(TopicForm["Flipcard"] = 0)] = "Flipcard"
  TopicForm[(TopicForm["TrueOrFalse"] = 1)] = "TrueOrFalse"
  TopicForm[(TopicForm["MultipleChoices"] = 2)] = "MultipleChoices"
})(TopicForm || (TopicForm = {}))
/** 0 = None 1 = NotStarted 2 = Started 3 = Complete */
export var TrainingSessionStatus
;(function (TrainingSessionStatus) {
  TrainingSessionStatus[(TrainingSessionStatus["None"] = 0)] = "None"
  TrainingSessionStatus[(TrainingSessionStatus["NotStarted"] = 1)] =
    "NotStarted"
  TrainingSessionStatus[(TrainingSessionStatus["Started"] = 2)] = "Started"
  TrainingSessionStatus[(TrainingSessionStatus["Complete"] = 3)] = "Complete"
})(TrainingSessionStatus || (TrainingSessionStatus = {}))
/** 0 = None 1 = Vimeo 2 = Youtube 3 = Azure 4 = Wistia */
export var VideoType
;(function (VideoType) {
  VideoType[(VideoType["None"] = 0)] = "None"
  VideoType[(VideoType["Vimeo"] = 1)] = "Vimeo"
  VideoType[(VideoType["Youtube"] = 2)] = "Youtube"
  VideoType[(VideoType["Azure"] = 3)] = "Azure"
  VideoType[(VideoType["Wistia"] = 4)] = "Wistia"
})(VideoType || (VideoType = {}))
/** 0 = Password 1 = OneTimePasscode */
export var AuthenticationMethod
;(function (AuthenticationMethod) {
  AuthenticationMethod[(AuthenticationMethod["Password"] = 0)] = "Password"
  AuthenticationMethod[(AuthenticationMethod["OneTimePasscode"] = 1)] =
    "OneTimePasscode"
})(AuthenticationMethod || (AuthenticationMethod = {}))
/** 0 = None 1 = Sms 2 = Email */
export var TwoFactorAuthenticationType
;(function (TwoFactorAuthenticationType) {
  TwoFactorAuthenticationType[(TwoFactorAuthenticationType["None"] = 0)] =
    "None"
  TwoFactorAuthenticationType[(TwoFactorAuthenticationType["Sms"] = 1)] = "Sms"
  TwoFactorAuthenticationType[(TwoFactorAuthenticationType["Email"] = 2)] =
    "Email"
})(TwoFactorAuthenticationType || (TwoFactorAuthenticationType = {}))
export var UserActivityType
;(function (UserActivityType) {
  UserActivityType["Unknown"] = "Unknown"
  UserActivityType["Joined"] = "Joined"
  UserActivityType["Left"] = "Left"
  UserActivityType["Banned"] = "Banned"
  UserActivityType["RolesAdded"] = "RolesAdded"
  UserActivityType["RolesRemoved"] = "RolesRemoved"
  UserActivityType["ModuleAttempt"] = "ModuleAttempt"
  UserActivityType["SurveyResponse"] = "SurveyResponse"
})(UserActivityType || (UserActivityType = {}))
export class ApiException extends Error {
  constructor(message, status, response, headers, result) {
    super()
    this.isApiException = true
    this.message = message
    this.status = status
    this.response = response
    this.headers = headers
    this.result = result
  }
  static isApiException(obj) {
    return obj.isApiException === true
  }
}
function throwException(message, status, response, headers, result) {
  if (result !== null && result !== undefined) throw result
  else throw new ApiException(message, status, response, headers, null)
}
function isAxiosError(obj) {
  return obj && obj.isAxiosError === true
}
