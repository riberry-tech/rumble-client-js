/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.8.2.0 (NJsonSchema v10.2.1.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class EmailClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param groupId (optional) 
     * @param statuses (optional) 
     * @param includeContents (optional) 
     */
    getAll(search: string | null | undefined, skip: number | undefined, take: number | undefined, groupId: string | null | undefined, statuses: EmailStatus[] | null | undefined, includeContents: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfEmail> {
        let url_ = this.baseUrl + "/v1/Email?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (groupId !== undefined && groupId !== null)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        if (statuses !== undefined && statuses !== null)
            statuses && statuses.forEach(item => { url_ += "statuses=" + encodeURIComponent("" + item) + "&"; });
        if (includeContents === null)
            throw new Error("The parameter 'includeContents' cannot be null.");
        else if (includeContents !== undefined)
            url_ += "includeContents=" + encodeURIComponent("" + includeContents) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfEmail> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfEmail.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfEmail>(<any>null);
    }

    /**
     * This is a webhook called by SendGrid
     */
    update(  cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Email";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param statuses (optional) 
     * @param includeContents (optional) 
     */
    getAllByUser(userId: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined, statuses: EmailStatus[] | null | undefined, includeContents: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfEmail> {
        let url_ = this.baseUrl + "/v1/Email/User/{userId}?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (statuses !== undefined && statuses !== null)
            statuses && statuses.forEach(item => { url_ += "statuses=" + encodeURIComponent("" + item) + "&"; });
        if (includeContents === null)
            throw new Error("The parameter 'includeContents' cannot be null.");
        else if (includeContents !== undefined)
            url_ += "includeContents=" + encodeURIComponent("" + includeContents) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllByUser(_response);
        });
    }

    protected processGetAllByUser(response: AxiosResponse): Promise<ListOfEmail> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfEmail.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfEmail>(<any>null);
    }

    get(emailId: string | null , cancelToken?: CancelToken | undefined): Promise<Email> {
        let url_ = this.baseUrl + "/v1/Email/{emailId}";
        if (emailId === undefined || emailId === null)
            throw new Error("The parameter 'emailId' must be defined.");
        url_ = url_.replace("{emailId}", encodeURIComponent("" + emailId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Email> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Email.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Email>(<any>null);
    }
}

export class GroupAttendanceClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param status (optional) 
     */
    getAll(groupId: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined, status: AttendanceStatus | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfUserAttendance> {
        let url_ = this.baseUrl + "/v1/Group/{groupId}/Attendance?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (status !== undefined && status !== null)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfUserAttendance> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfUserAttendance.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfUserAttendance>(<any>null);
    }

    get(groupId: string | null, userId: string | null , cancelToken?: CancelToken | undefined): Promise<UserAttendance> {
        let url_ = this.baseUrl + "/v1/Group/{groupId}/Attendance/{userId}";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<UserAttendance> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserAttendance.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserAttendance>(<any>null);
    }

    update(groupId: string | null, userId: string | null, settings: UpdateAttendanceSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Group/{groupId}/Attendance/{userId}";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class MeetingClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param parentId (optional) 
     * @param from (optional) 
     * @param to (optional) 
     */
    getAll(search: string | null | undefined, skip: number | undefined, take: number | undefined, parentId: string | null | undefined, from: Date | null | undefined, to: Date | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfMeeting> {
        let url_ = this.baseUrl + "/v1/Meeting?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (parentId !== undefined && parentId !== null)
            url_ += "parentId=" + encodeURIComponent("" + parentId) + "&";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toJSON() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfMeeting> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfMeeting.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfMeeting>(<any>null);
    }

    create(settings: CreateMeetingSettings , cancelToken?: CancelToken | undefined): Promise<Meeting> {
        let url_ = this.baseUrl + "/v1/Meeting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Meeting> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Meeting.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Meeting>(<any>null);
    }

    get(meetingId: string | null , cancelToken?: CancelToken | undefined): Promise<Meeting> {
        let url_ = this.baseUrl + "/v1/Meeting/{meetingId}";
        if (meetingId === undefined || meetingId === null)
            throw new Error("The parameter 'meetingId' must be defined.");
        url_ = url_.replace("{meetingId}", encodeURIComponent("" + meetingId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Meeting> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Meeting.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Meeting>(<any>null);
    }

    update(meetingId: string | null, settings: UpdateMeetingSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Meeting/{meetingId}";
        if (meetingId === undefined || meetingId === null)
            throw new Error("The parameter 'meetingId' must be defined.");
        url_ = url_.replace("{meetingId}", encodeURIComponent("" + meetingId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(meetingId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Meeting/{meetingId}";
        if (meetingId === undefined || meetingId === null)
            throw new Error("The parameter 'meetingId' must be defined.");
        url_ = url_.replace("{meetingId}", encodeURIComponent("" + meetingId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    getAllFiles(meetingId: string | null , cancelToken?: CancelToken | undefined): Promise<ListOfFile> {
        let url_ = this.baseUrl + "/v1/Meeting/{meetingId}/File";
        if (meetingId === undefined || meetingId === null)
            throw new Error("The parameter 'meetingId' must be defined.");
        url_ = url_.replace("{meetingId}", encodeURIComponent("" + meetingId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllFiles(_response);
        });
    }

    protected processGetAllFiles(response: AxiosResponse): Promise<ListOfFile> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfFile.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfFile>(<any>null);
    }

    createFile(meetingId: string | null, settings: CreateFileSettings , cancelToken?: CancelToken | undefined): Promise<File> {
        let url_ = this.baseUrl + "/v1/Meeting/{meetingId}/File";
        if (meetingId === undefined || meetingId === null)
            throw new Error("The parameter 'meetingId' must be defined.");
        url_ = url_.replace("{meetingId}", encodeURIComponent("" + meetingId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateFile(_response);
        });
    }

    protected processCreateFile(response: AxiosResponse): Promise<File> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = File.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<File>(<any>null);
    }

    getFile(meetingId: string | null, fileId: string | null , cancelToken?: CancelToken | undefined): Promise<File> {
        let url_ = this.baseUrl + "/v1/Meeting/{meetingId}/File/{fileId}";
        if (meetingId === undefined || meetingId === null)
            throw new Error("The parameter 'meetingId' must be defined.");
        url_ = url_.replace("{meetingId}", encodeURIComponent("" + meetingId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetFile(_response);
        });
    }

    protected processGetFile(response: AxiosResponse): Promise<File> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = File.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<File>(<any>null);
    }

    updateFile(meetingId: string | null, fileId: string | null, settings: UpdateFileSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Meeting/{meetingId}/File/{fileId}";
        if (meetingId === undefined || meetingId === null)
            throw new Error("The parameter 'meetingId' must be defined.");
        url_ = url_.replace("{meetingId}", encodeURIComponent("" + meetingId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateFile(_response);
        });
    }

    protected processUpdateFile(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    deleteFile(meetingId: string | null, fileId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Meeting/{meetingId}/File/{fileId}";
        if (meetingId === undefined || meetingId === null)
            throw new Error("The parameter 'meetingId' must be defined.");
        url_ = url_.replace("{meetingId}", encodeURIComponent("" + meetingId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteFile(_response);
        });
    }

    protected processDeleteFile(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    downloadFile(meetingId: string | null, fileId: string | null , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/Meeting/{meetingId}/File/{fileId}/Download";
        if (meetingId === undefined || meetingId === null)
            throw new Error("The parameter 'meetingId' must be defined.");
        url_ = url_.replace("{meetingId}", encodeURIComponent("" + meetingId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadFile(_response);
        });
    }

    protected processDownloadFile(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }
}

export class UserAttendanceClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param status (optional) 
     */
    getAll(userId: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined, status: AttendanceStatus | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfGroupAttendance> {
        let url_ = this.baseUrl + "/v1/User/{userId}/Attendance?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (status !== undefined && status !== null)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfGroupAttendance> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfGroupAttendance.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfGroupAttendance>(<any>null);
    }

    get(userId: string | null, groupId: string | null , cancelToken?: CancelToken | undefined): Promise<GroupAttendance> {
        let url_ = this.baseUrl + "/v1/User/{userId}/Attendance/{groupId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<GroupAttendance> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GroupAttendance.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GroupAttendance>(<any>null);
    }

    update(userId: string | null, groupId: string | null, settings: UpdateAttendanceSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/User/{userId}/Attendance/{groupId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class BackupClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAll(skip: number | undefined, take: number | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfBackup> {
        let url_ = this.baseUrl + "/v1/Backup?";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfBackup> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfBackup.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfBackup>(<any>null);
    }

    create(  cancelToken?: CancelToken | undefined): Promise<Backup> {
        let url_ = this.baseUrl + "/v1/Backup";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Backup> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Backup.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Backup>(<any>null);
    }

    get(id: string | null , cancelToken?: CancelToken | undefined): Promise<Backup> {
        let url_ = this.baseUrl + "/v1/Backup/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Backup> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Backup.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Backup>(<any>null);
    }

    delete(id: string | null, searchDeep: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Backup/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (searchDeep === null)
            throw new Error("The parameter 'searchDeep' cannot be null.");
        else if (searchDeep !== undefined)
            url_ += "searchDeep=" + encodeURIComponent("" + searchDeep) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class ExternalApplicationClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAll(search: string | null | undefined, skip: number | undefined, take: number | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfExternalApplication> {
        let url_ = this.baseUrl + "/v1/ExternalApplication?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfExternalApplication> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfExternalApplication.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfExternalApplication>(<any>null);
    }

    create(settings: CreateExternalApplicationSettings , cancelToken?: CancelToken | undefined): Promise<ExternalApplication> {
        let url_ = this.baseUrl + "/v1/ExternalApplication";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ExternalApplication> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ExternalApplication.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExternalApplication>(<any>null);
    }

    get(applicationId: string | null , cancelToken?: CancelToken | undefined): Promise<ExternalApplication> {
        let url_ = this.baseUrl + "/v1/ExternalApplication/{applicationId}";
        if (applicationId === undefined || applicationId === null)
            throw new Error("The parameter 'applicationId' must be defined.");
        url_ = url_.replace("{applicationId}", encodeURIComponent("" + applicationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ExternalApplication> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ExternalApplication.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExternalApplication>(<any>null);
    }

    update(applicationId: string | null, settings: UpdateExternalApplicationSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/ExternalApplication/{applicationId}";
        if (applicationId === undefined || applicationId === null)
            throw new Error("The parameter 'applicationId' must be defined.");
        url_ = url_.replace("{applicationId}", encodeURIComponent("" + applicationId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(applicationId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/ExternalApplication/{applicationId}";
        if (applicationId === undefined || applicationId === null)
            throw new Error("The parameter 'applicationId' must be defined.");
        url_ = url_.replace("{applicationId}", encodeURIComponent("" + applicationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class ImageClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Resizes the given image to the specified size.
     * @param uri (optional) Uri of the image to resize.
     * @param size (optional) The default width and height of the result image in pixels.
     * @param width (optional) A custom width to override the default size.
     * @param height (optional) A custom height to override the default size.
     * @return Uri of the resized image.
     */
    get(uri: string | null | undefined, size: number | null | undefined, width: number | null | undefined, height: number | null | undefined , cancelToken?: CancelToken | undefined): Promise<ResizedImage> {
        let url_ = this.baseUrl + "/v1/Image?";
        if (uri !== undefined && uri !== null)
            url_ += "uri=" + encodeURIComponent("" + uri) + "&";
        if (size !== undefined && size !== null)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (width !== undefined && width !== null)
            url_ += "width=" + encodeURIComponent("" + width) + "&";
        if (height !== undefined && height !== null)
            url_ += "height=" + encodeURIComponent("" + height) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ResizedImage> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ResizedImage.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResizedImage>(<any>null);
    }
}

export class LogClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param logLevel (optional) 
     */
    getAll(search: string | null | undefined, skip: number | undefined, take: number | undefined, logLevel: number | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfLog> {
        let url_ = this.baseUrl + "/v1/Log?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (logLevel === null)
            throw new Error("The parameter 'logLevel' cannot be null.");
        else if (logLevel !== undefined)
            url_ += "logLevel=" + encodeURIComponent("" + logLevel) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfLog> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfLog.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfLog>(<any>null);
    }

    get(logId: string | null , cancelToken?: CancelToken | undefined): Promise<Log> {
        let url_ = this.baseUrl + "/v1/Log/{logId}";
        if (logId === undefined || logId === null)
            throw new Error("The parameter 'logId' must be defined.");
        url_ = url_.replace("{logId}", encodeURIComponent("" + logId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Log> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Log.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Log>(<any>null);
    }
}

export class MarkdownClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    preview(settings: MarkdownPreviewSettings , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/Markdown/Preview";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPreview(_response);
        });
    }

    protected processPreview(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }
}

export class PlatformClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(  cancelToken?: CancelToken | undefined): Promise<Platform> {
        let url_ = this.baseUrl + "/v1/Platform";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Platform> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Platform.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Platform>(<any>null);
    }

    terms(  cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/v1/Platform/Terms";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTerms(_response);
        });
    }

    protected processTerms(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(<any>null);
    }

    defaultSettings(environment: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/v1/Platform/DefaultSettings?";
        if (environment !== undefined && environment !== null)
            url_ += "environment=" + encodeURIComponent("" + environment) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDefaultSettings(_response);
        });
    }

    protected processDefaultSettings(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(<any>null);
    }

    status(  cancelToken?: CancelToken | undefined): Promise<PlatformStatus> {
        let url_ = this.baseUrl + "/v1/Platform/Status";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStatus(_response);
        });
    }

    protected processStatus(response: AxiosResponse): Promise<PlatformStatus> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PlatformStatus.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlatformStatus>(<any>null);
    }
}

export class ProjectionClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAll(  cancelToken?: CancelToken | undefined): Promise<ListOfProjectionBuild> {
        let url_ = this.baseUrl + "/v1/Projection";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfProjectionBuild> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfProjectionBuild.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfProjectionBuild>(<any>null);
    }

    get(projectionName: string | null , cancelToken?: CancelToken | undefined): Promise<ProjectionBuild> {
        let url_ = this.baseUrl + "/v1/Projection/{projectionName}";
        if (projectionName === undefined || projectionName === null)
            throw new Error("The parameter 'projectionName' must be defined.");
        url_ = url_.replace("{projectionName}", encodeURIComponent("" + projectionName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ProjectionBuild> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProjectionBuild.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProjectionBuild>(<any>null);
    }
}

export class NotificationClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param type (optional) 
     * @param seen (optional) 
     * @param read (optional) 
     * @param from (optional) 
     * @param to (optional) 
     */
    getAll(skip: number | undefined, take: number | undefined, type: string | null | undefined, seen: boolean | null | undefined, read: boolean | null | undefined, from: Date | null | undefined, to: Date | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfNotification> {
        let url_ = this.baseUrl + "/v1/Notification?";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (seen !== undefined && seen !== null)
            url_ += "seen=" + encodeURIComponent("" + seen) + "&";
        if (read !== undefined && read !== null)
            url_ += "read=" + encodeURIComponent("" + read) + "&";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toJSON() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfNotification> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfNotification.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfNotification>(<any>null);
    }

    get(notificationId: string | null , cancelToken?: CancelToken | undefined): Promise<Notification> {
        let url_ = this.baseUrl + "/v1/Notification/{notificationId}";
        if (notificationId === undefined || notificationId === null)
            throw new Error("The parameter 'notificationId' must be defined.");
        url_ = url_.replace("{notificationId}", encodeURIComponent("" + notificationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Notification> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Notification.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Notification>(<any>null);
    }

    update(notificationId: string | null, settings: UpdateNotificationSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Notification/{notificationId}";
        if (notificationId === undefined || notificationId === null)
            throw new Error("The parameter 'notificationId' must be defined.");
        url_ = url_.replace("{notificationId}", encodeURIComponent("" + notificationId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(notificationId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Notification/{notificationId}";
        if (notificationId === undefined || notificationId === null)
            throw new Error("The parameter 'notificationId' must be defined.");
        url_ = url_.replace("{notificationId}", encodeURIComponent("" + notificationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    markAllAsSeen(  cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Notification/MarkAllAsSeen";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMarkAllAsSeen(_response);
        });
    }

    protected processMarkAllAsSeen(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    markAllAsRead(  cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Notification/MarkAllAsRead";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMarkAllAsRead(_response);
        });
    }

    protected processMarkAllAsRead(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class ScheduledEmailClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param groupId (optional) 
     */
    getAll(skip: number | undefined, take: number | undefined, groupId: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfScheduledEmail> {
        let url_ = this.baseUrl + "/v1/ScheduledEmail?";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (groupId !== undefined && groupId !== null)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfScheduledEmail> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfScheduledEmail.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfScheduledEmail>(<any>null);
    }

    /**
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAllForRecipient(recipientId: string | null, skip: number | undefined, take: number | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfScheduledEmail> {
        let url_ = this.baseUrl + "/v1/ScheduledEmail/Recipient/{recipientId}?";
        if (recipientId === undefined || recipientId === null)
            throw new Error("The parameter 'recipientId' must be defined.");
        url_ = url_.replace("{recipientId}", encodeURIComponent("" + recipientId));
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForRecipient(_response);
        });
    }

    protected processGetAllForRecipient(response: AxiosResponse): Promise<ListOfScheduledEmail> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfScheduledEmail.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfScheduledEmail>(<any>null);
    }

    get(scheduleId: string | null , cancelToken?: CancelToken | undefined): Promise<ScheduledEmail> {
        let url_ = this.baseUrl + "/v1/ScheduledEmail/{scheduleId}";
        if (scheduleId === undefined || scheduleId === null)
            throw new Error("The parameter 'scheduleId' must be defined.");
        url_ = url_.replace("{scheduleId}", encodeURIComponent("" + scheduleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ScheduledEmail> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ScheduledEmail.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ScheduledEmail>(<any>null);
    }

    create(settings: CreateScheduledEmailSettings , cancelToken?: CancelToken | undefined): Promise<ScheduledEmail> {
        let url_ = this.baseUrl + "/v1/ScheduledEmail/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ScheduledEmail> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ScheduledEmail.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ScheduledEmail>(<any>null);
    }

    update(scheduleId: string | null, settings: UpdateScheduledEmailSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/ScheduledEmail/{scheduleId}/Update";
        if (scheduleId === undefined || scheduleId === null)
            throw new Error("The parameter 'scheduleId' must be defined.");
        url_ = url_.replace("{scheduleId}", encodeURIComponent("" + scheduleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(scheduleId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/ScheduledEmail/{scheduleId}/Delete";
        if (scheduleId === undefined || scheduleId === null)
            throw new Error("The parameter 'scheduleId' must be defined.");
        url_ = url_.replace("{scheduleId}", encodeURIComponent("" + scheduleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    leave(scheduleId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/ScheduledEmail/{scheduleId}/Leave";
        if (scheduleId === undefined || scheduleId === null)
            throw new Error("The parameter 'scheduleId' must be defined.");
        url_ = url_.replace("{scheduleId}", encodeURIComponent("" + scheduleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLeave(_response);
        });
    }

    protected processLeave(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class ObservationContentClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param published (optional) 
     */
    getAll(definitionId: string | null, skip: number | undefined, take: number | undefined, published: boolean | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfObservationContent> {
        let url_ = this.baseUrl + "/v1/ObservationDefinition/{definitionId}/Content?";
        if (definitionId === undefined || definitionId === null)
            throw new Error("The parameter 'definitionId' must be defined.");
        url_ = url_.replace("{definitionId}", encodeURIComponent("" + definitionId));
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (published !== undefined && published !== null)
            url_ += "published=" + encodeURIComponent("" + published) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfObservationContent> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfObservationContent.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfObservationContent>(<any>null);
    }

    get(contentId: string | null , cancelToken?: CancelToken | undefined): Promise<ObservationContent> {
        let url_ = this.baseUrl + "/v1/ObservationContent/{contentId}";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ObservationContent> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ObservationContent.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ObservationContent>(<any>null);
    }

    update(contentId: string | null, settings: UpdateObservationContentSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/ObservationContent/{contentId}";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(contentId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/ObservationContent/{contentId}";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    create(settings: CreateObservationContentSettings , cancelToken?: CancelToken | undefined): Promise<ObservationContent> {
        let url_ = this.baseUrl + "/v1/ObservationContent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ObservationContent> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ObservationContent.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ObservationContent>(<any>null);
    }

    publish(contentId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/ObservationContent/{contentId}/Publish";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPublish(_response);
        });
    }

    protected processPublish(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class ObservationClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAllForArea(options: ObservationAreaOptions , cancelToken?: CancelToken | undefined): Promise<ListOfLocatableObservation> {
        let url_ = this.baseUrl + "/v1/Observation/GetAllForArea";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(options);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForArea(_response);
        });
    }

    protected processGetAllForArea(response: AxiosResponse): Promise<ListOfLocatableObservation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfLocatableObservation.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfLocatableObservation>(<any>null);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param definitionId (optional) 
     * @param from (optional) 
     * @param to (optional) 
     * @param labelled (optional) 
     * @param anonymousUser (optional) 
     */
    getAllForGroup(groupId: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined, definitionId: string | null | undefined, from: Date | null | undefined, to: Date | null | undefined, labelled: boolean | null | undefined, anonymousUser: boolean | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfObservation> {
        let url_ = this.baseUrl + "/v1/Observation/Group/{groupId}?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (definitionId !== undefined && definitionId !== null)
            url_ += "definitionId=" + encodeURIComponent("" + definitionId) + "&";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toJSON() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toJSON() : "") + "&";
        if (labelled !== undefined && labelled !== null)
            url_ += "labelled=" + encodeURIComponent("" + labelled) + "&";
        if (anonymousUser !== undefined && anonymousUser !== null)
            url_ += "anonymousUser=" + encodeURIComponent("" + anonymousUser) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForGroup(_response);
        });
    }

    protected processGetAllForGroup(response: AxiosResponse): Promise<ListOfObservation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfObservation.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfObservation>(<any>null);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param definitionId (optional) 
     * @param contentId (optional) 
     * @param groupId (optional) 
     * @param from (optional) 
     * @param to (optional) 
     * @param labelled (optional) 
     */
    getAllForPublisher(publisherId: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined, definitionId: string | null | undefined, contentId: string | null | undefined, groupId: string | null | undefined, from: Date | null | undefined, to: Date | null | undefined, labelled: boolean | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfObservation> {
        let url_ = this.baseUrl + "/v1/Observation/Publisher/{publisherId}?";
        if (publisherId === undefined || publisherId === null)
            throw new Error("The parameter 'publisherId' must be defined.");
        url_ = url_.replace("{publisherId}", encodeURIComponent("" + publisherId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (definitionId !== undefined && definitionId !== null)
            url_ += "definitionId=" + encodeURIComponent("" + definitionId) + "&";
        if (contentId !== undefined && contentId !== null)
            url_ += "contentId=" + encodeURIComponent("" + contentId) + "&";
        if (groupId !== undefined && groupId !== null)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toJSON() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toJSON() : "") + "&";
        if (labelled !== undefined && labelled !== null)
            url_ += "labelled=" + encodeURIComponent("" + labelled) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForPublisher(_response);
        });
    }

    protected processGetAllForPublisher(response: AxiosResponse): Promise<ListOfObservation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfObservation.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfObservation>(<any>null);
    }

    get(observationId: string | null, labelled: boolean | null | undefined , cancelToken?: CancelToken | undefined): Promise<Observation> {
        let url_ = this.baseUrl + "/v1/Observation/{observationId}?";
        if (observationId === undefined || observationId === null)
            throw new Error("The parameter 'observationId' must be defined.");
        url_ = url_.replace("{observationId}", encodeURIComponent("" + observationId));
        if (labelled !== undefined && labelled !== null)
            url_ += "labelled=" + encodeURIComponent("" + labelled) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Observation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Observation.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Observation>(<any>null);
    }

    update(observationId: string | null, settings: UpdateObservationSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Observation/{observationId}";
        if (observationId === undefined || observationId === null)
            throw new Error("The parameter 'observationId' must be defined.");
        url_ = url_.replace("{observationId}", encodeURIComponent("" + observationId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(observationId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Observation/{observationId}";
        if (observationId === undefined || observationId === null)
            throw new Error("The parameter 'observationId' must be defined.");
        url_ = url_.replace("{observationId}", encodeURIComponent("" + observationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    create(settings: CreateObservationSettings , cancelToken?: CancelToken | undefined): Promise<Observation> {
        let url_ = this.baseUrl + "/v1/Observation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Observation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Observation.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Observation>(<any>null);
    }

    predict(observationContentId: string | null, settings: PredictObservationSettings , cancelToken?: CancelToken | undefined): Promise<CreateObservationSettings> {
        let url_ = this.baseUrl + "/v1/Observation/{observationContentId}/Predict";
        if (observationContentId === undefined || observationContentId === null)
            throw new Error("The parameter 'observationContentId' must be defined.");
        url_ = url_.replace("{observationContentId}", encodeURIComponent("" + observationContentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPredict(_response);
        });
    }

    protected processPredict(response: AxiosResponse): Promise<CreateObservationSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CreateObservationSettings.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateObservationSettings>(<any>null);
    }

    downloadFile(observationId: string | null, fileId: string | null , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/Observation/{observationId}/File/{fileId}";
        if (observationId === undefined || observationId === null)
            throw new Error("The parameter 'observationId' must be defined.");
        url_ = url_.replace("{observationId}", encodeURIComponent("" + observationId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadFile(_response);
        });
    }

    protected processDownloadFile(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    extractLabelledAnswers(settings: ExtractLabelledAnswersSettings , cancelToken?: CancelToken | undefined): Promise<LabelledAnswer[]> {
        let url_ = this.baseUrl + "/v1/Observation/ExtractLabelledAnswers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExtractLabelledAnswers(_response);
        });
    }

    protected processExtractLabelledAnswers(response: AxiosResponse): Promise<LabelledAnswer[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LabelledAnswer.fromJS(item));
            }
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LabelledAnswer[]>(<any>null);
    }
}

export class ObservationDefinitionClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param programId (optional) - null/empty to show all
    - program ID to filter to specific program
    - "none" to filter to items not in any program
     */
    getAllForPublisher(publisherId: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined, programId: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfObservationDefinition> {
        let url_ = this.baseUrl + "/v1/ObservationDefinition/Publisher/{publisherId}?";
        if (publisherId === undefined || publisherId === null)
            throw new Error("The parameter 'publisherId' must be defined.");
        url_ = url_.replace("{publisherId}", encodeURIComponent("" + publisherId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (programId !== undefined && programId !== null)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForPublisher(_response);
        });
    }

    protected processGetAllForPublisher(response: AxiosResponse): Promise<ListOfObservationDefinition> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfObservationDefinition.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfObservationDefinition>(<any>null);
    }

    create(settings: CreateObservationDefinitionSettings , cancelToken?: CancelToken | undefined): Promise<ObservationDefinition> {
        let url_ = this.baseUrl + "/v1/ObservationDefinition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ObservationDefinition> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ObservationDefinition.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ObservationDefinition>(<any>null);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param consumerId (optional) 
     * @param publisherId (optional) 
     * @param programId (optional) - null/empty to show all
    - program ID to filter to specific program
    - "none" to filter to items not in any program
     * @param itemId (optional) 
     * @param activated (optional) 
     */
    getAllByActivation(search: string | null | undefined, skip: number | undefined, take: number | undefined, consumerId: string | null | undefined, publisherId: string | null | undefined, programId: string | null | undefined, itemId: string | null | undefined, activated: boolean | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfObservationDefinition> {
        let url_ = this.baseUrl + "/v1/ObservationDefinition?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (consumerId !== undefined && consumerId !== null)
            url_ += "consumerId=" + encodeURIComponent("" + consumerId) + "&";
        if (publisherId !== undefined && publisherId !== null)
            url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&";
        if (programId !== undefined && programId !== null)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        if (itemId !== undefined && itemId !== null)
            url_ += "itemId=" + encodeURIComponent("" + itemId) + "&";
        if (activated !== undefined && activated !== null)
            url_ += "activated=" + encodeURIComponent("" + activated) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllByActivation(_response);
        });
    }

    protected processGetAllByActivation(response: AxiosResponse): Promise<ListOfObservationDefinition> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfObservationDefinition.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfObservationDefinition>(<any>null);
    }

    update(observationDefinitionId: string | null, settings: UpdateObservationDefinitionSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/ObservationDefinition/{observationDefinitionId}";
        if (observationDefinitionId === undefined || observationDefinitionId === null)
            throw new Error("The parameter 'observationDefinitionId' must be defined.");
        url_ = url_.replace("{observationDefinitionId}", encodeURIComponent("" + observationDefinitionId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(observationDefinitionId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/ObservationDefinition/{observationDefinitionId}";
        if (observationDefinitionId === undefined || observationDefinitionId === null)
            throw new Error("The parameter 'observationDefinitionId' must be defined.");
        url_ = url_.replace("{observationDefinitionId}", encodeURIComponent("" + observationDefinitionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param publisherId (optional) 
     * @param programId (optional) - null/empty to show all
    - program ID to filter to specific program
    - "none" to filter to items not in any program
     * @param countryCode (optional) 
     */
    getAllPublished(search: string | null | undefined, skip: number | undefined, take: number | undefined, publisherId: string | null | undefined, programId: string | null | undefined, countryCode: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfObservationDefinition> {
        let url_ = this.baseUrl + "/v1/ObservationDefinition/Published?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (publisherId !== undefined && publisherId !== null)
            url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&";
        if (programId !== undefined && programId !== null)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        if (countryCode !== undefined && countryCode !== null)
            url_ += "countryCode=" + encodeURIComponent("" + countryCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllPublished(_response);
        });
    }

    protected processGetAllPublished(response: AxiosResponse): Promise<ListOfObservationDefinition> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfObservationDefinition.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfObservationDefinition>(<any>null);
    }

    get(id: string | null , cancelToken?: CancelToken | undefined): Promise<ObservationDefinition> {
        let url_ = this.baseUrl + "/v1/ObservationDefinition/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ObservationDefinition> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ObservationDefinition.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ObservationDefinition>(<any>null);
    }
}

export class ObservationFormClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAllForObservationContent(contentId: string | null, skip: number | undefined, take: number | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfObservationForm> {
        let url_ = this.baseUrl + "/v1/ObservationContent/{contentId}/Form?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForObservationContent(_response);
        });
    }

    protected processGetAllForObservationContent(response: AxiosResponse): Promise<ListOfObservationForm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfObservationForm.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfObservationForm>(<any>null);
    }

    get(observationFormId: string | null , cancelToken?: CancelToken | undefined): Promise<ObservationForm> {
        let url_ = this.baseUrl + "/v1/ObservationForm/{observationFormId}";
        if (observationFormId === undefined || observationFormId === null)
            throw new Error("The parameter 'observationFormId' must be defined.");
        url_ = url_.replace("{observationFormId}", encodeURIComponent("" + observationFormId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ObservationForm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ObservationForm.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ObservationForm>(<any>null);
    }

    update(observationFormId: string | null, settings: UpdateObservationFormSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/ObservationForm/{observationFormId}";
        if (observationFormId === undefined || observationFormId === null)
            throw new Error("The parameter 'observationFormId' must be defined.");
        url_ = url_.replace("{observationFormId}", encodeURIComponent("" + observationFormId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(observationFormId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/ObservationForm/{observationFormId}";
        if (observationFormId === undefined || observationFormId === null)
            throw new Error("The parameter 'observationFormId' must be defined.");
        url_ = url_.replace("{observationFormId}", encodeURIComponent("" + observationFormId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    create(settings: CreateObservationFormSettings , cancelToken?: CancelToken | undefined): Promise<ObservationForm> {
        let url_ = this.baseUrl + "/v1/ObservationForm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ObservationForm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ObservationForm.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ObservationForm>(<any>null);
    }
}

export class ObservationMigrationClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Change the ownership (publisher) of an given observation definition, all related data including 
    activations and observation will be transferred to the new publisher as well.
     */
    migrateObservationDefinition(observationDefinitionId: string | null, settings: MigrateObservationDefinitionSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/ObservationDefinition/{observationDefinitionId}/Migrate";
        if (observationDefinitionId === undefined || observationDefinitionId === null)
            throw new Error("The parameter 'observationDefinitionId' must be defined.");
        url_ = url_.replace("{observationDefinitionId}", encodeURIComponent("" + observationDefinitionId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMigrateObservationDefinition(_response);
        });
    }

    protected processMigrateObservationDefinition(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Create a duplicate copy of an observation definition under the same publisher.
                
    NOTE: this might run for a while if there are a lot of observations need to be migrated, when tested
    locally, 2400 observations took about 3 minutes to finish, as such, the command would be timeout but it
    will finish eventually, check the logs for progress.
     */
    duplicateObservationDefinition(observationDefinitionId: string | null, settings: DuplicateObservationDefinitionSettings , cancelToken?: CancelToken | undefined): Promise<ObservationDefinition> {
        let url_ = this.baseUrl + "/v1/ObservationDefinition/{observationDefinitionId}/Duplicate";
        if (observationDefinitionId === undefined || observationDefinitionId === null)
            throw new Error("The parameter 'observationDefinitionId' must be defined.");
        url_ = url_.replace("{observationDefinitionId}", encodeURIComponent("" + observationDefinitionId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDuplicateObservationDefinition(_response);
        });
    }

    protected processDuplicateObservationDefinition(response: AxiosResponse): Promise<ObservationDefinition> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ObservationDefinition.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ObservationDefinition>(<any>null);
    }

    /**
     * @param definitionId (optional) 
     * @param groupId (optional) 
     * @deprecated
     */
    getObservationAnonymousUsers(definitionId: string | null | undefined, groupId: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/v1/Observation/AnonymousUser?";
        if (definitionId !== undefined && definitionId !== null)
            url_ += "definitionId=" + encodeURIComponent("" + definitionId) + "&";
        if (groupId !== undefined && groupId !== null)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetObservationAnonymousUsers(_response);
        });
    }

    protected processGetObservationAnonymousUsers(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(<any>null);
    }

    /**
     * @deprecated
     */
    batchMergeObservationAnonymousUsers(settings: BatchMergeObservationAnonymousUsersSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Observation/AnonymousUser/BatchMerge";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBatchMergeObservationAnonymousUsers(_response);
        });
    }

    protected processBatchMergeObservationAnonymousUsers(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class ObservationSettingsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param definitionId (optional) 
     * @param organisationId (optional) 
     */
    getAll(skip: number | undefined, take: number | undefined, definitionId: string | null | undefined, organisationId: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfObservationSettings> {
        let url_ = this.baseUrl + "/v1/ObservationSettings?";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (definitionId !== undefined && definitionId !== null)
            url_ += "definitionId=" + encodeURIComponent("" + definitionId) + "&";
        if (organisationId !== undefined && organisationId !== null)
            url_ += "organisationId=" + encodeURIComponent("" + organisationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfObservationSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfObservationSettings.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfObservationSettings>(<any>null);
    }

    create(settings: CreateObservationSettingsSettings , cancelToken?: CancelToken | undefined): Promise<ObservationSettings> {
        let url_ = this.baseUrl + "/v1/ObservationSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ObservationSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ObservationSettings.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ObservationSettings>(<any>null);
    }

    get(settingsId: string | null , cancelToken?: CancelToken | undefined): Promise<ObservationSettings> {
        let url_ = this.baseUrl + "/v1/ObservationSettings/{settingsId}";
        if (settingsId === undefined || settingsId === null)
            throw new Error("The parameter 'settingsId' must be defined.");
        url_ = url_.replace("{settingsId}", encodeURIComponent("" + settingsId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ObservationSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ObservationSettings.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ObservationSettings>(<any>null);
    }

    update(settingsId: string | null, settings: UpdateObservationSettingsSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/ObservationSettings/{settingsId}";
        if (settingsId === undefined || settingsId === null)
            throw new Error("The parameter 'settingsId' must be defined.");
        url_ = url_.replace("{settingsId}", encodeURIComponent("" + settingsId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(settingsId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/ObservationSettings/{settingsId}";
        if (settingsId === undefined || settingsId === null)
            throw new Error("The parameter 'settingsId' must be defined.");
        url_ = url_.replace("{settingsId}", encodeURIComponent("" + settingsId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class CustomerClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(customerId: string | null , cancelToken?: CancelToken | undefined): Promise<Customer> {
        let url_ = this.baseUrl + "/v1/Customer/{customerId}";
        if (customerId === undefined || customerId === null)
            throw new Error("The parameter 'customerId' must be defined.");
        url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Customer> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Customer.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Customer>(<any>null);
    }

    getForUser(userId: string | null , cancelToken?: CancelToken | undefined): Promise<Customer> {
        let url_ = this.baseUrl + "/v1/Customer/User/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetForUser(_response);
        });
    }

    protected processGetForUser(response: AxiosResponse): Promise<Customer> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Customer.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Customer>(<any>null);
    }
}

export class MerchantClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(merchantId: string | null , cancelToken?: CancelToken | undefined): Promise<Merchant> {
        let url_ = this.baseUrl + "/v1/Merchant/{merchantId}";
        if (merchantId === undefined || merchantId === null)
            throw new Error("The parameter 'merchantId' must be defined.");
        url_ = url_.replace("{merchantId}", encodeURIComponent("" + merchantId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Merchant> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Merchant.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Merchant>(<any>null);
    }

    getForOrganisation(organisationId: string | null , cancelToken?: CancelToken | undefined): Promise<Merchant> {
        let url_ = this.baseUrl + "/v1/Merchant/Organisation/{organisationId}";
        if (organisationId === undefined || organisationId === null)
            throw new Error("The parameter 'organisationId' must be defined.");
        url_ = url_.replace("{organisationId}", encodeURIComponent("" + organisationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetForOrganisation(_response);
        });
    }

    protected processGetForOrganisation(response: AxiosResponse): Promise<Merchant> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Merchant.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Merchant>(<any>null);
    }

    createUrl(publisherId: string | null | undefined, redirectUrl: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/v1/Merchant/CreateUrl?";
        if (publisherId !== undefined && publisherId !== null)
            url_ += "PublisherId=" + encodeURIComponent("" + publisherId) + "&";
        if (redirectUrl !== undefined && redirectUrl !== null)
            url_ += "RedirectUrl=" + encodeURIComponent("" + redirectUrl) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateUrl(_response);
        });
    }

    protected processCreateUrl(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(<any>null);
    }

    create(scope: string | null | undefined, state: string | null | undefined, code: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/Merchant?";
        if (scope !== undefined && scope !== null)
            url_ += "scope=" + encodeURIComponent("" + scope) + "&";
        if (state !== undefined && state !== null)
            url_ += "state=" + encodeURIComponent("" + state) + "&";
        if (code !== undefined && code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }
}

export class PaymentClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(paymentId: string | null , cancelToken?: CancelToken | undefined): Promise<Payment> {
        let url_ = this.baseUrl + "/v1/Payment/{paymentId}";
        if (paymentId === undefined || paymentId === null)
            throw new Error("The parameter 'paymentId' must be defined.");
        url_ = url_.replace("{paymentId}", encodeURIComponent("" + paymentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Payment> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Payment.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Payment>(<any>null);
    }

    create(settings: CreatePaymentSettings , cancelToken?: CancelToken | undefined): Promise<Payment> {
        let url_ = this.baseUrl + "/v1/Payment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Payment> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Payment.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Payment>(<any>null);
    }
}

export class PaymentSettingsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    publicKey(  cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/v1/PaymentSettings/PublicKey";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPublicKey(_response);
        });
    }

    protected processPublicKey(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(<any>null);
    }

    regions(  cancelToken?: CancelToken | undefined): Promise<Region[]> {
        let url_ = this.baseUrl + "/v1/PaymentSettings/Regions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRegions(_response);
        });
    }

    protected processRegions(response: AxiosResponse): Promise<Region[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Region.fromJS(item));
            }
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Region[]>(<any>null);
    }

    countries(  cancelToken?: CancelToken | undefined): Promise<Country[]> {
        let url_ = this.baseUrl + "/v1/PaymentSettings/Countries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCountries(_response);
        });
    }

    protected processCountries(response: AxiosResponse): Promise<Country[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Country.fromJS(item));
            }
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Country[]>(<any>null);
    }

    currencies(  cancelToken?: CancelToken | undefined): Promise<Currency[]> {
        let url_ = this.baseUrl + "/v1/PaymentSettings/Currencies";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCurrencies(_response);
        });
    }

    protected processCurrencies(response: AxiosResponse): Promise<Currency[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Currency.fromJS(item));
            }
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Currency[]>(<any>null);
    }
}

export class ProductClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param publisherId (optional) 
     * @param countryCode (optional) 
     */
    getAll(search: string | null | undefined, skip: number | undefined, take: number | undefined, publisherId: string | null | undefined, countryCode: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<Product> {
        let url_ = this.baseUrl + "/v1/Product?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (publisherId !== undefined && publisherId !== null)
            url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&";
        if (countryCode !== undefined && countryCode !== null)
            url_ += "countryCode=" + encodeURIComponent("" + countryCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<Product> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Product.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Product>(<any>null);
    }

    create(settings: CreateProductSettings , cancelToken?: CancelToken | undefined): Promise<Product> {
        let url_ = this.baseUrl + "/v1/Product";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Product> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Product.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Product>(<any>null);
    }

    get(productId: string | null , cancelToken?: CancelToken | undefined): Promise<Product> {
        let url_ = this.baseUrl + "/v1/Product/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Product> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Product.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Product>(<any>null);
    }

    update(productId: string | null, settings: UpdateProductSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Product/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(productId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Product/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class PublisherClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAll(search: string | null | undefined, skip: number | undefined, take: number | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfPublisher> {
        let url_ = this.baseUrl + "/v1/Publisher?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfPublisher> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfPublisher.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfPublisher>(<any>null);
    }

    get(publisherId: string | null , cancelToken?: CancelToken | undefined): Promise<Publisher> {
        let url_ = this.baseUrl + "/v1/Publisher/{publisherId}";
        if (publisherId === undefined || publisherId === null)
            throw new Error("The parameter 'publisherId' must be defined.");
        url_ = url_.replace("{publisherId}", encodeURIComponent("" + publisherId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Publisher> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Publisher.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Publisher>(<any>null);
    }

    request(publisherId: string | null, settings: RequestPublisherSettings , cancelToken?: CancelToken | undefined): Promise<Publisher> {
        let url_ = this.baseUrl + "/v1/Publisher/{publisherId}/Request";
        if (publisherId === undefined || publisherId === null)
            throw new Error("The parameter 'publisherId' must be defined.");
        url_ = url_.replace("{publisherId}", encodeURIComponent("" + publisherId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRequest(_response);
        });
    }

    protected processRequest(response: AxiosResponse): Promise<Publisher> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Publisher.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Publisher>(<any>null);
    }

    approve(publisherId: string | null, settings: ApprovePublisherSettings , cancelToken?: CancelToken | undefined): Promise<Publisher> {
        let url_ = this.baseUrl + "/v1/Publisher/{publisherId}/Approve";
        if (publisherId === undefined || publisherId === null)
            throw new Error("The parameter 'publisherId' must be defined.");
        url_ = url_.replace("{publisherId}", encodeURIComponent("" + publisherId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processApprove(_response);
        });
    }

    protected processApprove(response: AxiosResponse): Promise<Publisher> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Publisher.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Publisher>(<any>null);
    }
}

export class StripeClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    event(  cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/Stripe/Event";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEvent(_response);
        });
    }

    protected processEvent(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }
}

export class TaskFileClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAll(taskId: string | null , cancelToken?: CancelToken | undefined): Promise<ListOfFile> {
        let url_ = this.baseUrl + "/v1/Task/{taskId}/File";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfFile> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfFile.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfFile>(<any>null);
    }

    create(taskId: string | null, settings: CreateFileSettings , cancelToken?: CancelToken | undefined): Promise<File> {
        let url_ = this.baseUrl + "/v1/Task/{taskId}/File";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<File> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = File.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<File>(<any>null);
    }

    get(taskId: string | null, fileId: string | null , cancelToken?: CancelToken | undefined): Promise<File> {
        let url_ = this.baseUrl + "/v1/Task/{taskId}/File/{fileId}";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<File> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = File.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<File>(<any>null);
    }

    update(taskId: string | null, fileId: string | null, settings: UpdateFileSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Task/{taskId}/File/{fileId}";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(taskId: string | null, fileId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Task/{taskId}/File/{fileId}";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    download(taskId: string | null, fileId: string | null , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/Task/{taskId}/File/{fileId}/Download";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownload(_response);
        });
    }

    protected processDownload(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }
}

export class ImplementationClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param publisherId (optional) 
     * @param consumerId (optional) 
     * @param teamId (optional) 
     */
    getAll(search: string | null | undefined, skip: number | undefined, take: number | undefined, publisherId: string | null | undefined, consumerId: string | null | undefined, teamId: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfImplementation> {
        let url_ = this.baseUrl + "/v1/Implementation?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (publisherId !== undefined && publisherId !== null)
            url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&";
        if (consumerId !== undefined && consumerId !== null)
            url_ += "consumerId=" + encodeURIComponent("" + consumerId) + "&";
        if (teamId !== undefined && teamId !== null)
            url_ += "teamId=" + encodeURIComponent("" + teamId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfImplementation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfImplementation.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfImplementation>(<any>null);
    }

    create(settings: CreateImplementationSettings , cancelToken?: CancelToken | undefined): Promise<Implementation> {
        let url_ = this.baseUrl + "/v1/Implementation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Implementation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Implementation.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Implementation>(<any>null);
    }

    get(implementationId: string | null , cancelToken?: CancelToken | undefined): Promise<Implementation> {
        let url_ = this.baseUrl + "/v1/Implementation/{implementationId}";
        if (implementationId === undefined || implementationId === null)
            throw new Error("The parameter 'implementationId' must be defined.");
        url_ = url_.replace("{implementationId}", encodeURIComponent("" + implementationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Implementation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Implementation.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Implementation>(<any>null);
    }

    update(implementationId: string | null, settings: UpdateImplementationSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Implementation/{implementationId}";
        if (implementationId === undefined || implementationId === null)
            throw new Error("The parameter 'implementationId' must be defined.");
        url_ = url_.replace("{implementationId}", encodeURIComponent("" + implementationId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(implementationId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Implementation/{implementationId}";
        if (implementationId === undefined || implementationId === null)
            throw new Error("The parameter 'implementationId' must be defined.");
        url_ = url_.replace("{implementationId}", encodeURIComponent("" + implementationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAllTasks(implementationId: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfTask> {
        let url_ = this.baseUrl + "/v1/Implementation/{implementationId}/Task?";
        if (implementationId === undefined || implementationId === null)
            throw new Error("The parameter 'implementationId' must be defined.");
        url_ = url_.replace("{implementationId}", encodeURIComponent("" + implementationId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllTasks(_response);
        });
    }

    protected processGetAllTasks(response: AxiosResponse): Promise<ListOfTask> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfTask.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfTask>(<any>null);
    }
}

export class ItemActivationClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param itemType (optional) 
     * @param programId (optional) - null/empty to show all
    - program ID to filter to specific program
    - "none" to filter to items not in any program
     * @param consumerId (optional) 
     * @param includeDeactivated (optional) 
     */
    getAllForPublisher(publisherId: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined, itemType: string | null | undefined, programId: string | null | undefined, consumerId: string | null | undefined, includeDeactivated: boolean | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfItemActivation> {
        let url_ = this.baseUrl + "/v1/ItemActivation/Publisher/{publisherId}?";
        if (publisherId === undefined || publisherId === null)
            throw new Error("The parameter 'publisherId' must be defined.");
        url_ = url_.replace("{publisherId}", encodeURIComponent("" + publisherId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (itemType !== undefined && itemType !== null)
            url_ += "itemType=" + encodeURIComponent("" + itemType) + "&";
        if (programId !== undefined && programId !== null)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        if (consumerId !== undefined && consumerId !== null)
            url_ += "consumerId=" + encodeURIComponent("" + consumerId) + "&";
        if (includeDeactivated !== undefined && includeDeactivated !== null)
            url_ += "includeDeactivated=" + encodeURIComponent("" + includeDeactivated) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForPublisher(_response);
        });
    }

    protected processGetAllForPublisher(response: AxiosResponse): Promise<ListOfItemActivation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfItemActivation.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfItemActivation>(<any>null);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param consumerId (optional) 
     * @param itemType (optional) 
     * @param itemId (optional) 
     * @param programId (optional) - null/empty to show all
    - program ID to filter to specific program
    - "none" to filter to items not in any program
     * @param publisherId (optional) 
     */
    getAllByActivation(search: string | null | undefined, skip: number | undefined, take: number | undefined, consumerId: string | null | undefined, itemType: string | null | undefined, itemId: string | null | undefined, programId: string | null | undefined, publisherId: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfItemActivation> {
        let url_ = this.baseUrl + "/v1/ItemActivation?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (consumerId !== undefined && consumerId !== null)
            url_ += "consumerId=" + encodeURIComponent("" + consumerId) + "&";
        if (itemType !== undefined && itemType !== null)
            url_ += "itemType=" + encodeURIComponent("" + itemType) + "&";
        if (itemId !== undefined && itemId !== null)
            url_ += "itemId=" + encodeURIComponent("" + itemId) + "&";
        if (programId !== undefined && programId !== null)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        if (publisherId !== undefined && publisherId !== null)
            url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllByActivation(_response);
        });
    }

    protected processGetAllByActivation(response: AxiosResponse): Promise<ListOfItemActivation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfItemActivation.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfItemActivation>(<any>null);
    }

    create(consumerId: string | null | undefined, itemId: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<ItemActivation> {
        let url_ = this.baseUrl + "/v1/ItemActivation?";
        if (consumerId !== undefined && consumerId !== null)
            url_ += "consumerId=" + encodeURIComponent("" + consumerId) + "&";
        if (itemId !== undefined && itemId !== null)
            url_ += "itemId=" + encodeURIComponent("" + itemId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ItemActivation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ItemActivation.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ItemActivation>(<any>null);
    }

    get(itemActivationId: string | null , cancelToken?: CancelToken | undefined): Promise<ItemActivation> {
        let url_ = this.baseUrl + "/v1/ItemActivation/{itemActivationId}";
        if (itemActivationId === undefined || itemActivationId === null)
            throw new Error("The parameter 'itemActivationId' must be defined.");
        url_ = url_.replace("{itemActivationId}", encodeURIComponent("" + itemActivationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ItemActivation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ItemActivation.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ItemActivation>(<any>null);
    }

    update(itemActivationId: string | null, activated: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/ItemActivation/{itemActivationId}?";
        if (itemActivationId === undefined || itemActivationId === null)
            throw new Error("The parameter 'itemActivationId' must be defined.");
        url_ = url_.replace("{itemActivationId}", encodeURIComponent("" + itemActivationId));
        if (activated === null)
            throw new Error("The parameter 'activated' cannot be null.");
        else if (activated !== undefined)
            url_ += "activated=" + encodeURIComponent("" + activated) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "PUT",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    get2(itemId: string | null, consumerId: string | null , cancelToken?: CancelToken | undefined): Promise<ItemActivation> {
        let url_ = this.baseUrl + "/v1/ItemActivation/Item/{itemId}/Consumer/{consumerId}";
        if (itemId === undefined || itemId === null)
            throw new Error("The parameter 'itemId' must be defined.");
        url_ = url_.replace("{itemId}", encodeURIComponent("" + itemId));
        if (consumerId === undefined || consumerId === null)
            throw new Error("The parameter 'consumerId' must be defined.");
        url_ = url_.replace("{consumerId}", encodeURIComponent("" + consumerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet2(_response);
        });
    }

    protected processGet2(response: AxiosResponse): Promise<ItemActivation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ItemActivation.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ItemActivation>(<any>null);
    }
}

export class ProgramActivationClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param programId (optional) 
     * @param consumerId (optional) 
     */
    getAll(search: string | null | undefined, skip: number | undefined, take: number | undefined, programId: string | null | undefined, consumerId: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfProgramActivation> {
        let url_ = this.baseUrl + "/v1/ProgramActivation?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (programId !== undefined && programId !== null)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        if (consumerId !== undefined && consumerId !== null)
            url_ += "consumerId=" + encodeURIComponent("" + consumerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfProgramActivation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfProgramActivation.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfProgramActivation>(<any>null);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param programId (optional) 
     */
    getAllForPublisher(publisherId: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined, programId: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfProgramActivation> {
        let url_ = this.baseUrl + "/v1/ProgramActivation/Publisher/{publisherId}?";
        if (publisherId === undefined || publisherId === null)
            throw new Error("The parameter 'publisherId' must be defined.");
        url_ = url_.replace("{publisherId}", encodeURIComponent("" + publisherId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (programId !== undefined && programId !== null)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForPublisher(_response);
        });
    }

    protected processGetAllForPublisher(response: AxiosResponse): Promise<ListOfProgramActivation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfProgramActivation.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfProgramActivation>(<any>null);
    }

    get(id: string | null , cancelToken?: CancelToken | undefined): Promise<ProgramActivation> {
        let url_ = this.baseUrl + "/v1/ProgramActivation/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ProgramActivation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProgramActivation.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProgramActivation>(<any>null);
    }

    get2(programId: string | null, consumerId: string | null , cancelToken?: CancelToken | undefined): Promise<ProgramActivation> {
        let url_ = this.baseUrl + "/v1/ProgramActivation/Program/{programId}/Consumer/{consumerId}";
        if (programId === undefined || programId === null)
            throw new Error("The parameter 'programId' must be defined.");
        url_ = url_.replace("{programId}", encodeURIComponent("" + programId));
        if (consumerId === undefined || consumerId === null)
            throw new Error("The parameter 'consumerId' must be defined.");
        url_ = url_.replace("{consumerId}", encodeURIComponent("" + consumerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet2(_response);
        });
    }

    protected processGet2(response: AxiosResponse): Promise<ProgramActivation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProgramActivation.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProgramActivation>(<any>null);
    }

    createByPhase(settings: ActivateProgramPhaseSettings , cancelToken?: CancelToken | undefined): Promise<ProgramActivation> {
        let url_ = this.baseUrl + "/v1/ProgramActivation/ProgramPhase";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateByPhase(_response);
        });
    }

    protected processCreateByPhase(response: AxiosResponse): Promise<ProgramActivation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProgramActivation.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProgramActivation>(<any>null);
    }

    setCurrentPhase(programActivationId: string | null, programPhaseId: string | null , cancelToken?: CancelToken | undefined): Promise<ProgramActivation> {
        let url_ = this.baseUrl + "/v1/ProgramActivation/{programActivationId}/ProgramPhase/{programPhaseId}/SetCurrent";
        if (programActivationId === undefined || programActivationId === null)
            throw new Error("The parameter 'programActivationId' must be defined.");
        url_ = url_.replace("{programActivationId}", encodeURIComponent("" + programActivationId));
        if (programPhaseId === undefined || programPhaseId === null)
            throw new Error("The parameter 'programPhaseId' must be defined.");
        url_ = url_.replace("{programPhaseId}", encodeURIComponent("" + programPhaseId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSetCurrentPhase(_response);
        });
    }

    protected processSetCurrentPhase(response: AxiosResponse): Promise<ProgramActivation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProgramActivation.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProgramActivation>(<any>null);
    }

    deactivate(programActivationId: string | null, programPhaseId: string | null , cancelToken?: CancelToken | undefined): Promise<ProgramActivation> {
        let url_ = this.baseUrl + "/v1/ProgramActivation/{programActivationId}/ProgramPhase/{programPhaseId}/Deactivate";
        if (programActivationId === undefined || programActivationId === null)
            throw new Error("The parameter 'programActivationId' must be defined.");
        url_ = url_.replace("{programActivationId}", encodeURIComponent("" + programActivationId));
        if (programPhaseId === undefined || programPhaseId === null)
            throw new Error("The parameter 'programPhaseId' must be defined.");
        url_ = url_.replace("{programPhaseId}", encodeURIComponent("" + programPhaseId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeactivate(_response);
        });
    }

    protected processDeactivate(response: AxiosResponse): Promise<ProgramActivation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProgramActivation.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProgramActivation>(<any>null);
    }
}

export class ProgramClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAllForPublisher(publisherId: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfProgram> {
        let url_ = this.baseUrl + "/v1/Program/Publisher/{publisherId}?";
        if (publisherId === undefined || publisherId === null)
            throw new Error("The parameter 'publisherId' must be defined.");
        url_ = url_.replace("{publisherId}", encodeURIComponent("" + publisherId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForPublisher(_response);
        });
    }

    protected processGetAllForPublisher(response: AxiosResponse): Promise<ListOfProgram> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfProgram.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfProgram>(<any>null);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param publisherId (optional) 
     * @param programId (optional) - null/empty to show all
    - program ID to filter to specific program
     * @param countryCode (optional) 
     */
    getAllPublished(search: string | null | undefined, skip: number | undefined, take: number | undefined, publisherId: string | null | undefined, programId: string | null | undefined, countryCode: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfProgram> {
        let url_ = this.baseUrl + "/v1/Program/Published?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (publisherId !== undefined && publisherId !== null)
            url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&";
        if (programId !== undefined && programId !== null)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        if (countryCode !== undefined && countryCode !== null)
            url_ += "countryCode=" + encodeURIComponent("" + countryCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllPublished(_response);
        });
    }

    protected processGetAllPublished(response: AxiosResponse): Promise<ListOfProgram> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfProgram.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfProgram>(<any>null);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param consumerId (optional) 
     * @param publisherId (optional) 
     * @param itemId (optional) 
     * @param activated (optional) 
     */
    getAllByActivation(search: string | null | undefined, skip: number | undefined, take: number | undefined, consumerId: string | null | undefined, publisherId: string | null | undefined, itemId: string | null | undefined, activated: boolean | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfProgram> {
        let url_ = this.baseUrl + "/v1/Program?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (consumerId !== undefined && consumerId !== null)
            url_ += "consumerId=" + encodeURIComponent("" + consumerId) + "&";
        if (publisherId !== undefined && publisherId !== null)
            url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&";
        if (itemId !== undefined && itemId !== null)
            url_ += "itemId=" + encodeURIComponent("" + itemId) + "&";
        if (activated !== undefined && activated !== null)
            url_ += "activated=" + encodeURIComponent("" + activated) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllByActivation(_response);
        });
    }

    protected processGetAllByActivation(response: AxiosResponse): Promise<ListOfProgram> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfProgram.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfProgram>(<any>null);
    }

    create(settings: CreateProgramSettings , cancelToken?: CancelToken | undefined): Promise<Program> {
        let url_ = this.baseUrl + "/v1/Program";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Program> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Program.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Program>(<any>null);
    }

    get(id: string | null , cancelToken?: CancelToken | undefined): Promise<Program> {
        let url_ = this.baseUrl + "/v1/Program/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Program> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Program.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Program>(<any>null);
    }

    update(programId: string | null, settings: UpdateProgramSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Program/{programId}";
        if (programId === undefined || programId === null)
            throw new Error("The parameter 'programId' must be defined.");
        url_ = url_.replace("{programId}", encodeURIComponent("" + programId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(programId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Program/{programId}";
        if (programId === undefined || programId === null)
            throw new Error("The parameter 'programId' must be defined.");
        url_ = url_.replace("{programId}", encodeURIComponent("" + programId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class ProgramPhaseClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(id: string | null , cancelToken?: CancelToken | undefined): Promise<ProgramPhase> {
        let url_ = this.baseUrl + "/v1/ProgramPhase/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ProgramPhase> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProgramPhase.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProgramPhase>(<any>null);
    }

    create(settings: CreateProgramPhaseSettings , cancelToken?: CancelToken | undefined): Promise<ProgramPhase> {
        let url_ = this.baseUrl + "/v1/ProgramPhase";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ProgramPhase> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProgramPhase.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProgramPhase>(<any>null);
    }

    update(programPhaseId: string | null, settings: UpdateProgramPhaseSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/ProgramPhase/{programPhaseId}";
        if (programPhaseId === undefined || programPhaseId === null)
            throw new Error("The parameter 'programPhaseId' must be defined.");
        url_ = url_.replace("{programPhaseId}", encodeURIComponent("" + programPhaseId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(programPhaseId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/ProgramPhase/{programPhaseId}";
        if (programPhaseId === undefined || programPhaseId === null)
            throw new Error("The parameter 'programPhaseId' must be defined.");
        url_ = url_.replace("{programPhaseId}", encodeURIComponent("" + programPhaseId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class TaskCommentClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAll(taskId: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfComment> {
        let url_ = this.baseUrl + "/v1/Task/{taskId}/Comment?";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfComment> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfComment.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfComment>(<any>null);
    }

    create(taskId: string | null, settings: CreateCommentSettings , cancelToken?: CancelToken | undefined): Promise<Comment> {
        let url_ = this.baseUrl + "/v1/Task/{taskId}/Comment";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Comment> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Comment.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Comment>(<any>null);
    }

    get(taskId: string | null, commentId: string | null , cancelToken?: CancelToken | undefined): Promise<Comment> {
        let url_ = this.baseUrl + "/v1/Task/{taskId}/Comment/{commentId}";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Comment> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Comment.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Comment>(<any>null);
    }

    update(taskId: string | null, commentId: string | null, settings: UpdateCommentSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Task/{taskId}/Comment/{commentId}";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(taskId: string | null, commentId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Task/{taskId}/Comment/{commentId}";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAllReplies(taskId: string | null, commentId: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfComment> {
        let url_ = this.baseUrl + "/v1/Task/{taskId}/Comment/{commentId}/Reply?";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllReplies(_response);
        });
    }

    protected processGetAllReplies(response: AxiosResponse): Promise<ListOfComment> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfComment.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfComment>(<any>null);
    }
}

export class TaskClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param implementationId (optional) 
     */
    getAll(search: string | null | undefined, skip: number | undefined, take: number | undefined, implementationId: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfTask> {
        let url_ = this.baseUrl + "/v1/Task?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (implementationId !== undefined && implementationId !== null)
            url_ += "implementationId=" + encodeURIComponent("" + implementationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfTask> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfTask.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfTask>(<any>null);
    }

    create(settings: CreateTaskSettings , cancelToken?: CancelToken | undefined): Promise<Task> {
        let url_ = this.baseUrl + "/v1/Task";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Task> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Task.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Task>(<any>null);
    }

    get(taskId: string | null , cancelToken?: CancelToken | undefined): Promise<Task> {
        let url_ = this.baseUrl + "/v1/Task/{taskId}";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Task> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Task.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Task>(<any>null);
    }

    update(taskId: string | null, settings: UpdateTaskSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Task/{taskId}";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(taskId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Task/{taskId}";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class SharingClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getByAlias(aliasId: string | null , cancelToken?: CancelToken | undefined): Promise<Sharing> {
        let url_ = this.baseUrl + "/v1/Sharing/Alias/{aliasId}";
        if (aliasId === undefined || aliasId === null)
            throw new Error("The parameter 'aliasId' must be defined.");
        url_ = url_.replace("{aliasId}", encodeURIComponent("" + aliasId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetByAlias(_response);
        });
    }

    protected processGetByAlias(response: AxiosResponse): Promise<Sharing> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Sharing.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Sharing>(<any>null);
    }

    delete(sharingId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Sharing/{sharingId}";
        if (sharingId === undefined || sharingId === null)
            throw new Error("The parameter 'sharingId' must be defined.");
        url_ = url_.replace("{sharingId}", encodeURIComponent("" + sharingId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAllGroupInvitationsForGroup(groupId: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfSharing> {
        let url_ = this.baseUrl + "/v1/Sharing/GroupInvitation/Group/{groupId}?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllGroupInvitationsForGroup(_response);
        });
    }

    protected processGetAllGroupInvitationsForGroup(response: AxiosResponse): Promise<ListOfSharing> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfSharing.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfSharing>(<any>null);
    }

    createForGroupInvitation(settings: CreateGroupInvitationSharingSettings , cancelToken?: CancelToken | undefined): Promise<Sharing> {
        let url_ = this.baseUrl + "/v1/Sharing/GroupInvitation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateForGroupInvitation(_response);
        });
    }

    protected processCreateForGroupInvitation(response: AxiosResponse): Promise<Sharing> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Sharing.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Sharing>(<any>null);
    }
}

export class TicketClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param userId (optional) 
     */
    getAll(search: string | null | undefined, skip: number | undefined, take: number | undefined, userId: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfTicket> {
        let url_ = this.baseUrl + "/v1/Ticket?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfTicket> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfTicket.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfTicket>(<any>null);
    }

    create(settings: CreateTicketSettings , cancelToken?: CancelToken | undefined): Promise<Ticket> {
        let url_ = this.baseUrl + "/v1/Ticket";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Ticket> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Ticket.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Ticket>(<any>null);
    }

    get(ticketId: string | null , cancelToken?: CancelToken | undefined): Promise<Ticket> {
        let url_ = this.baseUrl + "/v1/Ticket/{ticketId}";
        if (ticketId === undefined || ticketId === null)
            throw new Error("The parameter 'ticketId' must be defined.");
        url_ = url_.replace("{ticketId}", encodeURIComponent("" + ticketId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Ticket> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Ticket.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Ticket>(<any>null);
    }

    update(ticketId: string | null, settings: UpdateTicketSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Ticket/{ticketId}";
        if (ticketId === undefined || ticketId === null)
            throw new Error("The parameter 'ticketId' must be defined.");
        url_ = url_.replace("{ticketId}", encodeURIComponent("" + ticketId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class SurveyContentClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAll(surveyId: string | null, skip: number | undefined, take: number | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfSurveyContent> {
        let url_ = this.baseUrl + "/v1/Survey/{surveyId}/Content?";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfSurveyContent> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfSurveyContent.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfSurveyContent>(<any>null);
    }

    create(surveyId: string | null, settings: CreateSurveyContentSettings , cancelToken?: CancelToken | undefined): Promise<SurveyContent> {
        let url_ = this.baseUrl + "/v1/Survey/{surveyId}/Content";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<SurveyContent> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SurveyContent.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SurveyContent>(<any>null);
    }

    get(surveyId: string | null, contentId: string | null , cancelToken?: CancelToken | undefined): Promise<SurveyContent> {
        let url_ = this.baseUrl + "/v1/Survey/{surveyId}/Content/{contentId}";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<SurveyContent> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SurveyContent.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SurveyContent>(<any>null);
    }

    update(surveyId: string | null, contentId: string | null, settings: UpdateSurveyContentSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Survey/{surveyId}/Content/{contentId}";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(surveyId: string | null, contentId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Survey/{surveyId}/Content/{contentId}";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    publish(surveyId: string | null | undefined, contentId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/{contentId}/Publish?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        if (surveyId !== undefined && surveyId !== null)
            url_ += "surveyId=" + encodeURIComponent("" + surveyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "PUT",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPublish(_response);
        });
    }

    protected processPublish(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    questionTypes(  cancelToken?: CancelToken | undefined): Promise<SurveyQuestionTypes> {
        let url_ = this.baseUrl + "/v1/SurveyContent/QuestionTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processQuestionTypes(_response);
        });
    }

    protected processQuestionTypes(response: AxiosResponse): Promise<SurveyQuestionTypes> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SurveyQuestionTypes.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SurveyQuestionTypes>(<any>null);
    }

    answerTypes(  cancelToken?: CancelToken | undefined): Promise<SurveyAnswerTypes> {
        let url_ = this.baseUrl + "/v1/SurveyContent/AnswerTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAnswerTypes(_response);
        });
    }

    protected processAnswerTypes(response: AxiosResponse): Promise<SurveyAnswerTypes> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SurveyAnswerTypes.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SurveyAnswerTypes>(<any>null);
    }

    example(  cancelToken?: CancelToken | undefined): Promise<SurveySettings> {
        let url_ = this.baseUrl + "/v1/SurveyContent/Example";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExample(_response);
        });
    }

    protected processExample(response: AxiosResponse): Promise<SurveySettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SurveySettings.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SurveySettings>(<any>null);
    }

    schema(  cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/SurveyContent/Schema";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSchema(_response);
        });
    }

    protected processSchema(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }
}

export class SurveyClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAllForPublisher(publisherId: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfSurvey> {
        let url_ = this.baseUrl + "/v1/Survey/Publisher/{publisherId}?";
        if (publisherId === undefined || publisherId === null)
            throw new Error("The parameter 'publisherId' must be defined.");
        url_ = url_.replace("{publisherId}", encodeURIComponent("" + publisherId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForPublisher(_response);
        });
    }

    protected processGetAllForPublisher(response: AxiosResponse): Promise<ListOfSurvey> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfSurvey.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfSurvey>(<any>null);
    }

    create(settings: CreateSurveySettings , cancelToken?: CancelToken | undefined): Promise<Survey> {
        let url_ = this.baseUrl + "/v1/Survey";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Survey> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Survey.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Survey>(<any>null);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param consumerId (optional) 
     * @param publisherId (optional) 
     * @param programId (optional) - null/empty to show all
    - program ID to filter to specific program
    - "none" to filter to items not in any program
     * @param itemId (optional) 
     * @param activated (optional) 
     */
    getAllByActivation(search: string | null | undefined, skip: number | undefined, take: number | undefined, consumerId: string | null | undefined, publisherId: string | null | undefined, programId: string | null | undefined, itemId: string | null | undefined, activated: boolean | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfSurvey> {
        let url_ = this.baseUrl + "/v1/Survey?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (consumerId !== undefined && consumerId !== null)
            url_ += "consumerId=" + encodeURIComponent("" + consumerId) + "&";
        if (publisherId !== undefined && publisherId !== null)
            url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&";
        if (programId !== undefined && programId !== null)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        if (itemId !== undefined && itemId !== null)
            url_ += "itemId=" + encodeURIComponent("" + itemId) + "&";
        if (activated !== undefined && activated !== null)
            url_ += "activated=" + encodeURIComponent("" + activated) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllByActivation(_response);
        });
    }

    protected processGetAllByActivation(response: AxiosResponse): Promise<ListOfSurvey> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfSurvey.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfSurvey>(<any>null);
    }

    get(id: string | null , cancelToken?: CancelToken | undefined): Promise<Survey> {
        let url_ = this.baseUrl + "/v1/Survey/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Survey> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Survey.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Survey>(<any>null);
    }

    update(surveyId: string | null, settings: UpdateSurveySettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Survey/{surveyId}";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(surveyId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Survey/{surveyId}";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param publisherId (optional) 
     * @param programId (optional) - null/empty to show all
    - program ID to filter to specific program
    - "none" to filter to items not in any program
     * @param countryCode (optional) 
     */
    getAllPublished(search: string | null | undefined, skip: number | undefined, take: number | undefined, publisherId: string | null | undefined, programId: string | null | undefined, countryCode: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfSurvey> {
        let url_ = this.baseUrl + "/v1/Survey/Published?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (publisherId !== undefined && publisherId !== null)
            url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&";
        if (programId !== undefined && programId !== null)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        if (countryCode !== undefined && countryCode !== null)
            url_ += "countryCode=" + encodeURIComponent("" + countryCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllPublished(_response);
        });
    }

    protected processGetAllPublished(response: AxiosResponse): Promise<ListOfSurvey> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfSurvey.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfSurvey>(<any>null);
    }
}

export class SurveyRequestClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param surveyId (optional) 
     */
    getAllForGroup(groupId: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined, surveyId: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfSurveyRequest> {
        let url_ = this.baseUrl + "/v1/SurveyRequest/Group/{groupId}?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (surveyId !== undefined && surveyId !== null)
            url_ += "surveyId=" + encodeURIComponent("" + surveyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForGroup(_response);
        });
    }

    protected processGetAllForGroup(response: AxiosResponse): Promise<ListOfSurveyRequest> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfSurveyRequest.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfSurveyRequest>(<any>null);
    }

    get(requestId: string | null , cancelToken?: CancelToken | undefined): Promise<SurveyRequest> {
        let url_ = this.baseUrl + "/v1/SurveyRequest/{requestId}";
        if (requestId === undefined || requestId === null)
            throw new Error("The parameter 'requestId' must be defined.");
        url_ = url_.replace("{requestId}", encodeURIComponent("" + requestId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<SurveyRequest> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SurveyRequest.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SurveyRequest>(<any>null);
    }

    delete(requestId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/SurveyRequest/{requestId}";
        if (requestId === undefined || requestId === null)
            throw new Error("The parameter 'requestId' must be defined.");
        url_ = url_.replace("{requestId}", encodeURIComponent("" + requestId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    getForToken(token: string | null , cancelToken?: CancelToken | undefined): Promise<Token> {
        let url_ = this.baseUrl + "/v1/SurveyRequest/Token/{token}";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetForToken(_response);
        });
    }

    protected processGetForToken(response: AxiosResponse): Promise<Token> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Token.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Token>(<any>null);
    }

    create(settings: CreateSurveyRequestSettings , cancelToken?: CancelToken | undefined): Promise<SurveyRequest> {
        let url_ = this.baseUrl + "/v1/SurveyRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<SurveyRequest> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SurveyRequest.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SurveyRequest>(<any>null);
    }
}

export class SurveyResponseClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param groupId (optional) 
     * @param publisherId (optional) 
     * @param contentId (optional) 
     * @param jobTypeId (optional) 
     * @param submitted (optional) 
     */
    getAllForSurvey(surveyId: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined, groupId: string | null | undefined, publisherId: string | null | undefined, contentId: string | null | undefined, jobTypeId: string | null | undefined, submitted: boolean | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfSurveyResponse> {
        let url_ = this.baseUrl + "/v1/SurveyResponse/Survey/{surveyId}?";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (groupId !== undefined && groupId !== null)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        if (publisherId !== undefined && publisherId !== null)
            url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&";
        if (contentId !== undefined && contentId !== null)
            url_ += "contentId=" + encodeURIComponent("" + contentId) + "&";
        if (jobTypeId !== undefined && jobTypeId !== null)
            url_ += "jobTypeId=" + encodeURIComponent("" + jobTypeId) + "&";
        if (submitted !== undefined && submitted !== null)
            url_ += "submitted=" + encodeURIComponent("" + submitted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForSurvey(_response);
        });
    }

    protected processGetAllForSurvey(response: AxiosResponse): Promise<ListOfSurveyResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfSurveyResponse.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfSurveyResponse>(<any>null);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param surveyId (optional) 
     * @param submitted (optional) 
     */
    getAllForRespondent(respondentId: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined, surveyId: string | null | undefined, submitted: boolean | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfSurveyResponse> {
        let url_ = this.baseUrl + "/v1/SurveyResponse/Respondent/{respondentId}?";
        if (respondentId === undefined || respondentId === null)
            throw new Error("The parameter 'respondentId' must be defined.");
        url_ = url_.replace("{respondentId}", encodeURIComponent("" + respondentId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (surveyId !== undefined && surveyId !== null)
            url_ += "surveyId=" + encodeURIComponent("" + surveyId) + "&";
        if (submitted !== undefined && submitted !== null)
            url_ += "submitted=" + encodeURIComponent("" + submitted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForRespondent(_response);
        });
    }

    protected processGetAllForRespondent(response: AxiosResponse): Promise<ListOfSurveyResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfSurveyResponse.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfSurveyResponse>(<any>null);
    }

    get(responseId: string | null , cancelToken?: CancelToken | undefined): Promise<SurveyResponse> {
        let url_ = this.baseUrl + "/v1/SurveyResponse/{responseId}";
        if (responseId === undefined || responseId === null)
            throw new Error("The parameter 'responseId' must be defined.");
        url_ = url_.replace("{responseId}", encodeURIComponent("" + responseId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<SurveyResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SurveyResponse.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SurveyResponse>(<any>null);
    }

    update(responseId: string | null, settings: UpdateSurveyResponseSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/SurveyResponse/{responseId}";
        if (responseId === undefined || responseId === null)
            throw new Error("The parameter 'responseId' must be defined.");
        url_ = url_.replace("{responseId}", encodeURIComponent("" + responseId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(surveyId: string | null | undefined, responseId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/SurveyResponse/{responseId}?";
        if (responseId === undefined || responseId === null)
            throw new Error("The parameter 'responseId' must be defined.");
        url_ = url_.replace("{responseId}", encodeURIComponent("" + responseId));
        if (surveyId !== undefined && surveyId !== null)
            url_ += "surveyId=" + encodeURIComponent("" + surveyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    create(settings: CreateSurveyResponseSettings , cancelToken?: CancelToken | undefined): Promise<SurveyResponse> {
        let url_ = this.baseUrl + "/v1/SurveyResponse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<SurveyResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SurveyResponse.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SurveyResponse>(<any>null);
    }
}

export class ActorClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(actorId: string | null , cancelToken?: CancelToken | undefined): Promise<Actor> {
        let url_ = this.baseUrl + "/v1/Actor/{actorId}";
        if (actorId === undefined || actorId === null)
            throw new Error("The parameter 'actorId' must be defined.");
        url_ = url_.replace("{actorId}", encodeURIComponent("" + actorId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Actor> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Actor.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Actor>(<any>null);
    }
}

export class BookAttemptClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param moduleId (optional) 
     */
    getAllForActor(actorId: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined, moduleId: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfModuleAttemptOfBookResult> {
        let url_ = this.baseUrl + "/v1/BookAttempt/Actor/{actorId}?";
        if (actorId === undefined || actorId === null)
            throw new Error("The parameter 'actorId' must be defined.");
        url_ = url_.replace("{actorId}", encodeURIComponent("" + actorId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (moduleId !== undefined && moduleId !== null)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForActor(_response);
        });
    }

    protected processGetAllForActor(response: AxiosResponse): Promise<ListOfModuleAttemptOfBookResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfModuleAttemptOfBookResult.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfModuleAttemptOfBookResult>(<any>null);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param moduleId (optional) 
     * @param actorType (optional) 
     * @param from (optional) 
     * @param to (optional) 
     */
    getAllForGroup(groupId: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined, moduleId: string | null | undefined, actorType: ActorType | null | undefined, from: Date | null | undefined, to: Date | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfModuleAttemptOfBookResult> {
        let url_ = this.baseUrl + "/v1/BookAttempt/Group/{groupId}?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (moduleId !== undefined && moduleId !== null)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&";
        if (actorType !== undefined && actorType !== null)
            url_ += "actorType=" + encodeURIComponent("" + actorType) + "&";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toJSON() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForGroup(_response);
        });
    }

    protected processGetAllForGroup(response: AxiosResponse): Promise<ListOfModuleAttemptOfBookResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfModuleAttemptOfBookResult.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfModuleAttemptOfBookResult>(<any>null);
    }

    get(moduleAttemptId: string | null , cancelToken?: CancelToken | undefined): Promise<ModuleAttemptOfBookResult> {
        let url_ = this.baseUrl + "/v1/BookAttempt/{moduleAttemptId}";
        if (moduleAttemptId === undefined || moduleAttemptId === null)
            throw new Error("The parameter 'moduleAttemptId' must be defined.");
        url_ = url_.replace("{moduleAttemptId}", encodeURIComponent("" + moduleAttemptId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ModuleAttemptOfBookResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleAttemptOfBookResult.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleAttemptOfBookResult>(<any>null);
    }

    update(moduleAttemptId: string | null, settings: UpdateModuleAttemptSettingsOfBookResult , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/BookAttempt/{moduleAttemptId}";
        if (moduleAttemptId === undefined || moduleAttemptId === null)
            throw new Error("The parameter 'moduleAttemptId' must be defined.");
        url_ = url_.replace("{moduleAttemptId}", encodeURIComponent("" + moduleAttemptId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(moduleAttemptId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/BookAttempt/{moduleAttemptId}";
        if (moduleAttemptId === undefined || moduleAttemptId === null)
            throw new Error("The parameter 'moduleAttemptId' must be defined.");
        url_ = url_.replace("{moduleAttemptId}", encodeURIComponent("" + moduleAttemptId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    create(settings: CreateModuleAttemptSettingsOfBookResult , cancelToken?: CancelToken | undefined): Promise<ModuleAttemptOfBookResult> {
        let url_ = this.baseUrl + "/v1/BookAttempt";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ModuleAttemptOfBookResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleAttemptOfBookResult.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleAttemptOfBookResult>(<any>null);
    }

    examplePass(moduleId: string | null, contentId: string | null , cancelToken?: CancelToken | undefined): Promise<BookResult> {
        let url_ = this.baseUrl + "/v1/BookAttempt/{moduleId}/Content/{contentId}/ExamplePass";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExamplePass(_response);
        });
    }

    protected processExamplePass(response: AxiosResponse): Promise<BookResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BookResult.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BookResult>(<any>null);
    }
}

export class BookContentClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAll(moduleId: string | null, skip: number | undefined, take: number | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfModuleContentOfBookSettings> {
        let url_ = this.baseUrl + "/v1/BookContent/{moduleId}/Content?";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfModuleContentOfBookSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfModuleContentOfBookSettings.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfModuleContentOfBookSettings>(<any>null);
    }

    create(moduleId: string | null, settings: CreateModuleContentSettingsOfBookSettings , cancelToken?: CancelToken | undefined): Promise<ModuleContentOfBookSettings> {
        let url_ = this.baseUrl + "/v1/BookContent/{moduleId}/Content";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ModuleContentOfBookSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleContentOfBookSettings.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleContentOfBookSettings>(<any>null);
    }

    get(moduleId: string | null, contentId: string | null , cancelToken?: CancelToken | undefined): Promise<ModuleContentOfBookSettings> {
        let url_ = this.baseUrl + "/v1/BookContent/{moduleId}/Content/{contentId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ModuleContentOfBookSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleContentOfBookSettings.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleContentOfBookSettings>(<any>null);
    }

    update(moduleId: string | null, contentId: string | null, settings: UpdateModuleContentSettingsOfBookSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/BookContent/{moduleId}/Content/{contentId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(moduleId: string | null, contentId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/BookContent/{moduleId}/Content/{contentId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    createFromZip(moduleId: string | null, file: FileParameter | null | undefined , cancelToken?: CancelToken | undefined): Promise<ModuleContentOfBookSettings> {
        let url_ = this.baseUrl + "/v1/BookContent/{moduleId}/Content/FromZip";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateFromZip(_response);
        });
    }

    protected processCreateFromZip(response: AxiosResponse): Promise<ModuleContentOfBookSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleContentOfBookSettings.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleContentOfBookSettings>(<any>null);
    }

    updateFromZip(moduleId: string | null, contentId: string | null, file: FileParameter | null | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/BookContent/{moduleId}/Content/{contentId}/FromZip";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateFromZip(_response);
        });
    }

    protected processUpdateFromZip(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    publish(moduleId: string | null, contentId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/BookContent/{moduleId}/Content/{contentId}/Publish";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPublish(_response);
        });
    }

    protected processPublish(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    downloadFile(moduleId: string | null, contentId: string | null, fileId: string | null , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/BookContent/{moduleId}/Content/{contentId}/File/{fileId}/Download";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadFile(_response);
        });
    }

    protected processDownloadFile(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    export(moduleId: string | null, contentId: string | null , cancelToken?: CancelToken | undefined): Promise<CreateModuleContentSettingsOfBookSettings> {
        let url_ = this.baseUrl + "/v1/BookContent/{moduleId}/Content/{contentId}/Export";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExport(_response);
        });
    }

    protected processExport(response: AxiosResponse): Promise<CreateModuleContentSettingsOfBookSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CreateModuleContentSettingsOfBookSettings.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateModuleContentSettingsOfBookSettings>(<any>null);
    }

    example(  cancelToken?: CancelToken | undefined): Promise<BookSettings> {
        let url_ = this.baseUrl + "/v1/BookContent/Example";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExample(_response);
        });
    }

    protected processExample(response: AxiosResponse): Promise<BookSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BookSettings.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BookSettings>(<any>null);
    }

    schema(  cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/BookContent/Schema";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSchema(_response);
        });
    }

    protected processSchema(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }
}

export class CertificateClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param publisherId (optional) 
     */
    getAll(search: string | null | undefined, skip: number | undefined, take: number | undefined, publisherId: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfCertificate> {
        let url_ = this.baseUrl + "/v1/Certificate?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (publisherId !== undefined && publisherId !== null)
            url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfCertificate> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfCertificate.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfCertificate>(<any>null);
    }

    create(settings: CreateCertificateSettings , cancelToken?: CancelToken | undefined): Promise<Certificate> {
        let url_ = this.baseUrl + "/v1/Certificate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Certificate> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Certificate.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Certificate>(<any>null);
    }

    get(certificateId: string | null , cancelToken?: CancelToken | undefined): Promise<Certificate> {
        let url_ = this.baseUrl + "/v1/Certificate/{certificateId}";
        if (certificateId === undefined || certificateId === null)
            throw new Error("The parameter 'certificateId' must be defined.");
        url_ = url_.replace("{certificateId}", encodeURIComponent("" + certificateId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Certificate> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Certificate.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Certificate>(<any>null);
    }

    update(certificateId: string | null, settings: UpdateCertificateSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Certificate/{certificateId}";
        if (certificateId === undefined || certificateId === null)
            throw new Error("The parameter 'certificateId' must be defined.");
        url_ = url_.replace("{certificateId}", encodeURIComponent("" + certificateId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(certificateId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Certificate/{certificateId}";
        if (certificateId === undefined || certificateId === null)
            throw new Error("The parameter 'certificateId' must be defined.");
        url_ = url_.replace("{certificateId}", encodeURIComponent("" + certificateId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class CertificationClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAllForTrainee(traineeId: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfCertification> {
        let url_ = this.baseUrl + "/v1/Certification/Trainee/{traineeId}?";
        if (traineeId === undefined || traineeId === null)
            throw new Error("The parameter 'traineeId' must be defined.");
        url_ = url_.replace("{traineeId}", encodeURIComponent("" + traineeId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForTrainee(_response);
        });
    }

    protected processGetAllForTrainee(response: AxiosResponse): Promise<ListOfCertification> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfCertification.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfCertification>(<any>null);
    }

    /**
     * Gets the certifications for a trainee at the given time.
     * @param traineeId The user id of the trainee.
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param at (optional) The UTC time at which to get certificates. If not specified, the current time is used.
     */
    getAllHistoryForTrainee(traineeId: string | null, skip: number | undefined, take: number | undefined, at: Date | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfCertificationFact> {
        let url_ = this.baseUrl + "/v1/Certification/Trainee/{traineeId}/History?";
        if (traineeId === undefined || traineeId === null)
            throw new Error("The parameter 'traineeId' must be defined.");
        url_ = url_.replace("{traineeId}", encodeURIComponent("" + traineeId));
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (at !== undefined && at !== null)
            url_ += "at=" + encodeURIComponent(at ? "" + at.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllHistoryForTrainee(_response);
        });
    }

    protected processGetAllHistoryForTrainee(response: AxiosResponse): Promise<ListOfCertificationFact> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfCertificationFact.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfCertificationFact>(<any>null);
    }

    /**
     * Gets the list of users with a certificate in a group at a specified time, optionally filtered by their status and roles in the group.
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param certificateId (optional) 
     * @param memberStatus (optional) 
     * @param role (optional) 
     * @param at (optional) The UTC time at which to get certificates. If not specified, the current time is used.
     */
    getAllHistoryForGroup(groupId: string | null, skip: number | undefined, take: number | undefined, certificateId: string | null | undefined, memberStatus: MemberStatus | null | undefined, role: string | null | undefined, at: Date | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfCertificationFact> {
        let url_ = this.baseUrl + "/v1/Certification/Group/{groupId}/History?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (certificateId !== undefined && certificateId !== null)
            url_ += "certificateId=" + encodeURIComponent("" + certificateId) + "&";
        if (memberStatus !== undefined && memberStatus !== null)
            url_ += "memberStatus=" + encodeURIComponent("" + memberStatus) + "&";
        if (role !== undefined && role !== null)
            url_ += "role=" + encodeURIComponent("" + role) + "&";
        if (at !== undefined && at !== null)
            url_ += "at=" + encodeURIComponent(at ? "" + at.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllHistoryForGroup(_response);
        });
    }

    protected processGetAllHistoryForGroup(response: AxiosResponse): Promise<ListOfCertificationFact> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfCertificationFact.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfCertificationFact>(<any>null);
    }

    get(certificationId: string | null , cancelToken?: CancelToken | undefined): Promise<Certification> {
        let url_ = this.baseUrl + "/v1/Certification/{certificationId}";
        if (certificationId === undefined || certificationId === null)
            throw new Error("The parameter 'certificationId' must be defined.");
        url_ = url_.replace("{certificationId}", encodeURIComponent("" + certificationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Certification> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Certification.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Certification>(<any>null);
    }

    export(certificationId: string | null , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/Certification/{certificationId}/Export";
        if (certificationId === undefined || certificationId === null)
            throw new Error("The parameter 'certificationId' must be defined.");
        url_ = url_.replace("{certificationId}", encodeURIComponent("" + certificationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExport(_response);
        });
    }

    protected processExport(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    download(token: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/Certification/Download?";
        if (token !== undefined && token !== null)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownload(_response);
        });
    }

    protected processDownload(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }
}

export class ClassClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get a list of all classes
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param organisationId (optional) Optional organisation id filter
     * @param teamId (optional) Optional team id filter
     * @param publisherId (optional) Optional publisher id filter
     * @param courseId (optional) Optional course id filter
     * @param programId (optional) - null/empty to show all
    - program ID to filter to specific program
    - "none" to filter to items not in any program
     * @param activated (optional) Optional filter by class activation state
     */
    getAll(search: string | null | undefined, skip: number | undefined, take: number | undefined, organisationId: string | null | undefined, teamId: string | null | undefined, publisherId: string | null | undefined, courseId: string | null | undefined, programId: string | null | undefined, activated: boolean | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfClass> {
        let url_ = this.baseUrl + "/v1/Class?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (organisationId !== undefined && organisationId !== null)
            url_ += "organisationId=" + encodeURIComponent("" + organisationId) + "&";
        if (teamId !== undefined && teamId !== null)
            url_ += "teamId=" + encodeURIComponent("" + teamId) + "&";
        if (publisherId !== undefined && publisherId !== null)
            url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&";
        if (courseId !== undefined && courseId !== null)
            url_ += "courseId=" + encodeURIComponent("" + courseId) + "&";
        if (programId !== undefined && programId !== null)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        if (activated !== undefined && activated !== null)
            url_ += "activated=" + encodeURIComponent("" + activated) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfClass> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfClass.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfClass>(<any>null);
    }

    create(settings: CreateClassSettings , cancelToken?: CancelToken | undefined): Promise<Class> {
        let url_ = this.baseUrl + "/v1/Class";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Class> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Class.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Class>(<any>null);
    }

    get(classId: string | null , cancelToken?: CancelToken | undefined): Promise<Class> {
        let url_ = this.baseUrl + "/v1/Class/{classId}";
        if (classId === undefined || classId === null)
            throw new Error("The parameter 'classId' must be defined.");
        url_ = url_.replace("{classId}", encodeURIComponent("" + classId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Class> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Class.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Class>(<any>null);
    }

    update(classId: string | null, settings: UpdateClassSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Class/{classId}";
        if (classId === undefined || classId === null)
            throw new Error("The parameter 'classId' must be defined.");
        url_ = url_.replace("{classId}", encodeURIComponent("" + classId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(classId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Class/{classId}";
        if (classId === undefined || classId === null)
            throw new Error("The parameter 'classId' must be defined.");
        url_ = url_.replace("{classId}", encodeURIComponent("" + classId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Send assessment requested notification to trainers
     */
    notifyAssessors(classId: string | null, settings: NotifyAssessorsSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Class/{classId}/NotifyAssessors";
        if (classId === undefined || classId === null)
            throw new Error("The parameter 'classId' must be defined.");
        url_ = url_.replace("{classId}", encodeURIComponent("" + classId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processNotifyAssessors(_response);
        });
    }

    protected processNotifyAssessors(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class CourseClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param programId (optional) - null/empty to show all
    - program ID to filter to specific program
    - "none" to filter to items not in any program
     */
    getAllForPublisher(publisherId: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined, programId: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfCourse> {
        let url_ = this.baseUrl + "/v1/Course/Publisher/{publisherId}?";
        if (publisherId === undefined || publisherId === null)
            throw new Error("The parameter 'publisherId' must be defined.");
        url_ = url_.replace("{publisherId}", encodeURIComponent("" + publisherId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (programId !== undefined && programId !== null)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForPublisher(_response);
        });
    }

    protected processGetAllForPublisher(response: AxiosResponse): Promise<ListOfCourse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfCourse.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfCourse>(<any>null);
    }

    create(settings: CreateCourseSettings , cancelToken?: CancelToken | undefined): Promise<Course> {
        let url_ = this.baseUrl + "/v1/Course";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Course> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Course.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Course>(<any>null);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param consumerId (optional) 
     * @param publisherId (optional) 
     * @param programId (optional) - null/empty to show all
    - program ID to filter to specific program
    - "none" to filter to items not in any program
     * @param itemId (optional) 
     * @param activated (optional) 
     */
    getAllByActivation(search: string | null | undefined, skip: number | undefined, take: number | undefined, consumerId: string | null | undefined, publisherId: string | null | undefined, programId: string | null | undefined, itemId: string | null | undefined, activated: boolean | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfCourse> {
        let url_ = this.baseUrl + "/v1/Course?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (consumerId !== undefined && consumerId !== null)
            url_ += "consumerId=" + encodeURIComponent("" + consumerId) + "&";
        if (publisherId !== undefined && publisherId !== null)
            url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&";
        if (programId !== undefined && programId !== null)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        if (itemId !== undefined && itemId !== null)
            url_ += "itemId=" + encodeURIComponent("" + itemId) + "&";
        if (activated !== undefined && activated !== null)
            url_ += "activated=" + encodeURIComponent("" + activated) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllByActivation(_response);
        });
    }

    protected processGetAllByActivation(response: AxiosResponse): Promise<ListOfCourse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfCourse.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfCourse>(<any>null);
    }

    update(courseId: string | null, settings: UpdateCourseSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Course/{courseId}";
        if (courseId === undefined || courseId === null)
            throw new Error("The parameter 'courseId' must be defined.");
        url_ = url_.replace("{courseId}", encodeURIComponent("" + courseId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(courseId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Course/{courseId}";
        if (courseId === undefined || courseId === null)
            throw new Error("The parameter 'courseId' must be defined.");
        url_ = url_.replace("{courseId}", encodeURIComponent("" + courseId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param publisherId (optional) 
     * @param programId (optional) - null/empty to show all
    - program ID to filter to specific program
    - "none" to filter to items not in any program
     * @param countryCode (optional) 
     */
    getAllPublished(search: string | null | undefined, skip: number | undefined, take: number | undefined, publisherId: string | null | undefined, programId: string | null | undefined, countryCode: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfCourse> {
        let url_ = this.baseUrl + "/v1/Course/Published?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (publisherId !== undefined && publisherId !== null)
            url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&";
        if (programId !== undefined && programId !== null)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        if (countryCode !== undefined && countryCode !== null)
            url_ += "countryCode=" + encodeURIComponent("" + countryCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllPublished(_response);
        });
    }

    protected processGetAllPublished(response: AxiosResponse): Promise<ListOfCourse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfCourse.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfCourse>(<any>null);
    }

    get(id: string | null , cancelToken?: CancelToken | undefined): Promise<Course> {
        let url_ = this.baseUrl + "/v1/Course/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Course> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Course.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Course>(<any>null);
    }
}

export class EnrolmentClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param activated (optional) 
     * @param programId (optional) - null/empty to show all
    - program ID to filter to specific program
    - "none" to filter to items not in any program
     */
    getAllForTrainee(traineeId: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined, activated: boolean | null | undefined, programId: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfEnrolment> {
        let url_ = this.baseUrl + "/v1/Enrolment/Trainee/{traineeId}?";
        if (traineeId === undefined || traineeId === null)
            throw new Error("The parameter 'traineeId' must be defined.");
        url_ = url_.replace("{traineeId}", encodeURIComponent("" + traineeId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (activated !== undefined && activated !== null)
            url_ += "activated=" + encodeURIComponent("" + activated) + "&";
        if (programId !== undefined && programId !== null)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForTrainee(_response);
        });
    }

    protected processGetAllForTrainee(response: AxiosResponse): Promise<ListOfEnrolment> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfEnrolment.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfEnrolment>(<any>null);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAllForClass(classId: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfEnrolment> {
        let url_ = this.baseUrl + "/v1/Enrolment/Class/{classId}?";
        if (classId === undefined || classId === null)
            throw new Error("The parameter 'classId' must be defined.");
        url_ = url_.replace("{classId}", encodeURIComponent("" + classId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForClass(_response);
        });
    }

    protected processGetAllForClass(response: AxiosResponse): Promise<ListOfEnrolment> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfEnrolment.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfEnrolment>(<any>null);
    }

    get(enrolmentId: string | null , cancelToken?: CancelToken | undefined): Promise<Enrolment> {
        let url_ = this.baseUrl + "/v1/Enrolment/{enrolmentId}";
        if (enrolmentId === undefined || enrolmentId === null)
            throw new Error("The parameter 'enrolmentId' must be defined.");
        url_ = url_.replace("{enrolmentId}", encodeURIComponent("" + enrolmentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Enrolment> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Enrolment.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Enrolment>(<any>null);
    }
}

export class ModuleAttemptClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param moduleId (optional) 
     */
    getAllForActor(actorId: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined, moduleId: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfModuleAttempt> {
        let url_ = this.baseUrl + "/v1/ModuleAttempt/Actor/{actorId}?";
        if (actorId === undefined || actorId === null)
            throw new Error("The parameter 'actorId' must be defined.");
        url_ = url_.replace("{actorId}", encodeURIComponent("" + actorId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (moduleId !== undefined && moduleId !== null)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForActor(_response);
        });
    }

    protected processGetAllForActor(response: AxiosResponse): Promise<ListOfModuleAttempt> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfModuleAttempt.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfModuleAttempt>(<any>null);
    }

    /**
     * Gets all module attempts within the given group.
     * @param groupId The group to get module attempts from
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param moduleId (optional) Filter the results by module id
     * @param actorType (optional) Filter the results by actor type i.e. User, TrainingSession or Team. If left null, all actor types will be searched for.
     * @param from (optional) Start time of the module attempts
     * @param to (optional) End time of the module attempts
     */
    getAllForGroup(groupId: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined, moduleId: string | null | undefined, actorType: ActorType | null | undefined, from: Date | null | undefined, to: Date | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfModuleAttempt> {
        let url_ = this.baseUrl + "/v1/ModuleAttempt/Group/{groupId}?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (moduleId !== undefined && moduleId !== null)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&";
        if (actorType !== undefined && actorType !== null)
            url_ += "actorType=" + encodeURIComponent("" + actorType) + "&";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toJSON() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForGroup(_response);
        });
    }

    protected processGetAllForGroup(response: AxiosResponse): Promise<ListOfModuleAttempt> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfModuleAttempt.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfModuleAttempt>(<any>null);
    }

    get(moduleAttemptId: string | null , cancelToken?: CancelToken | undefined): Promise<ModuleAttempt> {
        let url_ = this.baseUrl + "/v1/ModuleAttempt/{moduleAttemptId}";
        if (moduleAttemptId === undefined || moduleAttemptId === null)
            throw new Error("The parameter 'moduleAttemptId' must be defined.");
        url_ = url_.replace("{moduleAttemptId}", encodeURIComponent("" + moduleAttemptId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ModuleAttempt> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleAttempt.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleAttempt>(<any>null);
    }

    delete(moduleAttemptId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/ModuleAttempt/{moduleAttemptId}";
        if (moduleAttemptId === undefined || moduleAttemptId === null)
            throw new Error("The parameter 'moduleAttemptId' must be defined.");
        url_ = url_.replace("{moduleAttemptId}", encodeURIComponent("" + moduleAttemptId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class ModuleClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param publisherId (optional) 
     * @param type (optional) 
     */
    getAll(search: string | null | undefined, skip: number | undefined, take: number | undefined, publisherId: string | null | undefined, type: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfModule> {
        let url_ = this.baseUrl + "/v1/Module?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (publisherId !== undefined && publisherId !== null)
            url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&";
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfModule> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfModule.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfModule>(<any>null);
    }

    /**
     * Creates a module using the given data
     * @param settings The data used to create the module
     */
    create(settings: CreateModuleSettings , cancelToken?: CancelToken | undefined): Promise<Module> {
        let url_ = this.baseUrl + "/v1/Module";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Module> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Module.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Module>(<any>null);
    }

    get(moduleId: string | null , cancelToken?: CancelToken | undefined): Promise<Module> {
        let url_ = this.baseUrl + "/v1/Module/{moduleId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Module> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Module.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Module>(<any>null);
    }

    update(moduleId: string | null, settings: UpdateModuleSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Module/{moduleId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(moduleId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Module/{moduleId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    getAllFiles(moduleId: string | null , cancelToken?: CancelToken | undefined): Promise<ListOfFile> {
        let url_ = this.baseUrl + "/v1/Module/{moduleId}/File";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllFiles(_response);
        });
    }

    protected processGetAllFiles(response: AxiosResponse): Promise<ListOfFile> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfFile.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfFile>(<any>null);
    }

    /**
     * Creates a file and attaches it to the module
     * @param moduleId Id of the module to attach the file to
     * @param settings Data used to create the file
     * @return Information about the created file
     */
    createFile(moduleId: string | null, settings: CreateFileSettings , cancelToken?: CancelToken | undefined): Promise<File> {
        let url_ = this.baseUrl + "/v1/Module/{moduleId}/File";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateFile(_response);
        });
    }

    protected processCreateFile(response: AxiosResponse): Promise<File> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = File.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<File>(<any>null);
    }

    getFile(moduleId: string | null, fileId: string | null , cancelToken?: CancelToken | undefined): Promise<File> {
        let url_ = this.baseUrl + "/v1/Module/{moduleId}/File/{fileId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetFile(_response);
        });
    }

    protected processGetFile(response: AxiosResponse): Promise<File> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = File.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<File>(<any>null);
    }

    updateFile(moduleId: string | null, fileId: string | null, settings: UpdateFileSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Module/{moduleId}/File/{fileId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateFile(_response);
        });
    }

    protected processUpdateFile(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    deleteFile(moduleId: string | null, fileId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Module/{moduleId}/File/{fileId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteFile(_response);
        });
    }

    protected processDeleteFile(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    downloadFile(moduleId: string | null, fileId: string | null , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/Module/{moduleId}/File/{fileId}/Download";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadFile(_response);
        });
    }

    protected processDownloadFile(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }
}

export class ModuleNpsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAllForPublisher(publisherId: string | null, search: string | null | undefined, from: Date | null | undefined, to: Date | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfModuleNps> {
        let url_ = this.baseUrl + "/v1/ModuleNps/Publisher/{publisherId}?";
        if (publisherId === undefined || publisherId === null)
            throw new Error("The parameter 'publisherId' must be defined.");
        url_ = url_.replace("{publisherId}", encodeURIComponent("" + publisherId));
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toJSON() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForPublisher(_response);
        });
    }

    protected processGetAllForPublisher(response: AxiosResponse): Promise<ListOfModuleNps> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfModuleNps.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfModuleNps>(<any>null);
    }

    getAllForModule(moduleId: string | null, from: Date | null | undefined, to: Date | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfModuleNps> {
        let url_ = this.baseUrl + "/v1/ModuleNps/Module/{moduleId}?";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toJSON() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForModule(_response);
        });
    }

    protected processGetAllForModule(response: AxiosResponse): Promise<ListOfModuleNps> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfModuleNps.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfModuleNps>(<any>null);
    }

    get(npsId: string | null , cancelToken?: CancelToken | undefined): Promise<Nps> {
        let url_ = this.baseUrl + "/v1/ModuleNps/{npsId}";
        if (npsId === undefined || npsId === null)
            throw new Error("The parameter 'npsId' must be defined.");
        url_ = url_.replace("{npsId}", encodeURIComponent("" + npsId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Nps> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Nps.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Nps>(<any>null);
    }

    delete(npsId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/ModuleNps/{npsId}";
        if (npsId === undefined || npsId === null)
            throw new Error("The parameter 'npsId' must be defined.");
        url_ = url_.replace("{npsId}", encodeURIComponent("" + npsId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    create(settings: CreateNpsSettings , cancelToken?: CancelToken | undefined): Promise<Nps> {
        let url_ = this.baseUrl + "/v1/ModuleNps";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Nps> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Nps.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Nps>(<any>null);
    }
}

export class QuizAttemptClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param moduleId (optional) 
     */
    getAllForActor(actorId: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined, moduleId: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfModuleAttemptOfQuizResult> {
        let url_ = this.baseUrl + "/v1/QuizAttempt/Actor/{actorId}?";
        if (actorId === undefined || actorId === null)
            throw new Error("The parameter 'actorId' must be defined.");
        url_ = url_.replace("{actorId}", encodeURIComponent("" + actorId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (moduleId !== undefined && moduleId !== null)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForActor(_response);
        });
    }

    protected processGetAllForActor(response: AxiosResponse): Promise<ListOfModuleAttemptOfQuizResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfModuleAttemptOfQuizResult.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfModuleAttemptOfQuizResult>(<any>null);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param moduleId (optional) 
     * @param actorType (optional) 
     * @param from (optional) 
     * @param to (optional) 
     */
    getAllForGroup(groupId: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined, moduleId: string | null | undefined, actorType: ActorType | null | undefined, from: Date | null | undefined, to: Date | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfModuleAttemptOfQuizResult> {
        let url_ = this.baseUrl + "/v1/QuizAttempt/Group/{groupId}?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (moduleId !== undefined && moduleId !== null)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&";
        if (actorType !== undefined && actorType !== null)
            url_ += "actorType=" + encodeURIComponent("" + actorType) + "&";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toJSON() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForGroup(_response);
        });
    }

    protected processGetAllForGroup(response: AxiosResponse): Promise<ListOfModuleAttemptOfQuizResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfModuleAttemptOfQuizResult.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfModuleAttemptOfQuizResult>(<any>null);
    }

    get(moduleAttemptId: string | null , cancelToken?: CancelToken | undefined): Promise<ModuleAttemptOfQuizResult> {
        let url_ = this.baseUrl + "/v1/QuizAttempt/{moduleAttemptId}";
        if (moduleAttemptId === undefined || moduleAttemptId === null)
            throw new Error("The parameter 'moduleAttemptId' must be defined.");
        url_ = url_.replace("{moduleAttemptId}", encodeURIComponent("" + moduleAttemptId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ModuleAttemptOfQuizResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleAttemptOfQuizResult.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleAttemptOfQuizResult>(<any>null);
    }

    update(moduleAttemptId: string | null, settings: UpdateModuleAttemptSettingsOfQuizResult , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/QuizAttempt/{moduleAttemptId}";
        if (moduleAttemptId === undefined || moduleAttemptId === null)
            throw new Error("The parameter 'moduleAttemptId' must be defined.");
        url_ = url_.replace("{moduleAttemptId}", encodeURIComponent("" + moduleAttemptId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(moduleAttemptId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/QuizAttempt/{moduleAttemptId}";
        if (moduleAttemptId === undefined || moduleAttemptId === null)
            throw new Error("The parameter 'moduleAttemptId' must be defined.");
        url_ = url_.replace("{moduleAttemptId}", encodeURIComponent("" + moduleAttemptId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    create(settings: CreateModuleAttemptSettingsOfQuizResult , cancelToken?: CancelToken | undefined): Promise<ModuleAttemptOfQuizResult> {
        let url_ = this.baseUrl + "/v1/QuizAttempt";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ModuleAttemptOfQuizResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleAttemptOfQuizResult.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleAttemptOfQuizResult>(<any>null);
    }

    examplePass(moduleId: string | null, contentId: string | null , cancelToken?: CancelToken | undefined): Promise<QuizResult> {
        let url_ = this.baseUrl + "/v1/QuizAttempt/{moduleId}/Content/{contentId}/ExamplePass";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExamplePass(_response);
        });
    }

    protected processExamplePass(response: AxiosResponse): Promise<QuizResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = QuizResult.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<QuizResult>(<any>null);
    }
}

export class QuizContentClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAll(moduleId: string | null, skip: number | undefined, take: number | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfModuleContentOfQuizSettings> {
        let url_ = this.baseUrl + "/v1/QuizContent/{moduleId}/Content?";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfModuleContentOfQuizSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfModuleContentOfQuizSettings.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfModuleContentOfQuizSettings>(<any>null);
    }

    create(moduleId: string | null, settings: CreateModuleContentSettingsOfQuizSettings , cancelToken?: CancelToken | undefined): Promise<ModuleContentOfQuizSettings> {
        let url_ = this.baseUrl + "/v1/QuizContent/{moduleId}/Content";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ModuleContentOfQuizSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleContentOfQuizSettings.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleContentOfQuizSettings>(<any>null);
    }

    get(moduleId: string | null, contentId: string | null , cancelToken?: CancelToken | undefined): Promise<ModuleContentOfQuizSettings> {
        let url_ = this.baseUrl + "/v1/QuizContent/{moduleId}/Content/{contentId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ModuleContentOfQuizSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleContentOfQuizSettings.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleContentOfQuizSettings>(<any>null);
    }

    update(moduleId: string | null, contentId: string | null, settings: UpdateModuleContentSettingsOfQuizSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/QuizContent/{moduleId}/Content/{contentId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(moduleId: string | null, contentId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/QuizContent/{moduleId}/Content/{contentId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    createFromZip(moduleId: string | null, file: FileParameter | null | undefined , cancelToken?: CancelToken | undefined): Promise<ModuleContentOfQuizSettings> {
        let url_ = this.baseUrl + "/v1/QuizContent/{moduleId}/Content/FromZip";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateFromZip(_response);
        });
    }

    protected processCreateFromZip(response: AxiosResponse): Promise<ModuleContentOfQuizSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleContentOfQuizSettings.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleContentOfQuizSettings>(<any>null);
    }

    updateFromZip(moduleId: string | null, contentId: string | null, file: FileParameter | null | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/QuizContent/{moduleId}/Content/{contentId}/FromZip";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateFromZip(_response);
        });
    }

    protected processUpdateFromZip(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    publish(moduleId: string | null, contentId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/QuizContent/{moduleId}/Content/{contentId}/Publish";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPublish(_response);
        });
    }

    protected processPublish(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    downloadFile(moduleId: string | null, contentId: string | null, fileId: string | null , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/QuizContent/{moduleId}/Content/{contentId}/File/{fileId}/Download";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadFile(_response);
        });
    }

    protected processDownloadFile(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    export(moduleId: string | null, contentId: string | null , cancelToken?: CancelToken | undefined): Promise<CreateModuleContentSettingsOfQuizSettings> {
        let url_ = this.baseUrl + "/v1/QuizContent/{moduleId}/Content/{contentId}/Export";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExport(_response);
        });
    }

    protected processExport(response: AxiosResponse): Promise<CreateModuleContentSettingsOfQuizSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CreateModuleContentSettingsOfQuizSettings.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateModuleContentSettingsOfQuizSettings>(<any>null);
    }

    example(  cancelToken?: CancelToken | undefined): Promise<QuizSettings> {
        let url_ = this.baseUrl + "/v1/QuizContent/Example";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExample(_response);
        });
    }

    protected processExample(response: AxiosResponse): Promise<QuizSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = QuizSettings.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<QuizSettings>(<any>null);
    }

    schema(  cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/QuizContent/Schema";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSchema(_response);
        });
    }

    protected processSchema(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }
}

export class RevisionAttemptClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param moduleId (optional) 
     */
    getAllForActor(actorId: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined, moduleId: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfModuleAttemptOfRevisionResult> {
        let url_ = this.baseUrl + "/v1/RevisionAttempt/Actor/{actorId}?";
        if (actorId === undefined || actorId === null)
            throw new Error("The parameter 'actorId' must be defined.");
        url_ = url_.replace("{actorId}", encodeURIComponent("" + actorId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (moduleId !== undefined && moduleId !== null)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForActor(_response);
        });
    }

    protected processGetAllForActor(response: AxiosResponse): Promise<ListOfModuleAttemptOfRevisionResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfModuleAttemptOfRevisionResult.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfModuleAttemptOfRevisionResult>(<any>null);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param moduleId (optional) 
     * @param actorType (optional) 
     * @param from (optional) 
     * @param to (optional) 
     */
    getAllForGroup(groupId: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined, moduleId: string | null | undefined, actorType: ActorType | null | undefined, from: Date | null | undefined, to: Date | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfModuleAttemptOfRevisionResult> {
        let url_ = this.baseUrl + "/v1/RevisionAttempt/Group/{groupId}?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (moduleId !== undefined && moduleId !== null)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&";
        if (actorType !== undefined && actorType !== null)
            url_ += "actorType=" + encodeURIComponent("" + actorType) + "&";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toJSON() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForGroup(_response);
        });
    }

    protected processGetAllForGroup(response: AxiosResponse): Promise<ListOfModuleAttemptOfRevisionResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfModuleAttemptOfRevisionResult.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfModuleAttemptOfRevisionResult>(<any>null);
    }

    get(moduleAttemptId: string | null , cancelToken?: CancelToken | undefined): Promise<ModuleAttemptOfRevisionResult> {
        let url_ = this.baseUrl + "/v1/RevisionAttempt/{moduleAttemptId}";
        if (moduleAttemptId === undefined || moduleAttemptId === null)
            throw new Error("The parameter 'moduleAttemptId' must be defined.");
        url_ = url_.replace("{moduleAttemptId}", encodeURIComponent("" + moduleAttemptId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ModuleAttemptOfRevisionResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleAttemptOfRevisionResult.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleAttemptOfRevisionResult>(<any>null);
    }

    update(moduleAttemptId: string | null, settings: UpdateModuleAttemptSettingsOfRevisionResult , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/RevisionAttempt/{moduleAttemptId}";
        if (moduleAttemptId === undefined || moduleAttemptId === null)
            throw new Error("The parameter 'moduleAttemptId' must be defined.");
        url_ = url_.replace("{moduleAttemptId}", encodeURIComponent("" + moduleAttemptId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(moduleAttemptId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/RevisionAttempt/{moduleAttemptId}";
        if (moduleAttemptId === undefined || moduleAttemptId === null)
            throw new Error("The parameter 'moduleAttemptId' must be defined.");
        url_ = url_.replace("{moduleAttemptId}", encodeURIComponent("" + moduleAttemptId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    create(settings: CreateModuleAttemptSettingsOfRevisionResult , cancelToken?: CancelToken | undefined): Promise<ModuleAttemptOfRevisionResult> {
        let url_ = this.baseUrl + "/v1/RevisionAttempt";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ModuleAttemptOfRevisionResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleAttemptOfRevisionResult.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleAttemptOfRevisionResult>(<any>null);
    }

    examplePass(moduleId: string | null, contentId: string | null , cancelToken?: CancelToken | undefined): Promise<RevisionResult> {
        let url_ = this.baseUrl + "/v1/RevisionAttempt/{moduleId}/Content/{contentId}/ExamplePass";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExamplePass(_response);
        });
    }

    protected processExamplePass(response: AxiosResponse): Promise<RevisionResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RevisionResult.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RevisionResult>(<any>null);
    }
}

export class RevisionContentClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAll(moduleId: string | null, skip: number | undefined, take: number | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfModuleContentOfRevisionSettings> {
        let url_ = this.baseUrl + "/v1/RevisionContent/{moduleId}/Content?";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfModuleContentOfRevisionSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfModuleContentOfRevisionSettings.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfModuleContentOfRevisionSettings>(<any>null);
    }

    create(moduleId: string | null, settings: CreateModuleContentSettingsOfRevisionSettings , cancelToken?: CancelToken | undefined): Promise<ModuleContentOfRevisionSettings> {
        let url_ = this.baseUrl + "/v1/RevisionContent/{moduleId}/Content";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ModuleContentOfRevisionSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleContentOfRevisionSettings.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleContentOfRevisionSettings>(<any>null);
    }

    get(moduleId: string | null, contentId: string | null , cancelToken?: CancelToken | undefined): Promise<ModuleContentOfRevisionSettings> {
        let url_ = this.baseUrl + "/v1/RevisionContent/{moduleId}/Content/{contentId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ModuleContentOfRevisionSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleContentOfRevisionSettings.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleContentOfRevisionSettings>(<any>null);
    }

    update(moduleId: string | null, contentId: string | null, settings: UpdateModuleContentSettingsOfRevisionSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/RevisionContent/{moduleId}/Content/{contentId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(moduleId: string | null, contentId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/RevisionContent/{moduleId}/Content/{contentId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    createFromZip(moduleId: string | null, file: FileParameter | null | undefined , cancelToken?: CancelToken | undefined): Promise<ModuleContentOfRevisionSettings> {
        let url_ = this.baseUrl + "/v1/RevisionContent/{moduleId}/Content/FromZip";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateFromZip(_response);
        });
    }

    protected processCreateFromZip(response: AxiosResponse): Promise<ModuleContentOfRevisionSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleContentOfRevisionSettings.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleContentOfRevisionSettings>(<any>null);
    }

    updateFromZip(moduleId: string | null, contentId: string | null, file: FileParameter | null | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/RevisionContent/{moduleId}/Content/{contentId}/FromZip";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateFromZip(_response);
        });
    }

    protected processUpdateFromZip(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    publish(moduleId: string | null, contentId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/RevisionContent/{moduleId}/Content/{contentId}/Publish";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPublish(_response);
        });
    }

    protected processPublish(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    downloadFile(moduleId: string | null, contentId: string | null, fileId: string | null , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/RevisionContent/{moduleId}/Content/{contentId}/File/{fileId}/Download";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadFile(_response);
        });
    }

    protected processDownloadFile(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    export(moduleId: string | null, contentId: string | null , cancelToken?: CancelToken | undefined): Promise<CreateModuleContentSettingsOfRevisionSettings> {
        let url_ = this.baseUrl + "/v1/RevisionContent/{moduleId}/Content/{contentId}/Export";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExport(_response);
        });
    }

    protected processExport(response: AxiosResponse): Promise<CreateModuleContentSettingsOfRevisionSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CreateModuleContentSettingsOfRevisionSettings.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateModuleContentSettingsOfRevisionSettings>(<any>null);
    }

    example(  cancelToken?: CancelToken | undefined): Promise<RevisionSettings> {
        let url_ = this.baseUrl + "/v1/RevisionContent/Example";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExample(_response);
        });
    }

    protected processExample(response: AxiosResponse): Promise<RevisionSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RevisionSettings.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RevisionSettings>(<any>null);
    }

    schema(  cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/RevisionContent/Schema";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSchema(_response);
        });
    }

    protected processSchema(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }
}

export class TrainingSessionClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param groupId (optional) 
     * @param from (optional) 
     * @param status (optional) 
     */
    getAll(search: string | null | undefined, skip: number | undefined, take: number | undefined, groupId: string | null | undefined, from: Date | null | undefined, status: TrainingSessionStatus | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfTrainingSession> {
        let url_ = this.baseUrl + "/v1/TrainingSession?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (groupId !== undefined && groupId !== null)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toJSON() : "") + "&";
        if (status !== undefined && status !== null)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfTrainingSession> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfTrainingSession.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfTrainingSession>(<any>null);
    }

    create(settings: CreateTrainingSessionSettings , cancelToken?: CancelToken | undefined): Promise<TrainingSession> {
        let url_ = this.baseUrl + "/v1/TrainingSession";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<TrainingSession> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TrainingSession.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TrainingSession>(<any>null);
    }

    get(trainingSessionId: string | null , cancelToken?: CancelToken | undefined): Promise<TrainingSession> {
        let url_ = this.baseUrl + "/v1/TrainingSession/{trainingSessionId}";
        if (trainingSessionId === undefined || trainingSessionId === null)
            throw new Error("The parameter 'trainingSessionId' must be defined.");
        url_ = url_.replace("{trainingSessionId}", encodeURIComponent("" + trainingSessionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<TrainingSession> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TrainingSession.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TrainingSession>(<any>null);
    }

    update(trainingSessionId: string | null, settings: UpdateTrainingSessionSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/TrainingSession/{trainingSessionId}";
        if (trainingSessionId === undefined || trainingSessionId === null)
            throw new Error("The parameter 'trainingSessionId' must be defined.");
        url_ = url_.replace("{trainingSessionId}", encodeURIComponent("" + trainingSessionId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(trainingSessionId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/TrainingSession/{trainingSessionId}";
        if (trainingSessionId === undefined || trainingSessionId === null)
            throw new Error("The parameter 'trainingSessionId' must be defined.");
        url_ = url_.replace("{trainingSessionId}", encodeURIComponent("" + trainingSessionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class VideoAttemptClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param moduleId (optional) 
     */
    getAllForActor(actorId: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined, moduleId: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfModuleAttemptOfVideoResult> {
        let url_ = this.baseUrl + "/v1/VideoAttempt/Actor/{actorId}?";
        if (actorId === undefined || actorId === null)
            throw new Error("The parameter 'actorId' must be defined.");
        url_ = url_.replace("{actorId}", encodeURIComponent("" + actorId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (moduleId !== undefined && moduleId !== null)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForActor(_response);
        });
    }

    protected processGetAllForActor(response: AxiosResponse): Promise<ListOfModuleAttemptOfVideoResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfModuleAttemptOfVideoResult.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfModuleAttemptOfVideoResult>(<any>null);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param moduleId (optional) 
     * @param actorType (optional) 
     * @param from (optional) 
     * @param to (optional) 
     */
    getAllForGroup(groupId: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined, moduleId: string | null | undefined, actorType: ActorType | null | undefined, from: Date | null | undefined, to: Date | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfModuleAttemptOfVideoResult> {
        let url_ = this.baseUrl + "/v1/VideoAttempt/Group/{groupId}?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (moduleId !== undefined && moduleId !== null)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&";
        if (actorType !== undefined && actorType !== null)
            url_ += "actorType=" + encodeURIComponent("" + actorType) + "&";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toJSON() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForGroup(_response);
        });
    }

    protected processGetAllForGroup(response: AxiosResponse): Promise<ListOfModuleAttemptOfVideoResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfModuleAttemptOfVideoResult.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfModuleAttemptOfVideoResult>(<any>null);
    }

    get(moduleAttemptId: string | null , cancelToken?: CancelToken | undefined): Promise<ModuleAttemptOfVideoResult> {
        let url_ = this.baseUrl + "/v1/VideoAttempt/{moduleAttemptId}";
        if (moduleAttemptId === undefined || moduleAttemptId === null)
            throw new Error("The parameter 'moduleAttemptId' must be defined.");
        url_ = url_.replace("{moduleAttemptId}", encodeURIComponent("" + moduleAttemptId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ModuleAttemptOfVideoResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleAttemptOfVideoResult.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleAttemptOfVideoResult>(<any>null);
    }

    update(moduleAttemptId: string | null, settings: UpdateModuleAttemptSettingsOfVideoResult , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/VideoAttempt/{moduleAttemptId}";
        if (moduleAttemptId === undefined || moduleAttemptId === null)
            throw new Error("The parameter 'moduleAttemptId' must be defined.");
        url_ = url_.replace("{moduleAttemptId}", encodeURIComponent("" + moduleAttemptId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(moduleAttemptId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/VideoAttempt/{moduleAttemptId}";
        if (moduleAttemptId === undefined || moduleAttemptId === null)
            throw new Error("The parameter 'moduleAttemptId' must be defined.");
        url_ = url_.replace("{moduleAttemptId}", encodeURIComponent("" + moduleAttemptId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    create(settings: CreateModuleAttemptSettingsOfVideoResult , cancelToken?: CancelToken | undefined): Promise<ModuleAttemptOfVideoResult> {
        let url_ = this.baseUrl + "/v1/VideoAttempt";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ModuleAttemptOfVideoResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleAttemptOfVideoResult.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleAttemptOfVideoResult>(<any>null);
    }

    examplePass(moduleId: string | null, contentId: string | null , cancelToken?: CancelToken | undefined): Promise<VideoResult> {
        let url_ = this.baseUrl + "/v1/VideoAttempt/{moduleId}/Content/{contentId}/ExamplePass";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExamplePass(_response);
        });
    }

    protected processExamplePass(response: AxiosResponse): Promise<VideoResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = VideoResult.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<VideoResult>(<any>null);
    }
}

export class VideoContentClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAll(moduleId: string | null, skip: number | undefined, take: number | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfModuleContentOfVideoSettings> {
        let url_ = this.baseUrl + "/v1/VideoContent/{moduleId}/Content?";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfModuleContentOfVideoSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfModuleContentOfVideoSettings.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfModuleContentOfVideoSettings>(<any>null);
    }

    create(moduleId: string | null, settings: CreateModuleContentSettingsOfVideoSettings , cancelToken?: CancelToken | undefined): Promise<ModuleContentOfVideoSettings> {
        let url_ = this.baseUrl + "/v1/VideoContent/{moduleId}/Content";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ModuleContentOfVideoSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleContentOfVideoSettings.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleContentOfVideoSettings>(<any>null);
    }

    get(moduleId: string | null, contentId: string | null , cancelToken?: CancelToken | undefined): Promise<ModuleContentOfVideoSettings> {
        let url_ = this.baseUrl + "/v1/VideoContent/{moduleId}/Content/{contentId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ModuleContentOfVideoSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleContentOfVideoSettings.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleContentOfVideoSettings>(<any>null);
    }

    update(moduleId: string | null, contentId: string | null, settings: UpdateModuleContentSettingsOfVideoSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/VideoContent/{moduleId}/Content/{contentId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(moduleId: string | null, contentId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/VideoContent/{moduleId}/Content/{contentId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    createFromZip(moduleId: string | null, file: FileParameter | null | undefined , cancelToken?: CancelToken | undefined): Promise<ModuleContentOfVideoSettings> {
        let url_ = this.baseUrl + "/v1/VideoContent/{moduleId}/Content/FromZip";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateFromZip(_response);
        });
    }

    protected processCreateFromZip(response: AxiosResponse): Promise<ModuleContentOfVideoSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleContentOfVideoSettings.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleContentOfVideoSettings>(<any>null);
    }

    updateFromZip(moduleId: string | null, contentId: string | null, file: FileParameter | null | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/VideoContent/{moduleId}/Content/{contentId}/FromZip";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateFromZip(_response);
        });
    }

    protected processUpdateFromZip(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    publish(moduleId: string | null, contentId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/VideoContent/{moduleId}/Content/{contentId}/Publish";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPublish(_response);
        });
    }

    protected processPublish(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    downloadFile(moduleId: string | null, contentId: string | null, fileId: string | null , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/VideoContent/{moduleId}/Content/{contentId}/File/{fileId}/Download";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadFile(_response);
        });
    }

    protected processDownloadFile(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    export(moduleId: string | null, contentId: string | null , cancelToken?: CancelToken | undefined): Promise<CreateModuleContentSettingsOfVideoSettings> {
        let url_ = this.baseUrl + "/v1/VideoContent/{moduleId}/Content/{contentId}/Export";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExport(_response);
        });
    }

    protected processExport(response: AxiosResponse): Promise<CreateModuleContentSettingsOfVideoSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CreateModuleContentSettingsOfVideoSettings.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateModuleContentSettingsOfVideoSettings>(<any>null);
    }

    example(  cancelToken?: CancelToken | undefined): Promise<VideoSettings> {
        let url_ = this.baseUrl + "/v1/VideoContent/Example";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExample(_response);
        });
    }

    protected processExample(response: AxiosResponse): Promise<VideoSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = VideoSettings.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<VideoSettings>(<any>null);
    }

    schema(  cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/VideoContent/Schema";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSchema(_response);
        });
    }

    protected processSchema(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }
}

export class AssessmentAttemptClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param moduleId (optional) 
     */
    getAllForActor(actorId: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined, moduleId: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfModuleAttemptOfAssessmentResult> {
        let url_ = this.baseUrl + "/v1/AssessmentAttempt/Actor/{actorId}?";
        if (actorId === undefined || actorId === null)
            throw new Error("The parameter 'actorId' must be defined.");
        url_ = url_.replace("{actorId}", encodeURIComponent("" + actorId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (moduleId !== undefined && moduleId !== null)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForActor(_response);
        });
    }

    protected processGetAllForActor(response: AxiosResponse): Promise<ListOfModuleAttemptOfAssessmentResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfModuleAttemptOfAssessmentResult.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfModuleAttemptOfAssessmentResult>(<any>null);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param moduleId (optional) 
     * @param actorType (optional) 
     * @param from (optional) 
     * @param to (optional) 
     */
    getAllForGroup(groupId: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined, moduleId: string | null | undefined, actorType: ActorType | null | undefined, from: Date | null | undefined, to: Date | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfModuleAttemptOfAssessmentResult> {
        let url_ = this.baseUrl + "/v1/AssessmentAttempt/Group/{groupId}?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (moduleId !== undefined && moduleId !== null)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&";
        if (actorType !== undefined && actorType !== null)
            url_ += "actorType=" + encodeURIComponent("" + actorType) + "&";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toJSON() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForGroup(_response);
        });
    }

    protected processGetAllForGroup(response: AxiosResponse): Promise<ListOfModuleAttemptOfAssessmentResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfModuleAttemptOfAssessmentResult.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfModuleAttemptOfAssessmentResult>(<any>null);
    }

    get(moduleAttemptId: string | null , cancelToken?: CancelToken | undefined): Promise<ModuleAttemptOfAssessmentResult> {
        let url_ = this.baseUrl + "/v1/AssessmentAttempt/{moduleAttemptId}";
        if (moduleAttemptId === undefined || moduleAttemptId === null)
            throw new Error("The parameter 'moduleAttemptId' must be defined.");
        url_ = url_.replace("{moduleAttemptId}", encodeURIComponent("" + moduleAttemptId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ModuleAttemptOfAssessmentResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleAttemptOfAssessmentResult.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleAttemptOfAssessmentResult>(<any>null);
    }

    update(moduleAttemptId: string | null, settings: UpdateModuleAttemptSettingsOfAssessmentResult , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/AssessmentAttempt/{moduleAttemptId}";
        if (moduleAttemptId === undefined || moduleAttemptId === null)
            throw new Error("The parameter 'moduleAttemptId' must be defined.");
        url_ = url_.replace("{moduleAttemptId}", encodeURIComponent("" + moduleAttemptId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(moduleAttemptId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/AssessmentAttempt/{moduleAttemptId}";
        if (moduleAttemptId === undefined || moduleAttemptId === null)
            throw new Error("The parameter 'moduleAttemptId' must be defined.");
        url_ = url_.replace("{moduleAttemptId}", encodeURIComponent("" + moduleAttemptId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    create(settings: CreateModuleAttemptSettingsOfAssessmentResult , cancelToken?: CancelToken | undefined): Promise<ModuleAttemptOfAssessmentResult> {
        let url_ = this.baseUrl + "/v1/AssessmentAttempt";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ModuleAttemptOfAssessmentResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleAttemptOfAssessmentResult.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleAttemptOfAssessmentResult>(<any>null);
    }

    examplePass(moduleId: string | null, contentId: string | null , cancelToken?: CancelToken | undefined): Promise<AssessmentResult> {
        let url_ = this.baseUrl + "/v1/AssessmentAttempt/{moduleId}/Content/{contentId}/ExamplePass";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExamplePass(_response);
        });
    }

    protected processExamplePass(response: AxiosResponse): Promise<AssessmentResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AssessmentResult.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AssessmentResult>(<any>null);
    }
}

export class AssessmentContentClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAll(moduleId: string | null, skip: number | undefined, take: number | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfModuleContentOfAssessmentSettings> {
        let url_ = this.baseUrl + "/v1/AssessmentContent/{moduleId}/Content?";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfModuleContentOfAssessmentSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfModuleContentOfAssessmentSettings.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfModuleContentOfAssessmentSettings>(<any>null);
    }

    create(moduleId: string | null, settings: CreateModuleContentSettingsOfAssessmentSettings , cancelToken?: CancelToken | undefined): Promise<ModuleContentOfAssessmentSettings> {
        let url_ = this.baseUrl + "/v1/AssessmentContent/{moduleId}/Content";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ModuleContentOfAssessmentSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleContentOfAssessmentSettings.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleContentOfAssessmentSettings>(<any>null);
    }

    get(moduleId: string | null, contentId: string | null , cancelToken?: CancelToken | undefined): Promise<ModuleContentOfAssessmentSettings> {
        let url_ = this.baseUrl + "/v1/AssessmentContent/{moduleId}/Content/{contentId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ModuleContentOfAssessmentSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleContentOfAssessmentSettings.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleContentOfAssessmentSettings>(<any>null);
    }

    update(moduleId: string | null, contentId: string | null, settings: UpdateModuleContentSettingsOfAssessmentSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/AssessmentContent/{moduleId}/Content/{contentId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(moduleId: string | null, contentId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/AssessmentContent/{moduleId}/Content/{contentId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    createFromZip(moduleId: string | null, file: FileParameter | null | undefined , cancelToken?: CancelToken | undefined): Promise<ModuleContentOfAssessmentSettings> {
        let url_ = this.baseUrl + "/v1/AssessmentContent/{moduleId}/Content/FromZip";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateFromZip(_response);
        });
    }

    protected processCreateFromZip(response: AxiosResponse): Promise<ModuleContentOfAssessmentSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleContentOfAssessmentSettings.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleContentOfAssessmentSettings>(<any>null);
    }

    updateFromZip(moduleId: string | null, contentId: string | null, file: FileParameter | null | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/AssessmentContent/{moduleId}/Content/{contentId}/FromZip";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateFromZip(_response);
        });
    }

    protected processUpdateFromZip(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    publish(moduleId: string | null, contentId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/AssessmentContent/{moduleId}/Content/{contentId}/Publish";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPublish(_response);
        });
    }

    protected processPublish(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    downloadFile(moduleId: string | null, contentId: string | null, fileId: string | null , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/AssessmentContent/{moduleId}/Content/{contentId}/File/{fileId}/Download";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadFile(_response);
        });
    }

    protected processDownloadFile(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    export(moduleId: string | null, contentId: string | null , cancelToken?: CancelToken | undefined): Promise<CreateModuleContentSettingsOfAssessmentSettings> {
        let url_ = this.baseUrl + "/v1/AssessmentContent/{moduleId}/Content/{contentId}/Export";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExport(_response);
        });
    }

    protected processExport(response: AxiosResponse): Promise<CreateModuleContentSettingsOfAssessmentSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CreateModuleContentSettingsOfAssessmentSettings.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateModuleContentSettingsOfAssessmentSettings>(<any>null);
    }

    example(  cancelToken?: CancelToken | undefined): Promise<AssessmentSettings> {
        let url_ = this.baseUrl + "/v1/AssessmentContent/Example";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExample(_response);
        });
    }

    protected processExample(response: AxiosResponse): Promise<AssessmentSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AssessmentSettings.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AssessmentSettings>(<any>null);
    }

    schema(  cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/AssessmentContent/Schema";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSchema(_response);
        });
    }

    protected processSchema(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }
}

export class AssessmentSubAttemptClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param assessmentId (optional) 
     */
    getAllForActor(actorId: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined, assessmentId: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfAssessmentSubAttempt> {
        let url_ = this.baseUrl + "/v1/AssessmentSubAttempt/Actor/{actorId}?";
        if (actorId === undefined || actorId === null)
            throw new Error("The parameter 'actorId' must be defined.");
        url_ = url_.replace("{actorId}", encodeURIComponent("" + actorId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (assessmentId !== undefined && assessmentId !== null)
            url_ += "assessmentId=" + encodeURIComponent("" + assessmentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForActor(_response);
        });
    }

    protected processGetAllForActor(response: AxiosResponse): Promise<ListOfAssessmentSubAttempt> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfAssessmentSubAttempt.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfAssessmentSubAttempt>(<any>null);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param assessmentId (optional) 
     * @param actorType (optional) 
     * @param from (optional) 
     * @param to (optional) 
     */
    getAllForGroup(groupId: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined, assessmentId: string | null | undefined, actorType: ActorType | null | undefined, from: Date | null | undefined, to: Date | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfAssessmentSubAttempt> {
        let url_ = this.baseUrl + "/v1/AssessmentSubAttempt/Group/{groupId}?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (assessmentId !== undefined && assessmentId !== null)
            url_ += "assessmentId=" + encodeURIComponent("" + assessmentId) + "&";
        if (actorType !== undefined && actorType !== null)
            url_ += "actorType=" + encodeURIComponent("" + actorType) + "&";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toJSON() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForGroup(_response);
        });
    }

    protected processGetAllForGroup(response: AxiosResponse): Promise<ListOfAssessmentSubAttempt> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfAssessmentSubAttempt.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfAssessmentSubAttempt>(<any>null);
    }

    get(subAttemptId: string | null , cancelToken?: CancelToken | undefined): Promise<AssessmentSubAttempt> {
        let url_ = this.baseUrl + "/v1/AssessmentSubAttempt/{subAttemptId}";
        if (subAttemptId === undefined || subAttemptId === null)
            throw new Error("The parameter 'subAttemptId' must be defined.");
        url_ = url_.replace("{subAttemptId}", encodeURIComponent("" + subAttemptId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<AssessmentSubAttempt> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AssessmentSubAttempt.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AssessmentSubAttempt>(<any>null);
    }

    update(subAttemptId: string | null, settings: UpdateAssessmentSubAttemptSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/AssessmentSubAttempt/{subAttemptId}";
        if (subAttemptId === undefined || subAttemptId === null)
            throw new Error("The parameter 'subAttemptId' must be defined.");
        url_ = url_.replace("{subAttemptId}", encodeURIComponent("" + subAttemptId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(subAttemptId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/AssessmentSubAttempt/{subAttemptId}";
        if (subAttemptId === undefined || subAttemptId === null)
            throw new Error("The parameter 'subAttemptId' must be defined.");
        url_ = url_.replace("{subAttemptId}", encodeURIComponent("" + subAttemptId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    create(settings: CreateAssessmentSubAttemptSettings , cancelToken?: CancelToken | undefined): Promise<AssessmentSubAttempt> {
        let url_ = this.baseUrl + "/v1/AssessmentSubAttempt";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<AssessmentSubAttempt> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AssessmentSubAttempt.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AssessmentSubAttempt>(<any>null);
    }
}

export class AuthenticationClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Set authentication cookie
     */
    signIn(settings: AuthenticationSettings , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/Authentication/SignIn";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSignIn(_response);
        });
    }

    protected processSignIn(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    /**
     * Clear authentication cookie
     */
    signOut(  cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Authentication/SignOut";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSignOut(_response);
        });
    }

    protected processSignOut(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Generate a TokenModel
     */
    token(settings: AuthenticationSettings , cancelToken?: CancelToken | undefined): Promise<ChallengeToken> {
        let url_ = this.baseUrl + "/v1/Authentication/Token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processToken(_response);
        });
    }

    protected processToken(response: AxiosResponse): Promise<ChallengeToken> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ChallengeToken.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ChallengeToken>(<any>null);
    }

    refreshToken(  cancelToken?: CancelToken | undefined): Promise<Token> {
        let url_ = this.baseUrl + "/v1/Authentication/RefreshToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRefreshToken(_response);
        });
    }

    protected processRefreshToken(response: AxiosResponse): Promise<Token> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Token.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Token>(<any>null);
    }

    /**
     * Generate a TokenModel on behalf of userId
     */
    impersonate(userId: string | null , cancelToken?: CancelToken | undefined): Promise<Token> {
        let url_ = this.baseUrl + "/v1/Authentication/Impersonate/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processImpersonate(_response);
        });
    }

    protected processImpersonate(response: AxiosResponse): Promise<Token> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Token.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Token>(<any>null);
    }

    /**
     * Revert the supplied TokenModel to one with no
    impersonating data
     */
    unimpersonate(  cancelToken?: CancelToken | undefined): Promise<Token> {
        let url_ = this.baseUrl + "/v1/Authentication/Unimpersonate";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUnimpersonate(_response);
        });
    }

    protected processUnimpersonate(response: AxiosResponse): Promise<Token> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Token.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Token>(<any>null);
    }

    /**
     * Gets the Identity
     */
    identity(  cancelToken?: CancelToken | undefined): Promise<Identity> {
        let url_ = this.baseUrl + "/v1/Authentication/Identity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processIdentity(_response);
        });
    }

    protected processIdentity(response: AxiosResponse): Promise<Identity> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Identity.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Identity>(<any>null);
    }

    /**
     * Checks if the authenticated Identity has the given permission
     * @param permission (optional) The required permission
     * @param groupId (optional) The GroupId. If this is null or empty, all the current identity's
    groups will be searched.
     * @param orChildren (optional) If groupId is provided and orChildren
    is true, all child groups of groupId
    will also be checked
     * @return Returns true if the current identity is permitted
     * @deprecated
     */
    permitted(permission: string | null | undefined, groupId: string | null | undefined, orChildren: boolean | null | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/v1/Authentication/Permitted?";
        if (permission !== undefined && permission !== null)
            url_ += "permission=" + encodeURIComponent("" + permission) + "&";
        if (groupId !== undefined && groupId !== null)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        if (orChildren !== undefined && orChildren !== null)
            url_ += "orChildren=" + encodeURIComponent("" + orChildren) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPermitted(_response);
        });
    }

    protected processPermitted(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @param permission The required permission
     * @return Returns true if the current identity is permitted
     */
    permittedAll(permission: string | null, groupIds: string[] , cancelToken?: CancelToken | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/v1/Authentication/Permitted/{permission}";
        if (permission === undefined || permission === null)
            throw new Error("The parameter 'permission' must be defined.");
        url_ = url_.replace("{permission}", encodeURIComponent("" + permission));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(groupIds);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPermittedAll(_response);
        });
    }

    protected processPermittedAll(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(<any>null);
    }
}

export class CommunicationPreferencesClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(userId: string | null , cancelToken?: CancelToken | undefined): Promise<CommunicationPreferences> {
        let url_ = this.baseUrl + "/v1/CommunicationPreferences/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<CommunicationPreferences> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CommunicationPreferences.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CommunicationPreferences>(<any>null);
    }

    update(userId: string | null, settings: UpdateCommunicationPreferencesSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/CommunicationPreferences/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    unsubscribe(token: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<UnsubscribeToken> {
        let url_ = this.baseUrl + "/v1/CommunicationPreferences/Unsubscribe?";
        if (token !== undefined && token !== null)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUnsubscribe(_response);
        });
    }

    protected processUnsubscribe(response: AxiosResponse): Promise<UnsubscribeToken> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UnsubscribeToken.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UnsubscribeToken>(<any>null);
    }

    unsubscribe2(token: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<UnsubscribeToken> {
        let url_ = this.baseUrl + "/v1/CommunicationPreferences/Unsubscribe?";
        if (token !== undefined && token !== null)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUnsubscribe2(_response);
        });
    }

    protected processUnsubscribe2(response: AxiosResponse): Promise<UnsubscribeToken> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UnsubscribeToken.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UnsubscribeToken>(<any>null);
    }
}

export class EmailRegistrationClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Check if the given email is registered in the system.
     * @return 200 OK if the email is found, else a 404
     */
    get(settings: EmailSettings , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/EmailRegistration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }
}

export class GroupCommentClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param includeChildGroups (optional) 
     */
    getAll(groupId: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined, includeChildGroups: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfGroupComment> {
        let url_ = this.baseUrl + "/v1/Group/{groupId}/Comment?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (includeChildGroups === null)
            throw new Error("The parameter 'includeChildGroups' cannot be null.");
        else if (includeChildGroups !== undefined)
            url_ += "includeChildGroups=" + encodeURIComponent("" + includeChildGroups) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfGroupComment> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfGroupComment.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfGroupComment>(<any>null);
    }

    create(groupId: string | null, settings: CreateCommentSettings , cancelToken?: CancelToken | undefined): Promise<GroupComment> {
        let url_ = this.baseUrl + "/v1/Group/{groupId}/Comment";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<GroupComment> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GroupComment.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GroupComment>(<any>null);
    }

    get(groupId: string | null, commentId: string | null , cancelToken?: CancelToken | undefined): Promise<GroupComment> {
        let url_ = this.baseUrl + "/v1/Group/{groupId}/Comment/{commentId}";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<GroupComment> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GroupComment.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GroupComment>(<any>null);
    }

    update(groupId: string | null, commentId: string | null, settings: UpdateCommentSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Group/{groupId}/Comment/{commentId}";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(groupId: string | null, commentId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Group/{groupId}/Comment/{commentId}";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAllReplies(groupId: string | null, commentId: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfComment> {
        let url_ = this.baseUrl + "/v1/Group/{groupId}/Comment/{commentId}/Reply?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllReplies(_response);
        });
    }

    protected processGetAllReplies(response: AxiosResponse): Promise<ListOfComment> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfComment.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfComment>(<any>null);
    }
}

export class GroupClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(groupId: string | null , cancelToken?: CancelToken | undefined): Promise<Group> {
        let url_ = this.baseUrl + "/v1/Group/{groupId}";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Group> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Group.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Group>(<any>null);
    }
}

export class GroupFileClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param includeChildGroups (optional) 
     */
    getAll(groupId: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined, includeChildGroups: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfGroupFile> {
        let url_ = this.baseUrl + "/v1/Group/{groupId}/File?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (includeChildGroups === null)
            throw new Error("The parameter 'includeChildGroups' cannot be null.");
        else if (includeChildGroups !== undefined)
            url_ += "includeChildGroups=" + encodeURIComponent("" + includeChildGroups) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfGroupFile> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfGroupFile.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfGroupFile>(<any>null);
    }

    create(groupId: string | null, settings: CreateFileSettings , cancelToken?: CancelToken | undefined): Promise<GroupFile> {
        let url_ = this.baseUrl + "/v1/Group/{groupId}/File";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<GroupFile> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GroupFile.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GroupFile>(<any>null);
    }

    get(groupId: string | null, fileId: string | null , cancelToken?: CancelToken | undefined): Promise<GroupFile> {
        let url_ = this.baseUrl + "/v1/Group/{groupId}/File/{fileId}";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<GroupFile> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GroupFile.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GroupFile>(<any>null);
    }

    update(groupId: string | null, fileId: string | null, settings: UpdateFileSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Group/{groupId}/File/{fileId}";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(groupId: string | null, fileId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Group/{groupId}/File/{fileId}";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    download(groupId: string | null, fileId: string | null , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/Group/{groupId}/File/{fileId}/Download";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownload(_response);
        });
    }

    protected processDownload(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }
}

export class JobTypeClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAll(search: string | null | undefined, skip: number | undefined, take: number | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfJobType> {
        let url_ = this.baseUrl + "/v1/JobType?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfJobType> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfJobType.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfJobType>(<any>null);
    }

    create(settings: CreateJobTypeSettings , cancelToken?: CancelToken | undefined): Promise<JobType> {
        let url_ = this.baseUrl + "/v1/JobType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<JobType> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JobType.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JobType>(<any>null);
    }

    get(jobTypeId: string | null , cancelToken?: CancelToken | undefined): Promise<JobType> {
        let url_ = this.baseUrl + "/v1/JobType/{jobTypeId}";
        if (jobTypeId === undefined || jobTypeId === null)
            throw new Error("The parameter 'jobTypeId' must be defined.");
        url_ = url_.replace("{jobTypeId}", encodeURIComponent("" + jobTypeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<JobType> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JobType.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JobType>(<any>null);
    }

    update(jobTypeId: string | null, settings: UpdateJobTypeSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/JobType/{jobTypeId}";
        if (jobTypeId === undefined || jobTypeId === null)
            throw new Error("The parameter 'jobTypeId' must be defined.");
        url_ = url_.replace("{jobTypeId}", encodeURIComponent("" + jobTypeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(jobTypeId: string | null, version: number | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/JobType/{jobTypeId}?";
        if (jobTypeId === undefined || jobTypeId === null)
            throw new Error("The parameter 'jobTypeId' must be defined.");
        url_ = url_.replace("{jobTypeId}", encodeURIComponent("" + jobTypeId));
        if (version === null)
            throw new Error("The parameter 'version' cannot be null.");
        else if (version !== undefined)
            url_ += "version=" + encodeURIComponent("" + version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class LabelClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAllForGroup(groupId: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfLabel> {
        let url_ = this.baseUrl + "/v1/Label/Group/{groupId}?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForGroup(_response);
        });
    }

    protected processGetAllForGroup(response: AxiosResponse): Promise<ListOfLabel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfLabel.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfLabel>(<any>null);
    }

    get(labelId: string | null , cancelToken?: CancelToken | undefined): Promise<Label> {
        let url_ = this.baseUrl + "/v1/Label/{labelId}";
        if (labelId === undefined || labelId === null)
            throw new Error("The parameter 'labelId' must be defined.");
        url_ = url_.replace("{labelId}", encodeURIComponent("" + labelId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Label> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Label.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Label>(<any>null);
    }

    update(labelId: string | null, settings: UpdateLabelSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Label/{labelId}";
        if (labelId === undefined || labelId === null)
            throw new Error("The parameter 'labelId' must be defined.");
        url_ = url_.replace("{labelId}", encodeURIComponent("" + labelId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(labelId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Label/{labelId}";
        if (labelId === undefined || labelId === null)
            throw new Error("The parameter 'labelId' must be defined.");
        url_ = url_.replace("{labelId}", encodeURIComponent("" + labelId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    create(settings: CreateLabelSettings , cancelToken?: CancelToken | undefined): Promise<Label> {
        let url_ = this.baseUrl + "/v1/Label";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Label> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Label.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Label>(<any>null);
    }
}

export class MemberClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param status (optional) 
     * @param jobTypeIds (optional) 
     * @param jobCategories (optional) 
     * @param roles (optional) 
     * @param includeDeactivated (optional) 
     */
    getAllForGroup(groupId: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined, status: MemberStatus | null | undefined, jobTypeIds: string[] | null | undefined, jobCategories: string[] | null | undefined, roles: string[] | null | undefined, includeDeactivated: boolean | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfMember> {
        let url_ = this.baseUrl + "/v1/Member/Group/{groupId}?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (status !== undefined && status !== null)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (jobTypeIds !== undefined && jobTypeIds !== null)
            jobTypeIds && jobTypeIds.forEach(item => { url_ += "jobTypeIds=" + encodeURIComponent("" + item) + "&"; });
        if (jobCategories !== undefined && jobCategories !== null)
            jobCategories && jobCategories.forEach(item => { url_ += "jobCategories=" + encodeURIComponent("" + item) + "&"; });
        if (roles !== undefined && roles !== null)
            roles && roles.forEach(item => { url_ += "roles=" + encodeURIComponent("" + item) + "&"; });
        if (includeDeactivated !== undefined && includeDeactivated !== null)
            url_ += "includeDeactivated=" + encodeURIComponent("" + includeDeactivated) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForGroup(_response);
        });
    }

    protected processGetAllForGroup(response: AxiosResponse): Promise<ListOfMember> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfMember.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfMember>(<any>null);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param status (optional) 
     * @param jobTypeIds (optional) 
     * @param jobCategories (optional) 
     * @param memberRoles (optional) 
     * @param identityPermission (optional) 
     * @param includeDeactivated (optional) 
     */
    getAllForChildGroups(groupId: string | null, childGroupType: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined, status: MemberStatus | null | undefined, jobTypeIds: string[] | null | undefined, jobCategories: string[] | null | undefined, memberRoles: string[] | null | undefined, identityPermission: string | null | undefined, includeDeactivated: boolean | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfMember> {
        let url_ = this.baseUrl + "/v1/Member/Group/{groupId}/Child/{childGroupType}?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (childGroupType === undefined || childGroupType === null)
            throw new Error("The parameter 'childGroupType' must be defined.");
        url_ = url_.replace("{childGroupType}", encodeURIComponent("" + childGroupType));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (status !== undefined && status !== null)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (jobTypeIds !== undefined && jobTypeIds !== null)
            jobTypeIds && jobTypeIds.forEach(item => { url_ += "jobTypeIds=" + encodeURIComponent("" + item) + "&"; });
        if (jobCategories !== undefined && jobCategories !== null)
            jobCategories && jobCategories.forEach(item => { url_ += "jobCategories=" + encodeURIComponent("" + item) + "&"; });
        if (memberRoles !== undefined && memberRoles !== null)
            memberRoles && memberRoles.forEach(item => { url_ += "memberRoles=" + encodeURIComponent("" + item) + "&"; });
        if (identityPermission !== undefined && identityPermission !== null)
            url_ += "identityPermission=" + encodeURIComponent("" + identityPermission) + "&";
        if (includeDeactivated !== undefined && includeDeactivated !== null)
            url_ += "includeDeactivated=" + encodeURIComponent("" + includeDeactivated) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForChildGroups(_response);
        });
    }

    protected processGetAllForChildGroups(response: AxiosResponse): Promise<ListOfMember> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfMember.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfMember>(<any>null);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param status (optional) 
     */
    getAllForUser(userId: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined, status: MemberStatus | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfMember> {
        let url_ = this.baseUrl + "/v1/Member/User/{userId}?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (status !== undefined && status !== null)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForUser(_response);
        });
    }

    protected processGetAllForUser(response: AxiosResponse): Promise<ListOfMember> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfMember.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfMember>(<any>null);
    }

    /**
     * Gets the list of users in a group at the given time.
     * @param groupId Id of the group to get the users from.
     * @param at (optional) The UTC time at which to get users. If not specified, the current time is used.
     * @param status (optional) The status used to filter the result.
     * @param role (optional) The role used to filter the result
     * @return The list of users with their membership status and roles within the group at the given time.
     */
    getAllGroupHistory(groupId: string | null, at: Date | null | undefined, status: MemberStatus | null | undefined, role: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<MemberHistory[]> {
        let url_ = this.baseUrl + "/v1/Member/Group/{groupId}/History?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (at !== undefined && at !== null)
            url_ += "at=" + encodeURIComponent(at ? "" + at.toJSON() : "") + "&";
        if (status !== undefined && status !== null)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (role !== undefined && role !== null)
            url_ += "role=" + encodeURIComponent("" + role) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllGroupHistory(_response);
        });
    }

    protected processGetAllGroupHistory(response: AxiosResponse): Promise<MemberHistory[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MemberHistory.fromJS(item));
            }
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MemberHistory[]>(<any>null);
    }

    get(groupId: string | null, userId: string | null , cancelToken?: CancelToken | undefined): Promise<Member> {
        let url_ = this.baseUrl + "/v1/Member/Group/{groupId}/User/{userId}";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Member> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Member.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Member>(<any>null);
    }

    add(groupId: string | null, userId: string | null, settings: AddGroupMemberSettings , cancelToken?: CancelToken | undefined): Promise<Member> {
        let url_ = this.baseUrl + "/v1/Member/Group/{groupId}/User/{userId}/Add";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAdd(_response);
        });
    }

    protected processAdd(response: AxiosResponse): Promise<Member> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Member.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Member>(<any>null);
    }

    join(groupId: string | null , cancelToken?: CancelToken | undefined): Promise<Member> {
        let url_ = this.baseUrl + "/v1/Member/Group/{groupId}/User/Join";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processJoin(_response);
        });
    }

    protected processJoin(response: AxiosResponse): Promise<Member> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Member.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Member>(<any>null);
    }

    update(groupId: string | null, userId: string | null, settings: UpdateGroupMemberSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Member/Group/{groupId}/User/{userId}/Update";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    remove(groupId: string | null, userId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Member/Group/{groupId}/User/{userId}/Remove";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "PUT",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRemove(_response);
        });
    }

    protected processRemove(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    ban(groupId: string | null, userId: string | null, reason: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Member/Group/{groupId}/User/{userId}/Ban?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (reason !== undefined && reason !== null)
            url_ += "reason=" + encodeURIComponent("" + reason) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "PUT",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBan(_response);
        });
    }

    protected processBan(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    leave(groupId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Member/Group/{groupId}/User/Leave";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "PUT",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLeave(_response);
        });
    }

    protected processLeave(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    acceptGroupInvitation(invitationId: string | null , cancelToken?: CancelToken | undefined): Promise<Member> {
        let url_ = this.baseUrl + "/v1/Member/GroupInvitation/{invitationId}/Accept";
        if (invitationId === undefined || invitationId === null)
            throw new Error("The parameter 'invitationId' must be defined.");
        url_ = url_.replace("{invitationId}", encodeURIComponent("" + invitationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAcceptGroupInvitation(_response);
        });
    }

    protected processAcceptGroupInvitation(response: AxiosResponse): Promise<Member> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Member.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Member>(<any>null);
    }

    emailAll(groupId: string | null | undefined, message: string | null | undefined, role: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Member/Email?";
        if (groupId !== undefined && groupId !== null)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        if (message !== undefined && message !== null)
            url_ += "message=" + encodeURIComponent("" + message) + "&";
        if (role !== undefined && role !== null)
            url_ += "role=" + encodeURIComponent("" + role) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEmailAll(_response);
        });
    }

    protected processEmailAll(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    email(groupId: string | null, userId: string | null, message: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Member/Group/{groupId}/User/{userId}/Email?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (message !== undefined && message !== null)
            url_ += "message=" + encodeURIComponent("" + message) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEmail(_response);
        });
    }

    protected processEmail(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class OrganisationAccessTokenClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param organisationId (optional) 
     */
    getAll(search: string | null | undefined, skip: number | undefined, take: number | undefined, organisationId: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfOrganisationAccessToken> {
        let url_ = this.baseUrl + "/v1/OrganisationAccessToken?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (organisationId !== undefined && organisationId !== null)
            url_ += "organisationId=" + encodeURIComponent("" + organisationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfOrganisationAccessToken> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfOrganisationAccessToken.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfOrganisationAccessToken>(<any>null);
    }

    create(settings: CreateOrganisationAccessTokenSettings , cancelToken?: CancelToken | undefined): Promise<OrganisationAccessToken> {
        let url_ = this.baseUrl + "/v1/OrganisationAccessToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<OrganisationAccessToken> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OrganisationAccessToken.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrganisationAccessToken>(<any>null);
    }

    getAll2(tokenId: string | null , cancelToken?: CancelToken | undefined): Promise<OrganisationAccessToken> {
        let url_ = this.baseUrl + "/v1/OrganisationAccessToken/{tokenId}";
        if (tokenId === undefined || tokenId === null)
            throw new Error("The parameter 'tokenId' must be defined.");
        url_ = url_.replace("{tokenId}", encodeURIComponent("" + tokenId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll2(_response);
        });
    }

    protected processGetAll2(response: AxiosResponse): Promise<OrganisationAccessToken> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OrganisationAccessToken.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrganisationAccessToken>(<any>null);
    }

    delete(tokenId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/OrganisationAccessToken/{tokenId}";
        if (tokenId === undefined || tokenId === null)
            throw new Error("The parameter 'tokenId' must be defined.");
        url_ = url_.replace("{tokenId}", encodeURIComponent("" + tokenId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class OrganisationClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param identityPermissions (optional) 
     */
    getAll(search: string | null | undefined, skip: number | undefined, take: number | undefined, identityPermissions: string[] | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfOrganisation> {
        let url_ = this.baseUrl + "/v1/Organisation?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (identityPermissions !== undefined && identityPermissions !== null)
            identityPermissions && identityPermissions.forEach(item => { url_ += "identityPermissions=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfOrganisation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfOrganisation.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfOrganisation>(<any>null);
    }

    create(settings: CreateOrganisationSettings , cancelToken?: CancelToken | undefined): Promise<Organisation> {
        let url_ = this.baseUrl + "/v1/Organisation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Organisation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Organisation.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Organisation>(<any>null);
    }

    get(organisationId: string | null , cancelToken?: CancelToken | undefined): Promise<Organisation> {
        let url_ = this.baseUrl + "/v1/Organisation/{organisationId}";
        if (organisationId === undefined || organisationId === null)
            throw new Error("The parameter 'organisationId' must be defined.");
        url_ = url_.replace("{organisationId}", encodeURIComponent("" + organisationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Organisation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Organisation.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Organisation>(<any>null);
    }

    update(organisationId: string | null, settings: UpdateOrganisationSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Organisation/{organisationId}";
        if (organisationId === undefined || organisationId === null)
            throw new Error("The parameter 'organisationId' must be defined.");
        url_ = url_.replace("{organisationId}", encodeURIComponent("" + organisationId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(organisationId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Organisation/{organisationId}";
        if (organisationId === undefined || organisationId === null)
            throw new Error("The parameter 'organisationId' must be defined.");
        url_ = url_.replace("{organisationId}", encodeURIComponent("" + organisationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class PasswordClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(userId: string | null , cancelToken?: CancelToken | undefined): Promise<Password> {
        let url_ = this.baseUrl + "/v1/Password/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Password> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Password.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Password>(<any>null);
    }

    update(userId: string | null, settings: UpdatePasswordSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Password/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    updateTwoFactorAuthentication(userId: string | null, settings: UpdateTwoFactorAuthenticationSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Password/{userId}/UpdateTwoFactorAuthentication";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateTwoFactorAuthentication(_response);
        });
    }

    protected processUpdateTwoFactorAuthentication(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    requestReset(settings: RequestResetPasswordSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Password/RequestReset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRequestReset(_response);
        });
    }

    protected processRequestReset(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    reset(settings: ResetPasswordSettings , cancelToken?: CancelToken | undefined): Promise<Token> {
        let url_ = this.baseUrl + "/v1/Password/Reset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReset(_response);
        });
    }

    protected processReset(response: AxiosResponse): Promise<Token> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Token.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Token>(<any>null);
    }
}

export class PhoneNumberRegistrationClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Check if the phoneNumber is registered in the system
     * @return 200 OK if the phoneNumber is found, else a 404
     */
    get(phoneNumber: string | null , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/PhoneNumberRegistration/{phoneNumber}";
        if (phoneNumber === undefined || phoneNumber === null)
            throw new Error("The parameter 'phoneNumber' must be defined.");
        url_ = url_.replace("{phoneNumber}", encodeURIComponent("" + phoneNumber));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }
}

export class RoleClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAll(groupType: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfRole> {
        let url_ = this.baseUrl + "/v1/Role?";
        if (groupType !== undefined && groupType !== null)
            url_ += "groupType=" + encodeURIComponent("" + groupType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfRole> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfRole.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfRole>(<any>null);
    }

    get(roleName: string | null , cancelToken?: CancelToken | undefined): Promise<Role> {
        let url_ = this.baseUrl + "/v1/Role/{roleName}";
        if (roleName === undefined || roleName === null)
            throw new Error("The parameter 'roleName' must be defined.");
        url_ = url_.replace("{roleName}", encodeURIComponent("" + roleName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Role> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Role.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Role>(<any>null);
    }
}

export class TeamClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param organisationId (optional) 
     * @param identityPermissions (optional) 
     */
    getAll(search: string | null | undefined, skip: number | undefined, take: number | undefined, organisationId: string | null | undefined, identityPermissions: string[] | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfTeam> {
        let url_ = this.baseUrl + "/v1/Team?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (organisationId !== undefined && organisationId !== null)
            url_ += "organisationId=" + encodeURIComponent("" + organisationId) + "&";
        if (identityPermissions !== undefined && identityPermissions !== null)
            identityPermissions && identityPermissions.forEach(item => { url_ += "identityPermissions=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfTeam> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfTeam.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfTeam>(<any>null);
    }

    create(settings: CreateTeamSettings , cancelToken?: CancelToken | undefined): Promise<Team> {
        let url_ = this.baseUrl + "/v1/Team";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Team> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Team.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Team>(<any>null);
    }

    get(teamId: string | null , cancelToken?: CancelToken | undefined): Promise<Team> {
        let url_ = this.baseUrl + "/v1/Team/{teamId}";
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Team> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Team.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Team>(<any>null);
    }

    update(teamId: string | null, settings: UpdateTeamSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Team/{teamId}";
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(teamId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Team/{teamId}";
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class UserActivityClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param moduleType (optional) 
     * @param programId (optional) 
     * @param from (optional) 
     * @param to (optional) 
     */
    getAllForGroup(groupId: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined, moduleType: string | null | undefined, programId: string | null | undefined, from: Date | null | undefined, to: Date | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfUserActivity> {
        let url_ = this.baseUrl + "/v1/UserActivity/Group/{groupId}?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (moduleType !== undefined && moduleType !== null)
            url_ += "moduleType=" + encodeURIComponent("" + moduleType) + "&";
        if (programId !== undefined && programId !== null)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toJSON() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForGroup(_response);
        });
    }

    protected processGetAllForGroup(response: AxiosResponse): Promise<ListOfUserActivity> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfUserActivity.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfUserActivity>(<any>null);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param moduleType (optional) 
     * @param programId (optional) 
     * @param from (optional) 
     * @param to (optional) 
     */
    getAllForPublisher(publisherId: string | null, search: string | null | undefined, skip: number | undefined, take: number | undefined, moduleType: string | null | undefined, programId: string | null | undefined, from: Date | null | undefined, to: Date | null | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfUserActivity> {
        let url_ = this.baseUrl + "/v1/UserActivity/Publisher/{publisherId}?";
        if (publisherId === undefined || publisherId === null)
            throw new Error("The parameter 'publisherId' must be defined.");
        url_ = url_.replace("{publisherId}", encodeURIComponent("" + publisherId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (moduleType !== undefined && moduleType !== null)
            url_ += "moduleType=" + encodeURIComponent("" + moduleType) + "&";
        if (programId !== undefined && programId !== null)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toJSON() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForPublisher(_response);
        });
    }

    protected processGetAllForPublisher(response: AxiosResponse): Promise<ListOfUserActivity> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfUserActivity.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfUserActivity>(<any>null);
    }
}

export class UserClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAll(search: string | null | undefined, skip: number | undefined, take: number | undefined , cancelToken?: CancelToken | undefined): Promise<ListOfUser> {
        let url_ = this.baseUrl + "/v1/User?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfUser> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfUser.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfUser>(<any>null);
    }

    create(settings: CreateUserSettings , cancelToken?: CancelToken | undefined): Promise<User> {
        let url_ = this.baseUrl + "/v1/User";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<User> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = User.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<User>(<any>null);
    }

    get(userId: string | null , cancelToken?: CancelToken | undefined): Promise<User> {
        let url_ = this.baseUrl + "/v1/User/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<User> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = User.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<User>(<any>null);
    }

    update(userId: string | null, settings: UpdateUserSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/User/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(userId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/User/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    onboard(settings: OnboardUserSettings , cancelToken?: CancelToken | undefined): Promise<User> {
        let url_ = this.baseUrl + "/v1/User/Onboard";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOnboard(_response);
        });
    }

    protected processOnboard(response: AxiosResponse): Promise<User> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = User.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<User>(<any>null);
    }

    activate(userId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/User/{userId}/Activate";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processActivate(_response);
        });
    }

    protected processActivate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    merge(settings: MergeUserSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/User/Merge";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMerge(_response);
        });
    }

    protected processMerge(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    contact(userId: string | null, message: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/User/{userId}/Contact?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (message !== undefined && message !== null)
            url_ += "message=" + encodeURIComponent("" + message) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processContact(_response);
        });
    }

    protected processContact(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    sendWelcomeEmail(userId: string | null, settings: SendWelcomeEmailSettings , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/User/{userId}/SendWelcomeEmail";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSendWelcomeEmail(_response);
        });
    }

    protected processSendWelcomeEmail(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    welcomeEmailTemplate(userName: string | null | undefined, userEmail: string | null | undefined, creatorName: string | null | undefined, message_CreatorName: string | null | undefined, message_CreatorImageUri: string | null | undefined, message_CreatorDescription: string | null | undefined, message_Message: string | null | undefined, welcomeButtonUri: string | null | undefined, welcomeButtonText: string | null | undefined, group_Title: string | null | undefined, group_ImageUri: string | null | undefined, group_Uri: string | null | undefined, group_Description: string | null | undefined, group_Subtitle: string | null | undefined, group_SubtitleImageUri: string | null | undefined, group_ActionButton: string | null | undefined, group_ActionUri: string | null | undefined, applicationName: string | null | undefined, productName: string | null | undefined, supportUri: string | null | undefined, termOfServiceUri: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/User/WelcomeEmailTemplate?";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (userEmail !== undefined && userEmail !== null)
            url_ += "UserEmail=" + encodeURIComponent("" + userEmail) + "&";
        if (creatorName !== undefined && creatorName !== null)
            url_ += "CreatorName=" + encodeURIComponent("" + creatorName) + "&";
        if (message_CreatorName !== undefined && message_CreatorName !== null)
            url_ += "Message.CreatorName=" + encodeURIComponent("" + message_CreatorName) + "&";
        if (message_CreatorImageUri !== undefined && message_CreatorImageUri !== null)
            url_ += "Message.CreatorImageUri=" + encodeURIComponent("" + message_CreatorImageUri) + "&";
        if (message_CreatorDescription !== undefined && message_CreatorDescription !== null)
            url_ += "Message.CreatorDescription=" + encodeURIComponent("" + message_CreatorDescription) + "&";
        if (message_Message !== undefined && message_Message !== null)
            url_ += "Message.Message=" + encodeURIComponent("" + message_Message) + "&";
        if (welcomeButtonUri !== undefined && welcomeButtonUri !== null)
            url_ += "WelcomeButtonUri=" + encodeURIComponent("" + welcomeButtonUri) + "&";
        if (welcomeButtonText !== undefined && welcomeButtonText !== null)
            url_ += "WelcomeButtonText=" + encodeURIComponent("" + welcomeButtonText) + "&";
        if (group_Title !== undefined && group_Title !== null)
            url_ += "Group.Title=" + encodeURIComponent("" + group_Title) + "&";
        if (group_ImageUri !== undefined && group_ImageUri !== null)
            url_ += "Group.ImageUri=" + encodeURIComponent("" + group_ImageUri) + "&";
        if (group_Uri !== undefined && group_Uri !== null)
            url_ += "Group.Uri=" + encodeURIComponent("" + group_Uri) + "&";
        if (group_Description !== undefined && group_Description !== null)
            url_ += "Group.Description=" + encodeURIComponent("" + group_Description) + "&";
        if (group_Subtitle !== undefined && group_Subtitle !== null)
            url_ += "Group.Subtitle=" + encodeURIComponent("" + group_Subtitle) + "&";
        if (group_SubtitleImageUri !== undefined && group_SubtitleImageUri !== null)
            url_ += "Group.SubtitleImageUri=" + encodeURIComponent("" + group_SubtitleImageUri) + "&";
        if (group_ActionButton !== undefined && group_ActionButton !== null)
            url_ += "Group.ActionButton=" + encodeURIComponent("" + group_ActionButton) + "&";
        if (group_ActionUri !== undefined && group_ActionUri !== null)
            url_ += "Group.ActionUri=" + encodeURIComponent("" + group_ActionUri) + "&";
        if (applicationName !== undefined && applicationName !== null)
            url_ += "ApplicationName=" + encodeURIComponent("" + applicationName) + "&";
        if (productName !== undefined && productName !== null)
            url_ += "ProductName=" + encodeURIComponent("" + productName) + "&";
        if (supportUri !== undefined && supportUri !== null)
            url_ += "SupportUri=" + encodeURIComponent("" + supportUri) + "&";
        if (termOfServiceUri !== undefined && termOfServiceUri !== null)
            url_ += "TermOfServiceUri=" + encodeURIComponent("" + termOfServiceUri) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processWelcomeEmailTemplate(_response);
        });
    }

    protected processWelcomeEmailTemplate(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    contactEmailTemplate(userName: string | null | undefined, creatorEmail: string | null | undefined, creatorName: string | null | undefined, message_CreatorName: string | null | undefined, message_CreatorImageUri: string | null | undefined, message_CreatorDescription: string | null | undefined, message_Message: string | null | undefined, group_Title: string | null | undefined, group_ImageUri: string | null | undefined, group_Uri: string | null | undefined, group_Description: string | null | undefined, group_Subtitle: string | null | undefined, group_SubtitleImageUri: string | null | undefined, group_ActionButton: string | null | undefined, group_ActionUri: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/User/ContactEmailTemplate?";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (creatorEmail !== undefined && creatorEmail !== null)
            url_ += "CreatorEmail=" + encodeURIComponent("" + creatorEmail) + "&";
        if (creatorName !== undefined && creatorName !== null)
            url_ += "CreatorName=" + encodeURIComponent("" + creatorName) + "&";
        if (message_CreatorName !== undefined && message_CreatorName !== null)
            url_ += "Message.CreatorName=" + encodeURIComponent("" + message_CreatorName) + "&";
        if (message_CreatorImageUri !== undefined && message_CreatorImageUri !== null)
            url_ += "Message.CreatorImageUri=" + encodeURIComponent("" + message_CreatorImageUri) + "&";
        if (message_CreatorDescription !== undefined && message_CreatorDescription !== null)
            url_ += "Message.CreatorDescription=" + encodeURIComponent("" + message_CreatorDescription) + "&";
        if (message_Message !== undefined && message_Message !== null)
            url_ += "Message.Message=" + encodeURIComponent("" + message_Message) + "&";
        if (group_Title !== undefined && group_Title !== null)
            url_ += "Group.Title=" + encodeURIComponent("" + group_Title) + "&";
        if (group_ImageUri !== undefined && group_ImageUri !== null)
            url_ += "Group.ImageUri=" + encodeURIComponent("" + group_ImageUri) + "&";
        if (group_Uri !== undefined && group_Uri !== null)
            url_ += "Group.Uri=" + encodeURIComponent("" + group_Uri) + "&";
        if (group_Description !== undefined && group_Description !== null)
            url_ += "Group.Description=" + encodeURIComponent("" + group_Description) + "&";
        if (group_Subtitle !== undefined && group_Subtitle !== null)
            url_ += "Group.Subtitle=" + encodeURIComponent("" + group_Subtitle) + "&";
        if (group_SubtitleImageUri !== undefined && group_SubtitleImageUri !== null)
            url_ += "Group.SubtitleImageUri=" + encodeURIComponent("" + group_SubtitleImageUri) + "&";
        if (group_ActionButton !== undefined && group_ActionButton !== null)
            url_ += "Group.ActionButton=" + encodeURIComponent("" + group_ActionButton) + "&";
        if (group_ActionUri !== undefined && group_ActionUri !== null)
            url_ += "Group.ActionUri=" + encodeURIComponent("" + group_ActionUri) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processContactEmailTemplate(_response);
        });
    }

    protected processContactEmailTemplate(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }
}

export class UserEmailClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(userId: string | null , cancelToken?: CancelToken | undefined): Promise<UserEmails> {
        let url_ = this.baseUrl + "/v1/UserEmail/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<UserEmails> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserEmails.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserEmails>(<any>null);
    }

    add(userId: string | null, settings: UserEmailSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/UserEmail/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAdd(_response);
        });
    }

    protected processAdd(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    remove(userId: string | null, settings: UserEmailSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/UserEmail/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "DELETE",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRemove(_response);
        });
    }

    protected processRemove(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    changePrimary(userId: string | null, settings: UserEmailSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/UserEmail/{userId}/ChangePrimary";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangePrimary(_response);
        });
    }

    protected processChangePrimary(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    sendVerification(userId: string | null, settings: UserEmailSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/UserEmail/{userId}/SendVerification";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSendVerification(_response);
        });
    }

    protected processSendVerification(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    verify(verificationToken: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<UserEmailVerificationToken> {
        let url_ = this.baseUrl + "/v1/UserEmail/Verify?";
        if (verificationToken !== undefined && verificationToken !== null)
            url_ += "verificationToken=" + encodeURIComponent("" + verificationToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVerify(_response);
        });
    }

    protected processVerify(response: AxiosResponse): Promise<UserEmailVerificationToken> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserEmailVerificationToken.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserEmailVerificationToken>(<any>null);
    }

    verify2(verificationToken: string | null , cancelToken?: CancelToken | undefined): Promise<UserEmailVerificationToken> {
        let url_ = this.baseUrl + "/v1/UserEmail/Verify/{verificationToken}";
        if (verificationToken === undefined || verificationToken === null)
            throw new Error("The parameter 'verificationToken' must be defined.");
        url_ = url_.replace("{verificationToken}", encodeURIComponent("" + verificationToken));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVerify2(_response);
        });
    }

    protected processVerify2(response: AxiosResponse): Promise<UserEmailVerificationToken> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserEmailVerificationToken.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserEmailVerificationToken>(<any>null);
    }

    contact(userId: string | null, message: string | null | undefined, groupId: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/UserEmail/{userId}/Contact?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (message !== undefined && message !== null)
            url_ += "message=" + encodeURIComponent("" + message) + "&";
        if (groupId !== undefined && groupId !== null)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processContact(_response);
        });
    }

    protected processContact(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class UserPhoneNumberClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(userId: string | null , cancelToken?: CancelToken | undefined): Promise<UserPhoneNumber> {
        let url_ = this.baseUrl + "/v1/UserPhoneNumber/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<UserPhoneNumber> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserPhoneNumber.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserPhoneNumber>(<any>null);
    }

    update(userId: string | null, settings: UpdateUserPhoneNumberSettings , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/UserPhoneNumber/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    sendVerification(userId: string | null , cancelToken?: CancelToken | undefined): Promise<VerificationRequestResult> {
        let url_ = this.baseUrl + "/v1/UserPhoneNumber/{userId}/SendVerification";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSendVerification(_response);
        });
    }

    protected processSendVerification(response: AxiosResponse): Promise<VerificationRequestResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = VerificationRequestResult.fromJS(resultData200);
            return result200;
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<VerificationRequestResult>(<any>null);
    }

    verify(verificationCode: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/UserPhoneNumber/Verify/{verificationCode}";
        if (verificationCode === undefined || verificationCode === null)
            throw new Error("The parameter 'verificationCode' must be defined.");
        url_ = url_.replace("{verificationCode}", encodeURIComponent("" + verificationCode));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVerify(_response);
        });
    }

    protected processVerify(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);
        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class ListOfEmail implements IListOfEmail {
    totalItemCount!: number;
    items!: Email[];

    constructor(data?: IListOfEmail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Email.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfEmail {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfEmail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfEmail {
    totalItemCount: number;
    items: Email[];
}

export class Email implements IEmail {
    id?: string | undefined;
    type?: EmailType;
    from?: EmailAddress | undefined;
    replyTo?: EmailAddress | undefined;
    to?: EmailAddress[] | undefined;
    subject?: string | undefined;
    bodyHtml?: string | undefined;
    created?: Date;
    modified?: Date;
    status?: EmailStatus;

    constructor(data?: IEmail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.from = _data["from"] ? EmailAddress.fromJS(_data["from"]) : <any>undefined;
            this.replyTo = _data["replyTo"] ? EmailAddress.fromJS(_data["replyTo"]) : <any>undefined;
            if (Array.isArray(_data["to"])) {
                this.to = [] as any;
                for (let item of _data["to"])
                    this.to!.push(EmailAddress.fromJS(item));
            }
            this.subject = _data["subject"];
            this.bodyHtml = _data["bodyHtml"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): Email {
        data = typeof data === 'object' ? data : {};
        let result = new Email();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["from"] = this.from ? this.from.toJSON() : <any>undefined;
        data["replyTo"] = this.replyTo ? this.replyTo.toJSON() : <any>undefined;
        if (Array.isArray(this.to)) {
            data["to"] = [];
            for (let item of this.to)
                data["to"].push(item.toJSON());
        }
        data["subject"] = this.subject;
        data["bodyHtml"] = this.bodyHtml;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }
}

export interface IEmail {
    id?: string | undefined;
    type?: EmailType;
    from?: EmailAddress | undefined;
    replyTo?: EmailAddress | undefined;
    to?: EmailAddress[] | undefined;
    subject?: string | undefined;
    bodyHtml?: string | undefined;
    created?: Date;
    modified?: Date;
    status?: EmailStatus;
}

export enum EmailType {
    None = "None",
    EventInvite = "EventInvite",
    EventChanged = "EventChanged",
    ScheduledLink = "ScheduledLink",
    RequestSurvey = "RequestSurvey",
    AddedToGroup = "AddedToGroup",
    AddedToClass = "AddedToClass",
    ModuleAttempt = "ModuleAttempt",
    Authentication = "Authentication",
    Confirm = "Confirm",
    ContactUser = "ContactUser",
    PublishingRequested = "PublishingRequested",
    PublishingRequestApproved = "PublishingRequestApproved",
    PublishingRequestRejected = "PublishingRequestRejected",
    RequestResetPassword = "RequestResetPassword",
    Welcome = "Welcome",
    Support = "Support",
    SupportConfirmation = "SupportConfirmation",
    SupportStatusChanged = "SupportStatusChanged",
    RequestResetPasswordFailed = "RequestResetPasswordFailed",
    PasswordChanged = "PasswordChanged",
    PrimaryEmailChanged = "PrimaryEmailChanged",
}

export class EmailAddress implements IEmailAddress {
    address?: string | undefined;
    name?: string | undefined;

    constructor(data?: IEmailAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.address = _data["address"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): EmailAddress {
        data = typeof data === 'object' ? data : {};
        let result = new EmailAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address;
        data["name"] = this.name;
        return data; 
    }
}

export interface IEmailAddress {
    address?: string | undefined;
    name?: string | undefined;
}

/** 0 = None 1 = Submitted 2 = Received 3 = Read 4 = Clicked 5 = Spammed 6 = Error */
export enum EmailStatus {
    None = 0,
    Submitted = 1,
    Received = 2,
    Read = 3,
    Clicked = 4,
    Spammed = 5,
    Error = 6,
}

export class ListOfUserAttendance implements IListOfUserAttendance {
    totalItemCount!: number;
    items!: UserAttendance[];

    constructor(data?: IListOfUserAttendance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserAttendance.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfUserAttendance {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfUserAttendance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfUserAttendance {
    totalItemCount: number;
    items: UserAttendance[];
}

export class Attendance implements IAttendance {
    id?: string | undefined;
    memberId?: string | undefined;
    status?: AttendanceStatus;
    created?: Date;
    modified?: Date;
    version?: number;

    constructor(data?: IAttendance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.memberId = _data["memberId"];
            this.status = _data["status"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): Attendance {
        data = typeof data === 'object' ? data : {};
        let result = new Attendance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["memberId"] = this.memberId;
        data["status"] = this.status;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        data["version"] = this.version;
        return data; 
    }
}

export interface IAttendance {
    id?: string | undefined;
    memberId?: string | undefined;
    status?: AttendanceStatus;
    created?: Date;
    modified?: Date;
    version?: number;
}

export class UserAttendance extends Attendance implements IUserAttendance {
    userId?: string | undefined;
    userName?: string | undefined;
    userImageUri?: string | undefined;
    userJobTypeId?: string | undefined;
    userJobTypeName?: string | undefined;
    userJobTypeCategory?: string | undefined;
    userQualifications?: string | undefined;

    constructor(data?: IUserAttendance) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.userImageUri = _data["userImageUri"];
            this.userJobTypeId = _data["userJobTypeId"];
            this.userJobTypeName = _data["userJobTypeName"];
            this.userJobTypeCategory = _data["userJobTypeCategory"];
            this.userQualifications = _data["userQualifications"];
        }
    }

    static fromJS(data: any): UserAttendance {
        data = typeof data === 'object' ? data : {};
        let result = new UserAttendance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["userImageUri"] = this.userImageUri;
        data["userJobTypeId"] = this.userJobTypeId;
        data["userJobTypeName"] = this.userJobTypeName;
        data["userJobTypeCategory"] = this.userJobTypeCategory;
        data["userQualifications"] = this.userQualifications;
        super.toJSON(data);
        return data; 
    }
}

export interface IUserAttendance extends IAttendance {
    userId?: string | undefined;
    userName?: string | undefined;
    userImageUri?: string | undefined;
    userJobTypeId?: string | undefined;
    userJobTypeName?: string | undefined;
    userJobTypeCategory?: string | undefined;
    userQualifications?: string | undefined;
}

/** 0 = None 1 = Yes 2 = No 3 = Maybe */
export enum AttendanceStatus {
    None = 0,
    Yes = 1,
    No = 2,
    Maybe = 3,
}

export class UpdateAttendanceSettings implements IUpdateAttendanceSettings {
    status?: AttendanceStatus;
    version!: number;

    constructor(data?: IUpdateAttendanceSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateAttendanceSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAttendanceSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["version"] = this.version;
        return data; 
    }
}

export interface IUpdateAttendanceSettings {
    status?: AttendanceStatus;
    version: number;
}

export class ListOfMeeting implements IListOfMeeting {
    totalItemCount!: number;
    items!: Meeting[];

    constructor(data?: IListOfMeeting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Meeting.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfMeeting {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfMeeting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfMeeting {
    totalItemCount: number;
    items: Meeting[];
}

export class Meeting implements IMeeting {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    start?: Date | undefined;
    end?: Date | undefined;
    location?: Location;
    parentId?: string | undefined;
    version?: number;

    constructor(data?: IMeeting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.start = _data["start"] ? new Date(_data["start"].toString()) : <any>undefined;
            this.end = _data["end"] ? new Date(_data["end"].toString()) : <any>undefined;
            this.location = _data["location"] ? Location.fromJS(_data["location"]) : <any>undefined;
            this.parentId = _data["parentId"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): Meeting {
        data = typeof data === 'object' ? data : {};
        let result = new Meeting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["start"] = this.start ? this.start.toISOString() : <any>undefined;
        data["end"] = this.end ? this.end.toISOString() : <any>undefined;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["parentId"] = this.parentId;
        data["version"] = this.version;
        return data; 
    }
}

export interface IMeeting {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    start?: Date | undefined;
    end?: Date | undefined;
    location?: Location;
    parentId?: string | undefined;
    version?: number;
}

export class Location implements ILocation {
    address?: string | undefined;
    coordinates?: Coordinates;

    constructor(data?: ILocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.address = _data["address"];
            this.coordinates = _data["coordinates"] ? Coordinates.fromJS(_data["coordinates"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Location {
        data = typeof data === 'object' ? data : {};
        let result = new Location();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address;
        data["coordinates"] = this.coordinates ? this.coordinates.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ILocation {
    address?: string | undefined;
    coordinates?: Coordinates;
}

export class Coordinates implements ICoordinates {
    longitude?: number;
    latitude?: number;

    constructor(data?: ICoordinates) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
        }
    }

    static fromJS(data: any): Coordinates {
        data = typeof data === 'object' ? data : {};
        let result = new Coordinates();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        return data; 
    }
}

export interface ICoordinates {
    longitude?: number;
    latitude?: number;
}

export class CreateMeetingSettings implements ICreateMeetingSettings {
    parentId!: string;
    name!: string;
    description?: string | undefined;
    start?: Date | undefined;
    end?: Date | undefined;
    location?: LocationBuilder | undefined;
    files?: CreateFileSettings[] | undefined;

    constructor(data?: ICreateMeetingSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentId = _data["parentId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.start = _data["start"] ? new Date(_data["start"].toString()) : <any>undefined;
            this.end = _data["end"] ? new Date(_data["end"].toString()) : <any>undefined;
            this.location = _data["location"] ? LocationBuilder.fromJS(_data["location"]) : <any>undefined;
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(CreateFileSettings.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateMeetingSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMeetingSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["start"] = this.start ? this.start.toISOString() : <any>undefined;
        data["end"] = this.end ? this.end.toISOString() : <any>undefined;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateMeetingSettings {
    parentId: string;
    name: string;
    description?: string | undefined;
    start?: Date | undefined;
    end?: Date | undefined;
    location?: LocationBuilder | undefined;
    files?: CreateFileSettings[] | undefined;
}

export class LocationBuilder implements ILocationBuilder {
    address?: string | undefined;
    longitude?: number;
    latitude?: number;

    constructor(data?: ILocationBuilder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.address = _data["address"];
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
        }
    }

    static fromJS(data: any): LocationBuilder {
        data = typeof data === 'object' ? data : {};
        let result = new LocationBuilder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        return data; 
    }
}

export interface ILocationBuilder {
    address?: string | undefined;
    longitude?: number;
    latitude?: number;
}

export class CreateFileSettings implements ICreateFileSettings {
    name!: string;
    description?: string | undefined;
    dataUri!: string;

    constructor(data?: ICreateFileSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.dataUri = _data["dataUri"];
        }
    }

    static fromJS(data: any): CreateFileSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFileSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["dataUri"] = this.dataUri;
        return data; 
    }
}

export interface ICreateFileSettings {
    name: string;
    description?: string | undefined;
    dataUri: string;
}

export class UpdateMeetingSettings implements IUpdateMeetingSettings {
    name!: string;
    description?: string | undefined;
    start?: Date | undefined;
    end?: Date | undefined;
    location?: LocationBuilder | undefined;
    version!: number;
    notify?: boolean;
    eventUri?: string | undefined;

    constructor(data?: IUpdateMeetingSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.start = _data["start"] ? new Date(_data["start"].toString()) : <any>undefined;
            this.end = _data["end"] ? new Date(_data["end"].toString()) : <any>undefined;
            this.location = _data["location"] ? LocationBuilder.fromJS(_data["location"]) : <any>undefined;
            this.version = _data["version"];
            this.notify = _data["notify"];
            this.eventUri = _data["eventUri"];
        }
    }

    static fromJS(data: any): UpdateMeetingSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMeetingSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["start"] = this.start ? this.start.toISOString() : <any>undefined;
        data["end"] = this.end ? this.end.toISOString() : <any>undefined;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["version"] = this.version;
        data["notify"] = this.notify;
        data["eventUri"] = this.eventUri;
        return data; 
    }
}

export interface IUpdateMeetingSettings {
    name: string;
    description?: string | undefined;
    start?: Date | undefined;
    end?: Date | undefined;
    location?: LocationBuilder | undefined;
    version: number;
    notify?: boolean;
    eventUri?: string | undefined;
}

export class ListOfFile implements IListOfFile {
    totalItemCount!: number;
    items!: File[];

    constructor(data?: IListOfFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(File.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfFile {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfFile {
    totalItemCount: number;
    items: File[];
}

export class File implements IFile {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    byteCount?: number;
    contentType?: string | undefined;
    extension?: string | undefined;
    creatorId?: string | undefined;
    creatorName?: string | undefined;
    created?: Date;
    modified?: Date;
    parentId?: string | undefined;
    version?: number;

    constructor(data?: IFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.byteCount = _data["byteCount"];
            this.contentType = _data["contentType"];
            this.extension = _data["extension"];
            this.creatorId = _data["creatorId"];
            this.creatorName = _data["creatorName"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
            this.parentId = _data["parentId"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): File {
        data = typeof data === 'object' ? data : {};
        let result = new File();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["byteCount"] = this.byteCount;
        data["contentType"] = this.contentType;
        data["extension"] = this.extension;
        data["creatorId"] = this.creatorId;
        data["creatorName"] = this.creatorName;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        data["parentId"] = this.parentId;
        data["version"] = this.version;
        return data; 
    }
}

export interface IFile {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    byteCount?: number;
    contentType?: string | undefined;
    extension?: string | undefined;
    creatorId?: string | undefined;
    creatorName?: string | undefined;
    created?: Date;
    modified?: Date;
    parentId?: string | undefined;
    version?: number;
}

export class UpdateFileSettings implements IUpdateFileSettings {
    name!: string;
    description?: string | undefined;
    dataUri?: string | undefined;
    version!: number;

    constructor(data?: IUpdateFileSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.dataUri = _data["dataUri"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateFileSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFileSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["dataUri"] = this.dataUri;
        data["version"] = this.version;
        return data; 
    }
}

export interface IUpdateFileSettings {
    name: string;
    description?: string | undefined;
    dataUri?: string | undefined;
    version: number;
}

export class ListOfGroupAttendance implements IListOfGroupAttendance {
    totalItemCount!: number;
    items!: GroupAttendance[];

    constructor(data?: IListOfGroupAttendance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GroupAttendance.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfGroupAttendance {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfGroupAttendance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfGroupAttendance {
    totalItemCount: number;
    items: GroupAttendance[];
}

export class GroupAttendance extends Attendance implements IGroupAttendance {
    groupName?: string | undefined;

    constructor(data?: IGroupAttendance) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.groupName = _data["groupName"];
        }
    }

    static fromJS(data: any): GroupAttendance {
        data = typeof data === 'object' ? data : {};
        let result = new GroupAttendance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupName"] = this.groupName;
        super.toJSON(data);
        return data; 
    }
}

export interface IGroupAttendance extends IAttendance {
    groupName?: string | undefined;
}

export class ListOfBackup implements IListOfBackup {
    totalItemCount!: number;
    items!: Backup[];

    constructor(data?: IListOfBackup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Backup.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfBackup {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfBackup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfBackup {
    totalItemCount: number;
    items: Backup[];
}

export class Backup implements IBackup {
    id?: string | undefined;
    type?: BackupType;
    started?: Date;
    completed?: Date | undefined;
    status?: BackupStatus;
    message?: string | undefined;

    constructor(data?: IBackup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.started = _data["started"] ? new Date(_data["started"].toString()) : <any>undefined;
            this.completed = _data["completed"] ? new Date(_data["completed"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): Backup {
        data = typeof data === 'object' ? data : {};
        let result = new Backup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["started"] = this.started ? this.started.toISOString() : <any>undefined;
        data["completed"] = this.completed ? this.completed.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["message"] = this.message;
        return data; 
    }
}

export interface IBackup {
    id?: string | undefined;
    type?: BackupType;
    started?: Date;
    completed?: Date | undefined;
    status?: BackupStatus;
    message?: string | undefined;
}

/** 0 = Unknown 1 = Scheduled 2 = Manual */
export enum BackupType {
    Unknown = 0,
    Scheduled = 1,
    Manual = 2,
}

/** 0 = Running 1 = Completed 2 = Error */
export enum BackupStatus {
    Running = 0,
    Completed = 1,
    Error = 2,
}

export class ListOfExternalApplication implements IListOfExternalApplication {
    totalItemCount!: number;
    items!: ExternalApplication[];

    constructor(data?: IListOfExternalApplication) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ExternalApplication.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfExternalApplication {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfExternalApplication();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfExternalApplication {
    totalItemCount: number;
    items: ExternalApplication[];
}

export class ExternalApplication implements IExternalApplication {
    id?: string | undefined;
    name?: string | undefined;
    imageUri?: string | undefined;
    endpoint?: string | undefined;
    isDefault?: boolean;
    version?: number;

    constructor(data?: IExternalApplication) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.imageUri = _data["imageUri"];
            this.endpoint = _data["endpoint"];
            this.isDefault = _data["isDefault"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): ExternalApplication {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalApplication();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["imageUri"] = this.imageUri;
        data["endpoint"] = this.endpoint;
        data["isDefault"] = this.isDefault;
        data["version"] = this.version;
        return data; 
    }
}

export interface IExternalApplication {
    id?: string | undefined;
    name?: string | undefined;
    imageUri?: string | undefined;
    endpoint?: string | undefined;
    isDefault?: boolean;
    version?: number;
}

export class CreateExternalApplicationSettings implements ICreateExternalApplicationSettings {
    name!: string;
    imageUri?: string | undefined;
    endpoint?: string | undefined;
    isDefault?: boolean;

    constructor(data?: ICreateExternalApplicationSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.imageUri = _data["imageUri"];
            this.endpoint = _data["endpoint"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): CreateExternalApplicationSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateExternalApplicationSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["imageUri"] = this.imageUri;
        data["endpoint"] = this.endpoint;
        data["isDefault"] = this.isDefault;
        return data; 
    }
}

export interface ICreateExternalApplicationSettings {
    name: string;
    imageUri?: string | undefined;
    endpoint?: string | undefined;
    isDefault?: boolean;
}

export class UpdateExternalApplicationSettings implements IUpdateExternalApplicationSettings {
    name!: string;
    imageUri?: string | undefined;
    endpoint?: string | undefined;
    isDefault?: boolean;
    version!: number;

    constructor(data?: IUpdateExternalApplicationSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.imageUri = _data["imageUri"];
            this.endpoint = _data["endpoint"];
            this.isDefault = _data["isDefault"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateExternalApplicationSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateExternalApplicationSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["imageUri"] = this.imageUri;
        data["endpoint"] = this.endpoint;
        data["isDefault"] = this.isDefault;
        data["version"] = this.version;
        return data; 
    }
}

export interface IUpdateExternalApplicationSettings {
    name: string;
    imageUri?: string | undefined;
    endpoint?: string | undefined;
    isDefault?: boolean;
    version: number;
}

export class ResizedImage implements IResizedImage {
    uri?: string | undefined;
    width?: number;
    height?: number;

    constructor(data?: IResizedImage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.uri = _data["uri"];
            this.width = _data["width"];
            this.height = _data["height"];
        }
    }

    static fromJS(data: any): ResizedImage {
        data = typeof data === 'object' ? data : {};
        let result = new ResizedImage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uri"] = this.uri;
        data["width"] = this.width;
        data["height"] = this.height;
        return data; 
    }
}

export interface IResizedImage {
    uri?: string | undefined;
    width?: number;
    height?: number;
}

export class ListOfLog implements IListOfLog {
    totalItemCount!: number;
    items!: Log[];

    constructor(data?: IListOfLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Log.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfLog {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfLog {
    totalItemCount: number;
    items: Log[];
}

export class Log implements ILog {
    id?: string | undefined;
    created?: Date;
    message?: string | undefined;
    level?: number;
    context?: string | undefined;

    constructor(data?: ILog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.message = _data["message"];
            this.level = _data["level"];
            this.context = _data["context"];
        }
    }

    static fromJS(data: any): Log {
        data = typeof data === 'object' ? data : {};
        let result = new Log();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["message"] = this.message;
        data["level"] = this.level;
        data["context"] = this.context;
        return data; 
    }
}

export interface ILog {
    id?: string | undefined;
    created?: Date;
    message?: string | undefined;
    level?: number;
    context?: string | undefined;
}

export class MarkdownPreviewSettings implements IMarkdownPreviewSettings {
    text?: string | undefined;

    constructor(data?: IMarkdownPreviewSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): MarkdownPreviewSettings {
        data = typeof data === 'object' ? data : {};
        let result = new MarkdownPreviewSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        return data; 
    }
}

export interface IMarkdownPreviewSettings {
    text?: string | undefined;
}

export class Platform implements IPlatform {
    id?: string | undefined;
    name?: string | undefined;
    environment?: string | undefined;
    timeZoneId?: string | undefined;
    version?: ApplicationVersion;
    compileConfiguration?: string | undefined;
    compileDate?: Date | undefined;
    reCaptchaSiteKey?: string | undefined;
    supportEmailAddress?: string | undefined;
    systemEmailAddress?: string | undefined;
    cultures?: Culture[] | undefined;

    constructor(data?: IPlatform) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.environment = _data["environment"];
            this.timeZoneId = _data["timeZoneId"];
            this.version = _data["version"] ? ApplicationVersion.fromJS(_data["version"]) : <any>undefined;
            this.compileConfiguration = _data["compileConfiguration"];
            this.compileDate = _data["compileDate"] ? new Date(_data["compileDate"].toString()) : <any>undefined;
            this.reCaptchaSiteKey = _data["reCaptchaSiteKey"];
            this.supportEmailAddress = _data["supportEmailAddress"];
            this.systemEmailAddress = _data["systemEmailAddress"];
            if (Array.isArray(_data["cultures"])) {
                this.cultures = [] as any;
                for (let item of _data["cultures"])
                    this.cultures!.push(Culture.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Platform {
        data = typeof data === 'object' ? data : {};
        let result = new Platform();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["environment"] = this.environment;
        data["timeZoneId"] = this.timeZoneId;
        data["version"] = this.version ? this.version.toJSON() : <any>undefined;
        data["compileConfiguration"] = this.compileConfiguration;
        data["compileDate"] = this.compileDate ? this.compileDate.toISOString() : <any>undefined;
        data["reCaptchaSiteKey"] = this.reCaptchaSiteKey;
        data["supportEmailAddress"] = this.supportEmailAddress;
        data["systemEmailAddress"] = this.systemEmailAddress;
        if (Array.isArray(this.cultures)) {
            data["cultures"] = [];
            for (let item of this.cultures)
                data["cultures"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPlatform {
    id?: string | undefined;
    name?: string | undefined;
    environment?: string | undefined;
    timeZoneId?: string | undefined;
    version?: ApplicationVersion;
    compileConfiguration?: string | undefined;
    compileDate?: Date | undefined;
    reCaptchaSiteKey?: string | undefined;
    supportEmailAddress?: string | undefined;
    systemEmailAddress?: string | undefined;
    cultures?: Culture[] | undefined;
}

export class ApplicationVersion implements IApplicationVersion {
    major?: number;
    minor?: number;
    build?: number;

    constructor(data?: IApplicationVersion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.major = _data["major"];
            this.minor = _data["minor"];
            this.build = _data["build"];
        }
    }

    static fromJS(data: any): ApplicationVersion {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationVersion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["major"] = this.major;
        data["minor"] = this.minor;
        data["build"] = this.build;
        return data; 
    }
}

export interface IApplicationVersion {
    major?: number;
    minor?: number;
    build?: number;
}

export class Culture implements ICulture {
    id?: string | undefined;
    name?: string | undefined;
    datePattern?: string | undefined;
    shortDatePattern?: string | undefined;
    timePattern?: string | undefined;
    shortTimePattern?: string | undefined;

    constructor(data?: ICulture) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.datePattern = _data["datePattern"];
            this.shortDatePattern = _data["shortDatePattern"];
            this.timePattern = _data["timePattern"];
            this.shortTimePattern = _data["shortTimePattern"];
        }
    }

    static fromJS(data: any): Culture {
        data = typeof data === 'object' ? data : {};
        let result = new Culture();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["datePattern"] = this.datePattern;
        data["shortDatePattern"] = this.shortDatePattern;
        data["timePattern"] = this.timePattern;
        data["shortTimePattern"] = this.shortTimePattern;
        return data; 
    }
}

export interface ICulture {
    id?: string | undefined;
    name?: string | undefined;
    datePattern?: string | undefined;
    shortDatePattern?: string | undefined;
    timePattern?: string | undefined;
    shortTimePattern?: string | undefined;
}

export class PlatformStatus implements IPlatformStatus {
    status?: SystemStatus;
    buildingProgress?: number;

    constructor(data?: IPlatformStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.buildingProgress = _data["buildingProgress"];
        }
    }

    static fromJS(data: any): PlatformStatus {
        data = typeof data === 'object' ? data : {};
        let result = new PlatformStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["buildingProgress"] = this.buildingProgress;
        return data; 
    }
}

export interface IPlatformStatus {
    status?: SystemStatus;
    buildingProgress?: number;
}

/** 0 = Built 1 = Building 2 = Maintenance -1 = Failed */
export enum SystemStatus {
    Built = 0,
    Building = 1,
    Maintenance = 2,
    Failed = -1,
}

export class ListOfProjectionBuild implements IListOfProjectionBuild {
    totalItemCount!: number;
    items!: ProjectionBuild[];

    constructor(data?: IListOfProjectionBuild) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProjectionBuild.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfProjectionBuild {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfProjectionBuild();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfProjectionBuild {
    totalItemCount: number;
    items: ProjectionBuild[];
}

export class ProjectionBuild implements IProjectionBuild {
    eventsProcessed?: number;
    estimatedTotalEvents?: number;
    status?: ProjectionStatus;

    constructor(data?: IProjectionBuild) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eventsProcessed = _data["eventsProcessed"];
            this.estimatedTotalEvents = _data["estimatedTotalEvents"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): ProjectionBuild {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectionBuild();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eventsProcessed"] = this.eventsProcessed;
        data["estimatedTotalEvents"] = this.estimatedTotalEvents;
        data["status"] = this.status;
        return data; 
    }
}

export interface IProjectionBuild {
    eventsProcessed?: number;
    estimatedTotalEvents?: number;
    status?: ProjectionStatus;
}

/** 0 = Unknown 1 = Pending 2 = Running 3 = Completed -1 = Failed */
export enum ProjectionStatus {
    Unknown = 0,
    Pending = 1,
    Running = 2,
    Completed = 3,
    Failed = -1,
}

export class ListOfNotification implements IListOfNotification {
    totalItemCount!: number;
    items!: Notification[];

    constructor(data?: IListOfNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Notification.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfNotification {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfNotification {
    totalItemCount: number;
    items: Notification[];
}

export class Notification implements INotification {
    id?: string | undefined;
    type?: string | undefined;
    recipientId?: string | undefined;
    parameters?: any | undefined;
    seen?: boolean;
    read?: boolean;
    creatorId?: string | undefined;
    creatorName?: string | undefined;
    created?: Date;
    version?: number;

    constructor(data?: INotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.recipientId = _data["recipientId"];
            this.parameters = _data["parameters"];
            this.seen = _data["seen"];
            this.read = _data["read"];
            this.creatorId = _data["creatorId"];
            this.creatorName = _data["creatorName"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): Notification {
        data = typeof data === 'object' ? data : {};
        let result = new Notification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["recipientId"] = this.recipientId;
        data["parameters"] = this.parameters;
        data["seen"] = this.seen;
        data["read"] = this.read;
        data["creatorId"] = this.creatorId;
        data["creatorName"] = this.creatorName;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["version"] = this.version;
        return data; 
    }
}

export interface INotification {
    id?: string | undefined;
    type?: string | undefined;
    recipientId?: string | undefined;
    parameters?: any | undefined;
    seen?: boolean;
    read?: boolean;
    creatorId?: string | undefined;
    creatorName?: string | undefined;
    created?: Date;
    version?: number;
}

export class UpdateNotificationSettings implements IUpdateNotificationSettings {
    seen?: boolean;
    read?: boolean;
    version!: number;

    constructor(data?: IUpdateNotificationSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.seen = _data["seen"];
            this.read = _data["read"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateNotificationSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNotificationSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["seen"] = this.seen;
        data["read"] = this.read;
        data["version"] = this.version;
        return data; 
    }
}

export interface IUpdateNotificationSettings {
    seen?: boolean;
    read?: boolean;
    version: number;
}

export class ListOfScheduledEmail implements IListOfScheduledEmail {
    totalItemCount!: number;
    items!: ScheduledEmail[];

    constructor(data?: IListOfScheduledEmail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ScheduledEmail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfScheduledEmail {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfScheduledEmail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfScheduledEmail {
    totalItemCount: number;
    items: ScheduledEmail[];
}

export class ScheduledEmail implements IScheduledEmail {
    id?: string | undefined;
    type?: string | undefined;
    title?: string | undefined;
    note?: string | undefined;
    externalApplicationId?: string | undefined;
    groupId?: string | undefined;
    groupName?: string | undefined;
    organisationId?: string | undefined;
    timeZoneId?: string | undefined;
    creatorId?: string | undefined;
    created?: Date;
    recipientIds?: string[] | undefined;
    parameters?: any | undefined;
    schedule?: ScheduleOption | undefined;
    version?: number;

    constructor(data?: IScheduledEmail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.title = _data["title"];
            this.note = _data["note"];
            this.externalApplicationId = _data["externalApplicationId"];
            this.groupId = _data["groupId"];
            this.groupName = _data["groupName"];
            this.organisationId = _data["organisationId"];
            this.timeZoneId = _data["timeZoneId"];
            this.creatorId = _data["creatorId"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            if (Array.isArray(_data["recipientIds"])) {
                this.recipientIds = [] as any;
                for (let item of _data["recipientIds"])
                    this.recipientIds!.push(item);
            }
            this.parameters = _data["parameters"];
            this.schedule = _data["schedule"] ? ScheduleOption.fromJS(_data["schedule"]) : <any>undefined;
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): ScheduledEmail {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduledEmail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["title"] = this.title;
        data["note"] = this.note;
        data["externalApplicationId"] = this.externalApplicationId;
        data["groupId"] = this.groupId;
        data["groupName"] = this.groupName;
        data["organisationId"] = this.organisationId;
        data["timeZoneId"] = this.timeZoneId;
        data["creatorId"] = this.creatorId;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        if (Array.isArray(this.recipientIds)) {
            data["recipientIds"] = [];
            for (let item of this.recipientIds)
                data["recipientIds"].push(item);
        }
        data["parameters"] = this.parameters;
        data["schedule"] = this.schedule ? this.schedule.toJSON() : <any>undefined;
        data["version"] = this.version;
        return data; 
    }
}

export interface IScheduledEmail {
    id?: string | undefined;
    type?: string | undefined;
    title?: string | undefined;
    note?: string | undefined;
    externalApplicationId?: string | undefined;
    groupId?: string | undefined;
    groupName?: string | undefined;
    organisationId?: string | undefined;
    timeZoneId?: string | undefined;
    creatorId?: string | undefined;
    created?: Date;
    recipientIds?: string[] | undefined;
    parameters?: any | undefined;
    schedule?: ScheduleOption | undefined;
    version?: number;
}

export class ScheduleOption implements IScheduleOption {
    start?: Date;
    repeatType?: RepeatType;
    repeatInterval?: number;
    repeatOn?: number[] | undefined;
    end?: Date | undefined;

    constructor(data?: IScheduleOption) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.start = _data["start"] ? new Date(_data["start"].toString()) : <any>undefined;
            this.repeatType = _data["repeatType"];
            this.repeatInterval = _data["repeatInterval"];
            if (Array.isArray(_data["repeatOn"])) {
                this.repeatOn = [] as any;
                for (let item of _data["repeatOn"])
                    this.repeatOn!.push(item);
            }
            this.end = _data["end"] ? new Date(_data["end"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ScheduleOption {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleOption();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["start"] = this.start ? this.start.toISOString() : <any>undefined;
        data["repeatType"] = this.repeatType;
        data["repeatInterval"] = this.repeatInterval;
        if (Array.isArray(this.repeatOn)) {
            data["repeatOn"] = [];
            for (let item of this.repeatOn)
                data["repeatOn"].push(item);
        }
        data["end"] = this.end ? this.end.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IScheduleOption {
    start?: Date;
    repeatType?: RepeatType;
    repeatInterval?: number;
    repeatOn?: number[] | undefined;
    end?: Date | undefined;
}

/** 0 = None 1 = Daily 2 = Weekly 3 = MonthlyByDay 4 = MonthlyByDayOfWeek 5 = Yearly */
export enum RepeatType {
    None = 0,
    Daily = 1,
    Weekly = 2,
    MonthlyByDay = 3,
    MonthlyByDayOfWeek = 4,
    Yearly = 5,
}

export class CreateScheduledEmailSettings implements ICreateScheduledEmailSettings {
    type!: string;
    title?: string | undefined;
    note?: string | undefined;
    groupId!: string;
    schedule!: ScheduleOption;
    recipientIds?: string[] | undefined;
    externalApplicationId?: string | undefined;
    parameters!: any;

    constructor(data?: ICreateScheduledEmailSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.schedule = new ScheduleOption();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.note = _data["note"];
            this.groupId = _data["groupId"];
            this.schedule = _data["schedule"] ? ScheduleOption.fromJS(_data["schedule"]) : new ScheduleOption();
            if (Array.isArray(_data["recipientIds"])) {
                this.recipientIds = [] as any;
                for (let item of _data["recipientIds"])
                    this.recipientIds!.push(item);
            }
            this.externalApplicationId = _data["externalApplicationId"];
            this.parameters = _data["parameters"];
        }
    }

    static fromJS(data: any): CreateScheduledEmailSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateScheduledEmailSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["note"] = this.note;
        data["groupId"] = this.groupId;
        data["schedule"] = this.schedule ? this.schedule.toJSON() : <any>undefined;
        if (Array.isArray(this.recipientIds)) {
            data["recipientIds"] = [];
            for (let item of this.recipientIds)
                data["recipientIds"].push(item);
        }
        data["externalApplicationId"] = this.externalApplicationId;
        data["parameters"] = this.parameters;
        return data; 
    }
}

export interface ICreateScheduledEmailSettings {
    type: string;
    title?: string | undefined;
    note?: string | undefined;
    groupId: string;
    schedule: ScheduleOption;
    recipientIds?: string[] | undefined;
    externalApplicationId?: string | undefined;
    parameters: any;
}

export class UpdateScheduledEmailSettings implements IUpdateScheduledEmailSettings {
    title?: string | undefined;
    note?: string | undefined;
    schedule?: ScheduleOption | undefined;
    recipientIds?: string[] | undefined;
    externalApplicationId?: string | undefined;
    parameters?: any | undefined;
    version?: number;

    constructor(data?: IUpdateScheduledEmailSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.note = _data["note"];
            this.schedule = _data["schedule"] ? ScheduleOption.fromJS(_data["schedule"]) : <any>undefined;
            if (Array.isArray(_data["recipientIds"])) {
                this.recipientIds = [] as any;
                for (let item of _data["recipientIds"])
                    this.recipientIds!.push(item);
            }
            this.externalApplicationId = _data["externalApplicationId"];
            this.parameters = _data["parameters"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateScheduledEmailSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateScheduledEmailSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["note"] = this.note;
        data["schedule"] = this.schedule ? this.schedule.toJSON() : <any>undefined;
        if (Array.isArray(this.recipientIds)) {
            data["recipientIds"] = [];
            for (let item of this.recipientIds)
                data["recipientIds"].push(item);
        }
        data["externalApplicationId"] = this.externalApplicationId;
        data["parameters"] = this.parameters;
        data["version"] = this.version;
        return data; 
    }
}

export interface IUpdateScheduledEmailSettings {
    title?: string | undefined;
    note?: string | undefined;
    schedule?: ScheduleOption | undefined;
    recipientIds?: string[] | undefined;
    externalApplicationId?: string | undefined;
    parameters?: any | undefined;
    version?: number;
}

export class ListOfObservationContent implements IListOfObservationContent {
    totalItemCount!: number;
    items!: ObservationContent[];

    constructor(data?: IListOfObservationContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ObservationContent.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfObservationContent {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfObservationContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfObservationContent {
    totalItemCount: number;
    items: ObservationContent[];
}

export class ObservationContent implements IObservationContent {
    id?: string | undefined;
    publisherId?: string | undefined;
    definitionId?: string | undefined;
    questions?: any[] | undefined;
    published?: boolean;
    created?: Date;
    modified?: Date;
    version?: number;

    constructor(data?: IObservationContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.publisherId = _data["publisherId"];
            this.definitionId = _data["definitionId"];
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(item);
            }
            this.published = _data["published"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): ObservationContent {
        data = typeof data === 'object' ? data : {};
        let result = new ObservationContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["publisherId"] = this.publisherId;
        data["definitionId"] = this.definitionId;
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item);
        }
        data["published"] = this.published;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        data["version"] = this.version;
        return data; 
    }
}

export interface IObservationContent {
    id?: string | undefined;
    publisherId?: string | undefined;
    definitionId?: string | undefined;
    questions?: any[] | undefined;
    published?: boolean;
    created?: Date;
    modified?: Date;
    version?: number;
}

export class CreateObservationContentSettings implements ICreateObservationContentSettings {
    definitionId!: string;
    questions!: any[];
    published?: boolean;

    constructor(data?: ICreateObservationContentSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.questions = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.definitionId = _data["definitionId"];
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(item);
            }
            this.published = _data["published"];
        }
    }

    static fromJS(data: any): CreateObservationContentSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateObservationContentSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["definitionId"] = this.definitionId;
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item);
        }
        data["published"] = this.published;
        return data; 
    }
}

export interface ICreateObservationContentSettings {
    definitionId: string;
    questions: any[];
    published?: boolean;
}

export class UpdateObservationContentSettings implements IUpdateObservationContentSettings {
    questions!: any[];
    version?: number;

    constructor(data?: IUpdateObservationContentSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.questions = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(item);
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateObservationContentSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateObservationContentSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item);
        }
        data["version"] = this.version;
        return data; 
    }
}

export interface IUpdateObservationContentSettings {
    questions: any[];
    version?: number;
}

export class ListOfLocatableObservation implements IListOfLocatableObservation {
    totalItemCount!: number;
    items!: LocatableObservation[];

    constructor(data?: IListOfLocatableObservation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LocatableObservation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfLocatableObservation {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfLocatableObservation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfLocatableObservation {
    totalItemCount: number;
    items: LocatableObservation[];
}

export class Observation implements IObservation {
    id?: string | undefined;
    name?: string | undefined;
    performed?: Date;
    answers?: any[] | undefined;
    groupId?: string | undefined;
    groupName?: string | undefined;
    groupType?: string | undefined;
    organisationId?: string | undefined;
    observerId?: string | undefined;
    observerName?: string | undefined;
    definitionId?: string | undefined;
    publisherId?: string | undefined;
    contentId?: string | undefined;
    creatorId?: string | undefined;
    version?: number;

    constructor(data?: IObservation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.performed = _data["performed"] ? new Date(_data["performed"].toString()) : <any>undefined;
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(item);
            }
            this.groupId = _data["groupId"];
            this.groupName = _data["groupName"];
            this.groupType = _data["groupType"];
            this.organisationId = _data["organisationId"];
            this.observerId = _data["observerId"];
            this.observerName = _data["observerName"];
            this.definitionId = _data["definitionId"];
            this.publisherId = _data["publisherId"];
            this.contentId = _data["contentId"];
            this.creatorId = _data["creatorId"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): Observation {
        data = typeof data === 'object' ? data : {};
        let result = new Observation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["performed"] = this.performed ? this.performed.toISOString() : <any>undefined;
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item);
        }
        data["groupId"] = this.groupId;
        data["groupName"] = this.groupName;
        data["groupType"] = this.groupType;
        data["organisationId"] = this.organisationId;
        data["observerId"] = this.observerId;
        data["observerName"] = this.observerName;
        data["definitionId"] = this.definitionId;
        data["publisherId"] = this.publisherId;
        data["contentId"] = this.contentId;
        data["creatorId"] = this.creatorId;
        data["version"] = this.version;
        return data; 
    }
}

export interface IObservation {
    id?: string | undefined;
    name?: string | undefined;
    performed?: Date;
    answers?: any[] | undefined;
    groupId?: string | undefined;
    groupName?: string | undefined;
    groupType?: string | undefined;
    organisationId?: string | undefined;
    observerId?: string | undefined;
    observerName?: string | undefined;
    definitionId?: string | undefined;
    publisherId?: string | undefined;
    contentId?: string | undefined;
    creatorId?: string | undefined;
    version?: number;
}

export class LocatableObservation extends Observation implements ILocatableObservation {
    coordinates?: Coordinates | undefined;

    constructor(data?: ILocatableObservation) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.coordinates = _data["coordinates"] ? Coordinates.fromJS(_data["coordinates"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LocatableObservation {
        data = typeof data === 'object' ? data : {};
        let result = new LocatableObservation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["coordinates"] = this.coordinates ? this.coordinates.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface ILocatableObservation extends IObservation {
    coordinates?: Coordinates | undefined;
}

export class PageOptions implements IPageOptions {
    skip?: number;
    /** The number (0 - 1000 inclusive) of items to get from the API. */
    take?: number;

    constructor(data?: IPageOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): PageOptions {
        data = typeof data === 'object' ? data : {};
        let result = new PageOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

export interface IPageOptions {
    skip?: number;
    /** The number (0 - 1000 inclusive) of items to get from the API. */
    take?: number;
}

export class ObservationAreaOptions extends PageOptions implements IObservationAreaOptions {
    southWest?: CoordinatesBuilder | undefined;
    northEast?: CoordinatesBuilder | undefined;
    labelled?: boolean | undefined;

    constructor(data?: IObservationAreaOptions) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.southWest = _data["southWest"] ? CoordinatesBuilder.fromJS(_data["southWest"]) : <any>undefined;
            this.northEast = _data["northEast"] ? CoordinatesBuilder.fromJS(_data["northEast"]) : <any>undefined;
            this.labelled = _data["labelled"];
        }
    }

    static fromJS(data: any): ObservationAreaOptions {
        data = typeof data === 'object' ? data : {};
        let result = new ObservationAreaOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["southWest"] = this.southWest ? this.southWest.toJSON() : <any>undefined;
        data["northEast"] = this.northEast ? this.northEast.toJSON() : <any>undefined;
        data["labelled"] = this.labelled;
        super.toJSON(data);
        return data; 
    }
}

export interface IObservationAreaOptions extends IPageOptions {
    southWest?: CoordinatesBuilder | undefined;
    northEast?: CoordinatesBuilder | undefined;
    labelled?: boolean | undefined;
}

export class CoordinatesBuilder implements ICoordinatesBuilder {
    longitude?: number;
    latitude?: number;

    constructor(data?: ICoordinatesBuilder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
        }
    }

    static fromJS(data: any): CoordinatesBuilder {
        data = typeof data === 'object' ? data : {};
        let result = new CoordinatesBuilder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        return data; 
    }
}

export interface ICoordinatesBuilder {
    longitude?: number;
    latitude?: number;
}

export class ListOfObservation implements IListOfObservation {
    totalItemCount!: number;
    items!: Observation[];

    constructor(data?: IListOfObservation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Observation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfObservation {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfObservation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfObservation {
    totalItemCount: number;
    items: Observation[];
}

export class CreateObservationSettings implements ICreateObservationSettings {
    contentId!: string;
    groupId!: string;
    observerId?: string | undefined;
    answers?: any[] | undefined;
    performed?: Date;

    constructor(data?: ICreateObservationSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contentId = _data["contentId"];
            this.groupId = _data["groupId"];
            this.observerId = _data["observerId"];
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(item);
            }
            this.performed = _data["performed"] ? new Date(_data["performed"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateObservationSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateObservationSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        data["groupId"] = this.groupId;
        data["observerId"] = this.observerId;
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item);
        }
        data["performed"] = this.performed ? this.performed.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ICreateObservationSettings {
    contentId: string;
    groupId: string;
    observerId?: string | undefined;
    answers?: any[] | undefined;
    performed?: Date;
}

export class UpdateObservationSettings implements IUpdateObservationSettings {
    observerId?: string | undefined;
    answers?: any[] | undefined;
    performed?: Date;
    version!: number;

    constructor(data?: IUpdateObservationSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.observerId = _data["observerId"];
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(item);
            }
            this.performed = _data["performed"] ? new Date(_data["performed"].toString()) : <any>undefined;
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateObservationSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateObservationSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["observerId"] = this.observerId;
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item);
        }
        data["performed"] = this.performed ? this.performed.toISOString() : <any>undefined;
        data["version"] = this.version;
        return data; 
    }
}

export interface IUpdateObservationSettings {
    observerId?: string | undefined;
    answers?: any[] | undefined;
    performed?: Date;
    version: number;
}

export class PredictObservationSettings implements IPredictObservationSettings {
    dataUri!: string;

    constructor(data?: IPredictObservationSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataUri = _data["dataUri"];
        }
    }

    static fromJS(data: any): PredictObservationSettings {
        data = typeof data === 'object' ? data : {};
        let result = new PredictObservationSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataUri"] = this.dataUri;
        return data; 
    }
}

export interface IPredictObservationSettings {
    dataUri: string;
}

export class LabelledAnswer implements ILabelledAnswer {
    label?: string | undefined;
    value?: any | undefined;

    constructor(data?: ILabelledAnswer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): LabelledAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new LabelledAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["value"] = this.value;
        return data; 
    }
}

export interface ILabelledAnswer {
    label?: string | undefined;
    value?: any | undefined;
}

export class ExtractLabelledAnswersSettings implements IExtractLabelledAnswersSettings {
    questions?: any[] | undefined;
    answers?: any[] | undefined;

    constructor(data?: IExtractLabelledAnswersSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(item);
            }
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(item);
            }
        }
    }

    static fromJS(data: any): ExtractLabelledAnswersSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ExtractLabelledAnswersSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item);
        }
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item);
        }
        return data; 
    }
}

export interface IExtractLabelledAnswersSettings {
    questions?: any[] | undefined;
    answers?: any[] | undefined;
}

export class ListOfObservationDefinition implements IListOfObservationDefinition {
    totalItemCount!: number;
    items!: ObservationDefinition[];

    constructor(data?: IListOfObservationDefinition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ObservationDefinition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfObservationDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfObservationDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfObservationDefinition {
    totalItemCount: number;
    items: ObservationDefinition[];
}

export class ObservationDefinition implements IObservationDefinition {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    publisherId?: string | undefined;
    publisherName?: string | undefined;
    published?: boolean;
    publishedContentId?: string | undefined;
    programs?: ProgramInObservationDefinition[] | undefined;
    version?: number;

    constructor(data?: IObservationDefinition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.publisherId = _data["publisherId"];
            this.publisherName = _data["publisherName"];
            this.published = _data["published"];
            this.publishedContentId = _data["publishedContentId"];
            if (Array.isArray(_data["programs"])) {
                this.programs = [] as any;
                for (let item of _data["programs"])
                    this.programs!.push(ProgramInObservationDefinition.fromJS(item));
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): ObservationDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new ObservationDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["publisherId"] = this.publisherId;
        data["publisherName"] = this.publisherName;
        data["published"] = this.published;
        data["publishedContentId"] = this.publishedContentId;
        if (Array.isArray(this.programs)) {
            data["programs"] = [];
            for (let item of this.programs)
                data["programs"].push(item.toJSON());
        }
        data["version"] = this.version;
        return data; 
    }
}

export interface IObservationDefinition {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    publisherId?: string | undefined;
    publisherName?: string | undefined;
    published?: boolean;
    publishedContentId?: string | undefined;
    programs?: ProgramInObservationDefinition[] | undefined;
    version?: number;
}

export class ProgramInObservationDefinition implements IProgramInObservationDefinition {
    id?: string | undefined;
    name?: string | undefined;

    constructor(data?: IProgramInObservationDefinition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ProgramInObservationDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramInObservationDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IProgramInObservationDefinition {
    id?: string | undefined;
    name?: string | undefined;
}

export class CreateObservationDefinitionSettings implements ICreateObservationDefinitionSettings {
    publisherId!: string;
    name!: string;
    description!: string;

    constructor(data?: ICreateObservationDefinitionSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.publisherId = _data["publisherId"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateObservationDefinitionSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateObservationDefinitionSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["publisherId"] = this.publisherId;
        data["name"] = this.name;
        data["description"] = this.description;
        return data; 
    }
}

export interface ICreateObservationDefinitionSettings {
    publisherId: string;
    name: string;
    description: string;
}

export class UpdateObservationDefinitionSettings implements IUpdateObservationDefinitionSettings {
    name!: string;
    description!: string;
    version!: number;

    constructor(data?: IUpdateObservationDefinitionSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateObservationDefinitionSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateObservationDefinitionSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["version"] = this.version;
        return data; 
    }
}

export interface IUpdateObservationDefinitionSettings {
    name: string;
    description: string;
    version: number;
}

export class ListOfObservationForm implements IListOfObservationForm {
    totalItemCount!: number;
    items!: ObservationForm[];

    constructor(data?: IListOfObservationForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ObservationForm.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfObservationForm {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfObservationForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfObservationForm {
    totalItemCount: number;
    items: ObservationForm[];
}

export class ObservationForm implements IObservationForm {
    id?: string | undefined;
    publisherId?: string | undefined;
    definitionId?: string | undefined;
    contentId?: string | undefined;
    fileQuestionIndex?: number | undefined;
    modelId?: string | undefined;
    modelVersion?: string | undefined;
    widthMillimetres?: number;
    heightMillimetres?: number;
    modified?: Date;
    version?: number;

    constructor(data?: IObservationForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.publisherId = _data["publisherId"];
            this.definitionId = _data["definitionId"];
            this.contentId = _data["contentId"];
            this.fileQuestionIndex = _data["fileQuestionIndex"];
            this.modelId = _data["modelId"];
            this.modelVersion = _data["modelVersion"];
            this.widthMillimetres = _data["widthMillimetres"];
            this.heightMillimetres = _data["heightMillimetres"];
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): ObservationForm {
        data = typeof data === 'object' ? data : {};
        let result = new ObservationForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["publisherId"] = this.publisherId;
        data["definitionId"] = this.definitionId;
        data["contentId"] = this.contentId;
        data["fileQuestionIndex"] = this.fileQuestionIndex;
        data["modelId"] = this.modelId;
        data["modelVersion"] = this.modelVersion;
        data["widthMillimetres"] = this.widthMillimetres;
        data["heightMillimetres"] = this.heightMillimetres;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        data["version"] = this.version;
        return data; 
    }
}

export interface IObservationForm {
    id?: string | undefined;
    publisherId?: string | undefined;
    definitionId?: string | undefined;
    contentId?: string | undefined;
    fileQuestionIndex?: number | undefined;
    modelId?: string | undefined;
    modelVersion?: string | undefined;
    widthMillimetres?: number;
    heightMillimetres?: number;
    modified?: Date;
    version?: number;
}

export class CreateObservationFormSettings implements ICreateObservationFormSettings {
    contentId!: string;
    /** The index of the file question in the target observation content
that will be used to store the OCR image. */
    fileQuestionIndex?: number | undefined;
    /** ID of the ML training model. */
    modelId!: string;
    /** Version of the ML training model. */
    modelVersion!: string;
    widthMillimetres?: number;
    heightMillimetres?: number;

    constructor(data?: ICreateObservationFormSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contentId = _data["contentId"];
            this.fileQuestionIndex = _data["fileQuestionIndex"];
            this.modelId = _data["modelId"];
            this.modelVersion = _data["modelVersion"];
            this.widthMillimetres = _data["widthMillimetres"];
            this.heightMillimetres = _data["heightMillimetres"];
        }
    }

    static fromJS(data: any): CreateObservationFormSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateObservationFormSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        data["fileQuestionIndex"] = this.fileQuestionIndex;
        data["modelId"] = this.modelId;
        data["modelVersion"] = this.modelVersion;
        data["widthMillimetres"] = this.widthMillimetres;
        data["heightMillimetres"] = this.heightMillimetres;
        return data; 
    }
}

export interface ICreateObservationFormSettings {
    contentId: string;
    /** The index of the file question in the target observation content
that will be used to store the OCR image. */
    fileQuestionIndex?: number | undefined;
    /** ID of the ML training model. */
    modelId: string;
    /** Version of the ML training model. */
    modelVersion: string;
    widthMillimetres?: number;
    heightMillimetres?: number;
}

export class UpdateObservationFormSettings implements IUpdateObservationFormSettings {
    fileQuestionIndex?: number | undefined;
    modelId!: string;
    modelVersion!: string;
    widthMillimetres?: number;
    heightMillimetres?: number;
    version?: number;

    constructor(data?: IUpdateObservationFormSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileQuestionIndex = _data["fileQuestionIndex"];
            this.modelId = _data["modelId"];
            this.modelVersion = _data["modelVersion"];
            this.widthMillimetres = _data["widthMillimetres"];
            this.heightMillimetres = _data["heightMillimetres"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateObservationFormSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateObservationFormSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileQuestionIndex"] = this.fileQuestionIndex;
        data["modelId"] = this.modelId;
        data["modelVersion"] = this.modelVersion;
        data["widthMillimetres"] = this.widthMillimetres;
        data["heightMillimetres"] = this.heightMillimetres;
        data["version"] = this.version;
        return data; 
    }
}

export interface IUpdateObservationFormSettings {
    fileQuestionIndex?: number | undefined;
    modelId: string;
    modelVersion: string;
    widthMillimetres?: number;
    heightMillimetres?: number;
    version?: number;
}

export class MigrateObservationDefinitionSettings implements IMigrateObservationDefinitionSettings {
    publisherId!: string;
    version!: number;

    constructor(data?: IMigrateObservationDefinitionSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.publisherId = _data["publisherId"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): MigrateObservationDefinitionSettings {
        data = typeof data === 'object' ? data : {};
        let result = new MigrateObservationDefinitionSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["publisherId"] = this.publisherId;
        data["version"] = this.version;
        return data; 
    }
}

export interface IMigrateObservationDefinitionSettings {
    publisherId: string;
    version: number;
}

export class DuplicateObservationDefinitionSettings implements IDuplicateObservationDefinitionSettings {
    name!: string;
    description!: string;
    /** List of consumers to be migrated with the new observation definition. */
    consumerIds!: string[];
    dryRun?: boolean;

    constructor(data?: IDuplicateObservationDefinitionSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.consumerIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["consumerIds"])) {
                this.consumerIds = [] as any;
                for (let item of _data["consumerIds"])
                    this.consumerIds!.push(item);
            }
            this.dryRun = _data["dryRun"];
        }
    }

    static fromJS(data: any): DuplicateObservationDefinitionSettings {
        data = typeof data === 'object' ? data : {};
        let result = new DuplicateObservationDefinitionSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.consumerIds)) {
            data["consumerIds"] = [];
            for (let item of this.consumerIds)
                data["consumerIds"].push(item);
        }
        data["dryRun"] = this.dryRun;
        return data; 
    }
}

export interface IDuplicateObservationDefinitionSettings {
    name: string;
    description: string;
    /** List of consumers to be migrated with the new observation definition. */
    consumerIds: string[];
    dryRun?: boolean;
}

export class BatchMergeObservationAnonymousUsersSettings implements IBatchMergeObservationAnonymousUsersSettings {
    definitionId!: string;
    groupId!: string;
    anonymousUsers!: string[];
    userId!: string;

    constructor(data?: IBatchMergeObservationAnonymousUsersSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.anonymousUsers = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.definitionId = _data["definitionId"];
            this.groupId = _data["groupId"];
            if (Array.isArray(_data["anonymousUsers"])) {
                this.anonymousUsers = [] as any;
                for (let item of _data["anonymousUsers"])
                    this.anonymousUsers!.push(item);
            }
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): BatchMergeObservationAnonymousUsersSettings {
        data = typeof data === 'object' ? data : {};
        let result = new BatchMergeObservationAnonymousUsersSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["definitionId"] = this.definitionId;
        data["groupId"] = this.groupId;
        if (Array.isArray(this.anonymousUsers)) {
            data["anonymousUsers"] = [];
            for (let item of this.anonymousUsers)
                data["anonymousUsers"].push(item);
        }
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IBatchMergeObservationAnonymousUsersSettings {
    definitionId: string;
    groupId: string;
    anonymousUsers: string[];
    userId: string;
}

export class ListOfObservationSettings implements IListOfObservationSettings {
    totalItemCount!: number;
    items!: ObservationSettings[];

    constructor(data?: IListOfObservationSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ObservationSettings.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfObservationSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfObservationSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfObservationSettings {
    totalItemCount: number;
    items: ObservationSettings[];
}

export class ObservationSettings implements IObservationSettings {
    id?: string | undefined;
    organisationId?: string | undefined;
    definitionId?: string | undefined;
    publisherId?: string | undefined;
    privacy?: PrivacyLevel;
    version?: number;

    constructor(data?: IObservationSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.organisationId = _data["organisationId"];
            this.definitionId = _data["definitionId"];
            this.publisherId = _data["publisherId"];
            this.privacy = _data["privacy"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): ObservationSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ObservationSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["organisationId"] = this.organisationId;
        data["definitionId"] = this.definitionId;
        data["publisherId"] = this.publisherId;
        data["privacy"] = this.privacy;
        data["version"] = this.version;
        return data; 
    }
}

export interface IObservationSettings {
    id?: string | undefined;
    organisationId?: string | undefined;
    definitionId?: string | undefined;
    publisherId?: string | undefined;
    privacy?: PrivacyLevel;
    version?: number;
}

/** 0 = Public 1 = Closed 2 = Secret */
export enum PrivacyLevel {
    Public = 0,
    Closed = 1,
    Secret = 2,
}

export class CreateObservationSettingsSettings implements ICreateObservationSettingsSettings {
    organisationId!: string;
    definitionId!: string;
    privacy?: PrivacyLevel;

    constructor(data?: ICreateObservationSettingsSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organisationId = _data["organisationId"];
            this.definitionId = _data["definitionId"];
            this.privacy = _data["privacy"];
        }
    }

    static fromJS(data: any): CreateObservationSettingsSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateObservationSettingsSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organisationId"] = this.organisationId;
        data["definitionId"] = this.definitionId;
        data["privacy"] = this.privacy;
        return data; 
    }
}

export interface ICreateObservationSettingsSettings {
    organisationId: string;
    definitionId: string;
    privacy?: PrivacyLevel;
}

export class UpdateObservationSettingsSettings implements IUpdateObservationSettingsSettings {
    privacy?: PrivacyLevel;
    version?: number;

    constructor(data?: IUpdateObservationSettingsSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.privacy = _data["privacy"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateObservationSettingsSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateObservationSettingsSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["privacy"] = this.privacy;
        data["version"] = this.version;
        return data; 
    }
}

export interface IUpdateObservationSettingsSettings {
    privacy?: PrivacyLevel;
    version?: number;
}

export class Customer implements ICustomer {
    id?: string | undefined;
    userId?: string | undefined;

    constructor(data?: ICustomer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): Customer {
        data = typeof data === 'object' ? data : {};
        let result = new Customer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface ICustomer {
    id?: string | undefined;
    userId?: string | undefined;
}

export class Merchant implements IMerchant {
    id?: string | undefined;
    publisherId?: string | undefined;
    verified?: boolean;

    constructor(data?: IMerchant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.publisherId = _data["publisherId"];
            this.verified = _data["verified"];
        }
    }

    static fromJS(data: any): Merchant {
        data = typeof data === 'object' ? data : {};
        let result = new Merchant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["publisherId"] = this.publisherId;
        data["verified"] = this.verified;
        return data; 
    }
}

export interface IMerchant {
    id?: string | undefined;
    publisherId?: string | undefined;
    verified?: boolean;
}

export class Payment implements IPayment {
    id?: string | undefined;
    created?: Date;
    userId?: string | undefined;
    customerId?: string | undefined;
    publisherId?: string | undefined;
    merchantId?: string | undefined;
    productId?: string | undefined;
    itemId?: string | undefined;
    currencyCode?: string | undefined;
    amount?: number;
    merchantAmount?: number;
    status?: PaymentStatus;

    constructor(data?: IPayment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.customerId = _data["customerId"];
            this.publisherId = _data["publisherId"];
            this.merchantId = _data["merchantId"];
            this.productId = _data["productId"];
            this.itemId = _data["itemId"];
            this.currencyCode = _data["currencyCode"];
            this.amount = _data["amount"];
            this.merchantAmount = _data["merchantAmount"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): Payment {
        data = typeof data === 'object' ? data : {};
        let result = new Payment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["customerId"] = this.customerId;
        data["publisherId"] = this.publisherId;
        data["merchantId"] = this.merchantId;
        data["productId"] = this.productId;
        data["itemId"] = this.itemId;
        data["currencyCode"] = this.currencyCode;
        data["amount"] = this.amount;
        data["merchantAmount"] = this.merchantAmount;
        data["status"] = this.status;
        return data; 
    }
}

export interface IPayment {
    id?: string | undefined;
    created?: Date;
    userId?: string | undefined;
    customerId?: string | undefined;
    publisherId?: string | undefined;
    merchantId?: string | undefined;
    productId?: string | undefined;
    itemId?: string | undefined;
    currencyCode?: string | undefined;
    amount?: number;
    merchantAmount?: number;
    status?: PaymentStatus;
}

/** 0 = None 1 = Pending 2 = Succeeded 3 = Failed 4 = Refunded */
export enum PaymentStatus {
    None = 0,
    Pending = 1,
    Succeeded = 2,
    Failed = 3,
    Refunded = 4,
}

export class CreatePaymentSettings implements ICreatePaymentSettings {
    productId!: string;
    token!: string;

    constructor(data?: ICreatePaymentSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): CreatePaymentSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePaymentSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["token"] = this.token;
        return data; 
    }
}

export interface ICreatePaymentSettings {
    productId: string;
    token: string;
}

export class Region implements IRegion {
    name?: string | undefined;
    countries?: Country[] | undefined;

    constructor(data?: IRegion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["countries"])) {
                this.countries = [] as any;
                for (let item of _data["countries"])
                    this.countries!.push(Country.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Region {
        data = typeof data === 'object' ? data : {};
        let result = new Region();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.countries)) {
            data["countries"] = [];
            for (let item of this.countries)
                data["countries"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRegion {
    name?: string | undefined;
    countries?: Country[] | undefined;
}

export class Country implements ICountry {
    name?: string | undefined;
    code?: string | undefined;
    currencies?: Currency[] | undefined;

    constructor(data?: ICountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            if (Array.isArray(_data["currencies"])) {
                this.currencies = [] as any;
                for (let item of _data["currencies"])
                    this.currencies!.push(Currency.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Country {
        data = typeof data === 'object' ? data : {};
        let result = new Country();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        if (Array.isArray(this.currencies)) {
            data["currencies"] = [];
            for (let item of this.currencies)
                data["currencies"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICountry {
    name?: string | undefined;
    code?: string | undefined;
    currencies?: Currency[] | undefined;
}

export class Currency implements ICurrency {
    name?: string | undefined;
    code?: string | undefined;
    symbol?: string | undefined;

    constructor(data?: ICurrency) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.symbol = _data["symbol"];
        }
    }

    static fromJS(data: any): Currency {
        data = typeof data === 'object' ? data : {};
        let result = new Currency();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["symbol"] = this.symbol;
        return data; 
    }
}

export interface ICurrency {
    name?: string | undefined;
    code?: string | undefined;
    symbol?: string | undefined;
}

export class Product implements IProduct {
    id?: string | undefined;
    itemName?: string | undefined;
    itemType?: string | undefined;
    itemDescription?: string | undefined;
    publisherId?: string | undefined;
    publisherName?: string | undefined;
    publisherApproved?: boolean;
    programId?: string | undefined;
    programName?: string | undefined;
    merchantId?: string | undefined;
    itemId?: string | undefined;
    prices?: Price[] | undefined;
    published?: boolean;
    version?: number;

    constructor(data?: IProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.itemName = _data["itemName"];
            this.itemType = _data["itemType"];
            this.itemDescription = _data["itemDescription"];
            this.publisherId = _data["publisherId"];
            this.publisherName = _data["publisherName"];
            this.publisherApproved = _data["publisherApproved"];
            this.programId = _data["programId"];
            this.programName = _data["programName"];
            this.merchantId = _data["merchantId"];
            this.itemId = _data["itemId"];
            if (Array.isArray(_data["prices"])) {
                this.prices = [] as any;
                for (let item of _data["prices"])
                    this.prices!.push(Price.fromJS(item));
            }
            this.published = _data["published"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): Product {
        data = typeof data === 'object' ? data : {};
        let result = new Product();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["itemName"] = this.itemName;
        data["itemType"] = this.itemType;
        data["itemDescription"] = this.itemDescription;
        data["publisherId"] = this.publisherId;
        data["publisherName"] = this.publisherName;
        data["publisherApproved"] = this.publisherApproved;
        data["programId"] = this.programId;
        data["programName"] = this.programName;
        data["merchantId"] = this.merchantId;
        data["itemId"] = this.itemId;
        if (Array.isArray(this.prices)) {
            data["prices"] = [];
            for (let item of this.prices)
                data["prices"].push(item.toJSON());
        }
        data["published"] = this.published;
        data["version"] = this.version;
        return data; 
    }
}

export interface IProduct {
    id?: string | undefined;
    itemName?: string | undefined;
    itemType?: string | undefined;
    itemDescription?: string | undefined;
    publisherId?: string | undefined;
    publisherName?: string | undefined;
    publisherApproved?: boolean;
    programId?: string | undefined;
    programName?: string | undefined;
    merchantId?: string | undefined;
    itemId?: string | undefined;
    prices?: Price[] | undefined;
    published?: boolean;
    version?: number;
}

export class Price implements IPrice {
    countryCode?: string | undefined;
    currencyCode?: string | undefined;
    amount?: number;

    constructor(data?: IPrice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.countryCode = _data["countryCode"];
            this.currencyCode = _data["currencyCode"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): Price {
        data = typeof data === 'object' ? data : {};
        let result = new Price();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryCode"] = this.countryCode;
        data["currencyCode"] = this.currencyCode;
        data["amount"] = this.amount;
        return data; 
    }
}

export interface IPrice {
    countryCode?: string | undefined;
    currencyCode?: string | undefined;
    amount?: number;
}

export class CreateProductSettings implements ICreateProductSettings {
    publisherId!: string;
    itemId!: string;
    published?: boolean;
    prices?: Price[] | undefined;

    constructor(data?: ICreateProductSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.publisherId = _data["publisherId"];
            this.itemId = _data["itemId"];
            this.published = _data["published"];
            if (Array.isArray(_data["prices"])) {
                this.prices = [] as any;
                for (let item of _data["prices"])
                    this.prices!.push(Price.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateProductSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["publisherId"] = this.publisherId;
        data["itemId"] = this.itemId;
        data["published"] = this.published;
        if (Array.isArray(this.prices)) {
            data["prices"] = [];
            for (let item of this.prices)
                data["prices"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateProductSettings {
    publisherId: string;
    itemId: string;
    published?: boolean;
    prices?: Price[] | undefined;
}

export class UpdateProductSettings implements IUpdateProductSettings {
    prices?: Price[] | undefined;
    published?: boolean;
    version!: number;

    constructor(data?: IUpdateProductSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["prices"])) {
                this.prices = [] as any;
                for (let item of _data["prices"])
                    this.prices!.push(Price.fromJS(item));
            }
            this.published = _data["published"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateProductSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.prices)) {
            data["prices"] = [];
            for (let item of this.prices)
                data["prices"].push(item.toJSON());
        }
        data["published"] = this.published;
        data["version"] = this.version;
        return data; 
    }
}

export interface IUpdateProductSettings {
    prices?: Price[] | undefined;
    published?: boolean;
    version: number;
}

export class ListOfPublisher implements IListOfPublisher {
    totalItemCount!: number;
    items!: Publisher[];

    constructor(data?: IListOfPublisher) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Publisher.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfPublisher {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfPublisher();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfPublisher {
    totalItemCount: number;
    items: Publisher[];
}

export class Publisher implements IPublisher {
    id?: string | undefined;
    requested?: boolean;
    request?: PublishingOptions | undefined;
    approved?: boolean;
    publishing?: PublishingOptions | undefined;

    constructor(data?: IPublisher) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.requested = _data["requested"];
            this.request = _data["request"] ? PublishingOptions.fromJS(_data["request"]) : <any>undefined;
            this.approved = _data["approved"];
            this.publishing = _data["publishing"] ? PublishingOptions.fromJS(_data["publishing"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Publisher {
        data = typeof data === 'object' ? data : {};
        let result = new Publisher();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["requested"] = this.requested;
        data["request"] = this.request ? this.request.toJSON() : <any>undefined;
        data["approved"] = this.approved;
        data["publishing"] = this.publishing ? this.publishing.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPublisher {
    id?: string | undefined;
    requested?: boolean;
    request?: PublishingOptions | undefined;
    approved?: boolean;
    publishing?: PublishingOptions | undefined;
}

export class PublishingOptions implements IPublishingOptions {
    freeBusinessToConsumer?: boolean;
    paidBusinessToConsumer?: boolean;
    businessToBusiness?: boolean;

    constructor(data?: IPublishingOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.freeBusinessToConsumer = _data["freeBusinessToConsumer"];
            this.paidBusinessToConsumer = _data["paidBusinessToConsumer"];
            this.businessToBusiness = _data["businessToBusiness"];
        }
    }

    static fromJS(data: any): PublishingOptions {
        data = typeof data === 'object' ? data : {};
        let result = new PublishingOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["freeBusinessToConsumer"] = this.freeBusinessToConsumer;
        data["paidBusinessToConsumer"] = this.paidBusinessToConsumer;
        data["businessToBusiness"] = this.businessToBusiness;
        return data; 
    }
}

export interface IPublishingOptions {
    freeBusinessToConsumer?: boolean;
    paidBusinessToConsumer?: boolean;
    businessToBusiness?: boolean;
}

export class RequestPublisherSettings implements IRequestPublisherSettings {
    options!: PublishingOptions;
    notes?: string | undefined;
    approvalUri?: string | undefined;

    constructor(data?: IRequestPublisherSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.options = new PublishingOptions();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.options = _data["options"] ? PublishingOptions.fromJS(_data["options"]) : new PublishingOptions();
            this.notes = _data["notes"];
            this.approvalUri = _data["approvalUri"];
        }
    }

    static fromJS(data: any): RequestPublisherSettings {
        data = typeof data === 'object' ? data : {};
        let result = new RequestPublisherSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["options"] = this.options ? this.options.toJSON() : <any>undefined;
        data["notes"] = this.notes;
        data["approvalUri"] = this.approvalUri;
        return data; 
    }
}

export interface IRequestPublisherSettings {
    options: PublishingOptions;
    notes?: string | undefined;
    approvalUri?: string | undefined;
}

export class ApprovePublisherSettings implements IApprovePublisherSettings {
    options!: PublishingOptions;
    notes?: string | undefined;
    publishingUri?: string | undefined;

    constructor(data?: IApprovePublisherSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.options = new PublishingOptions();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.options = _data["options"] ? PublishingOptions.fromJS(_data["options"]) : new PublishingOptions();
            this.notes = _data["notes"];
            this.publishingUri = _data["publishingUri"];
        }
    }

    static fromJS(data: any): ApprovePublisherSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovePublisherSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["options"] = this.options ? this.options.toJSON() : <any>undefined;
        data["notes"] = this.notes;
        data["publishingUri"] = this.publishingUri;
        return data; 
    }
}

export interface IApprovePublisherSettings {
    options: PublishingOptions;
    notes?: string | undefined;
    publishingUri?: string | undefined;
}

export class ListOfImplementation implements IListOfImplementation {
    totalItemCount!: number;
    items!: Implementation[];

    constructor(data?: IListOfImplementation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Implementation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfImplementation {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfImplementation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfImplementation {
    totalItemCount: number;
    items: Implementation[];
}

export class Implementation implements IImplementation {
    id?: string | undefined;
    templateId?: string | undefined;
    creatorId?: string | undefined;
    publisherId?: string | undefined;
    publisherName?: string | undefined;
    publisherLogoUri?: string | undefined;
    consumerId?: string | undefined;
    consumerName?: string | undefined;
    consumerLogoUri?: string | undefined;
    teamId?: string | undefined;
    teamName?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    startDate?: Date | undefined;
    archived?: boolean;
    phases?: PhaseInImplementation[] | undefined;
    version?: number;

    constructor(data?: IImplementation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.templateId = _data["templateId"];
            this.creatorId = _data["creatorId"];
            this.publisherId = _data["publisherId"];
            this.publisherName = _data["publisherName"];
            this.publisherLogoUri = _data["publisherLogoUri"];
            this.consumerId = _data["consumerId"];
            this.consumerName = _data["consumerName"];
            this.consumerLogoUri = _data["consumerLogoUri"];
            this.teamId = _data["teamId"];
            this.teamName = _data["teamName"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.archived = _data["archived"];
            if (Array.isArray(_data["phases"])) {
                this.phases = [] as any;
                for (let item of _data["phases"])
                    this.phases!.push(PhaseInImplementation.fromJS(item));
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): Implementation {
        data = typeof data === 'object' ? data : {};
        let result = new Implementation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["templateId"] = this.templateId;
        data["creatorId"] = this.creatorId;
        data["publisherId"] = this.publisherId;
        data["publisherName"] = this.publisherName;
        data["publisherLogoUri"] = this.publisherLogoUri;
        data["consumerId"] = this.consumerId;
        data["consumerName"] = this.consumerName;
        data["consumerLogoUri"] = this.consumerLogoUri;
        data["teamId"] = this.teamId;
        data["teamName"] = this.teamName;
        data["name"] = this.name;
        data["description"] = this.description;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["archived"] = this.archived;
        if (Array.isArray(this.phases)) {
            data["phases"] = [];
            for (let item of this.phases)
                data["phases"].push(item.toJSON());
        }
        data["version"] = this.version;
        return data; 
    }
}

export interface IImplementation {
    id?: string | undefined;
    templateId?: string | undefined;
    creatorId?: string | undefined;
    publisherId?: string | undefined;
    publisherName?: string | undefined;
    publisherLogoUri?: string | undefined;
    consumerId?: string | undefined;
    consumerName?: string | undefined;
    consumerLogoUri?: string | undefined;
    teamId?: string | undefined;
    teamName?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    startDate?: Date | undefined;
    archived?: boolean;
    phases?: PhaseInImplementation[] | undefined;
    version?: number;
}

export class PhaseInImplementation implements IPhaseInImplementation {
    name?: string | undefined;
    order?: number;
    tasks?: TaskInImplementation[] | undefined;

    constructor(data?: IPhaseInImplementation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.order = _data["order"];
            if (Array.isArray(_data["tasks"])) {
                this.tasks = [] as any;
                for (let item of _data["tasks"])
                    this.tasks!.push(TaskInImplementation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PhaseInImplementation {
        data = typeof data === 'object' ? data : {};
        let result = new PhaseInImplementation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["order"] = this.order;
        if (Array.isArray(this.tasks)) {
            data["tasks"] = [];
            for (let item of this.tasks)
                data["tasks"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPhaseInImplementation {
    name?: string | undefined;
    order?: number;
    tasks?: TaskInImplementation[] | undefined;
}

export class TaskInImplementation implements ITaskInImplementation {
    id?: string | undefined;
    name?: string | undefined;
    order?: number;
    status?: TaskStatus;

    constructor(data?: ITaskInImplementation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.order = _data["order"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): TaskInImplementation {
        data = typeof data === 'object' ? data : {};
        let result = new TaskInImplementation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["order"] = this.order;
        data["status"] = this.status;
        return data; 
    }
}

export interface ITaskInImplementation {
    id?: string | undefined;
    name?: string | undefined;
    order?: number;
    status?: TaskStatus;
}

/** 0 = None 1 = NotStarted 2 = Started 3 = Complete 4 = Rejected */
export enum TaskStatus {
    None = 0,
    NotStarted = 1,
    Started = 2,
    Complete = 3,
    Rejected = 4,
}

export class ListOfTask implements IListOfTask {
    totalItemCount!: number;
    items!: Task[];

    constructor(data?: IListOfTask) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Task.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfTask {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfTask {
    totalItemCount: number;
    items: Task[];
}

export class Task implements ITask {
    id?: string | undefined;
    groupId?: string | undefined;
    creatorId?: string | undefined;
    creatorName?: string | undefined;
    creatorImageUri?: string | undefined;
    templateId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    estimatedDuration?: string;
    status?: TaskStatus;
    due?: Date | undefined;
    subtasks?: SubtaskInTask[] | undefined;
    assignees?: AssigneeInTask[] | undefined;
    version?: number;

    constructor(data?: ITask) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.groupId = _data["groupId"];
            this.creatorId = _data["creatorId"];
            this.creatorName = _data["creatorName"];
            this.creatorImageUri = _data["creatorImageUri"];
            this.templateId = _data["templateId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.estimatedDuration = _data["estimatedDuration"];
            this.status = _data["status"];
            this.due = _data["due"] ? new Date(_data["due"].toString()) : <any>undefined;
            if (Array.isArray(_data["subtasks"])) {
                this.subtasks = [] as any;
                for (let item of _data["subtasks"])
                    this.subtasks!.push(SubtaskInTask.fromJS(item));
            }
            if (Array.isArray(_data["assignees"])) {
                this.assignees = [] as any;
                for (let item of _data["assignees"])
                    this.assignees!.push(AssigneeInTask.fromJS(item));
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): Task {
        data = typeof data === 'object' ? data : {};
        let result = new Task();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["groupId"] = this.groupId;
        data["creatorId"] = this.creatorId;
        data["creatorName"] = this.creatorName;
        data["creatorImageUri"] = this.creatorImageUri;
        data["templateId"] = this.templateId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["estimatedDuration"] = this.estimatedDuration;
        data["status"] = this.status;
        data["due"] = this.due ? this.due.toISOString() : <any>undefined;
        if (Array.isArray(this.subtasks)) {
            data["subtasks"] = [];
            for (let item of this.subtasks)
                data["subtasks"].push(item.toJSON());
        }
        if (Array.isArray(this.assignees)) {
            data["assignees"] = [];
            for (let item of this.assignees)
                data["assignees"].push(item.toJSON());
        }
        data["version"] = this.version;
        return data; 
    }
}

export interface ITask {
    id?: string | undefined;
    groupId?: string | undefined;
    creatorId?: string | undefined;
    creatorName?: string | undefined;
    creatorImageUri?: string | undefined;
    templateId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    estimatedDuration?: string;
    status?: TaskStatus;
    due?: Date | undefined;
    subtasks?: SubtaskInTask[] | undefined;
    assignees?: AssigneeInTask[] | undefined;
    version?: number;
}

export class SubtaskInTask implements ISubtaskInTask {
    id?: string | undefined;
    name?: string | undefined;
    order?: number;
    estimatedDuration?: string;
    status?: TaskStatus;
    due?: Date | undefined;

    constructor(data?: ISubtaskInTask) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.order = _data["order"];
            this.estimatedDuration = _data["estimatedDuration"];
            this.status = _data["status"];
            this.due = _data["due"] ? new Date(_data["due"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SubtaskInTask {
        data = typeof data === 'object' ? data : {};
        let result = new SubtaskInTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["order"] = this.order;
        data["estimatedDuration"] = this.estimatedDuration;
        data["status"] = this.status;
        data["due"] = this.due ? this.due.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ISubtaskInTask {
    id?: string | undefined;
    name?: string | undefined;
    order?: number;
    estimatedDuration?: string;
    status?: TaskStatus;
    due?: Date | undefined;
}

export class AssigneeInTask implements IAssigneeInTask {
    id?: string | undefined;
    name?: string | undefined;
    imageUri?: string | undefined;

    constructor(data?: IAssigneeInTask) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.imageUri = _data["imageUri"];
        }
    }

    static fromJS(data: any): AssigneeInTask {
        data = typeof data === 'object' ? data : {};
        let result = new AssigneeInTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["imageUri"] = this.imageUri;
        return data; 
    }
}

export interface IAssigneeInTask {
    id?: string | undefined;
    name?: string | undefined;
    imageUri?: string | undefined;
}

export class CreateImplementationSettings implements ICreateImplementationSettings {
    publisherId!: string;
    templateId?: string | undefined;
    consumerId?: string | undefined;
    teamId?: string | undefined;
    name!: string;
    description?: string | undefined;
    startDate?: Date | undefined;
    phases?: ImplementationPhase[] | undefined;

    constructor(data?: ICreateImplementationSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.publisherId = _data["publisherId"];
            this.templateId = _data["templateId"];
            this.consumerId = _data["consumerId"];
            this.teamId = _data["teamId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["phases"])) {
                this.phases = [] as any;
                for (let item of _data["phases"])
                    this.phases!.push(ImplementationPhase.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateImplementationSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateImplementationSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["publisherId"] = this.publisherId;
        data["templateId"] = this.templateId;
        data["consumerId"] = this.consumerId;
        data["teamId"] = this.teamId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        if (Array.isArray(this.phases)) {
            data["phases"] = [];
            for (let item of this.phases)
                data["phases"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateImplementationSettings {
    publisherId: string;
    templateId?: string | undefined;
    consumerId?: string | undefined;
    teamId?: string | undefined;
    name: string;
    description?: string | undefined;
    startDate?: Date | undefined;
    phases?: ImplementationPhase[] | undefined;
}

export class ImplementationPhase implements IImplementationPhase {
    name?: string | undefined;
    order?: number;
    tasks?: PhaseTask[] | undefined;

    constructor(data?: IImplementationPhase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.order = _data["order"];
            if (Array.isArray(_data["tasks"])) {
                this.tasks = [] as any;
                for (let item of _data["tasks"])
                    this.tasks!.push(PhaseTask.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ImplementationPhase {
        data = typeof data === 'object' ? data : {};
        let result = new ImplementationPhase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["order"] = this.order;
        if (Array.isArray(this.tasks)) {
            data["tasks"] = [];
            for (let item of this.tasks)
                data["tasks"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IImplementationPhase {
    name?: string | undefined;
    order?: number;
    tasks?: PhaseTask[] | undefined;
}

export class PhaseTask implements IPhaseTask {
    id?: string | undefined;
    order?: number;

    constructor(data?: IPhaseTask) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): PhaseTask {
        data = typeof data === 'object' ? data : {};
        let result = new PhaseTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["order"] = this.order;
        return data; 
    }
}

export interface IPhaseTask {
    id?: string | undefined;
    order?: number;
}

export class UpdateImplementationSettings implements IUpdateImplementationSettings {
    name!: string;
    description?: string | undefined;
    phases?: ImplementationPhase[] | undefined;
    startDate?: Date | undefined;
    archived?: boolean;
    version?: number;

    constructor(data?: IUpdateImplementationSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["phases"])) {
                this.phases = [] as any;
                for (let item of _data["phases"])
                    this.phases!.push(ImplementationPhase.fromJS(item));
            }
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.archived = _data["archived"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateImplementationSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateImplementationSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.phases)) {
            data["phases"] = [];
            for (let item of this.phases)
                data["phases"].push(item.toJSON());
        }
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["archived"] = this.archived;
        data["version"] = this.version;
        return data; 
    }
}

export interface IUpdateImplementationSettings {
    name: string;
    description?: string | undefined;
    phases?: ImplementationPhase[] | undefined;
    startDate?: Date | undefined;
    archived?: boolean;
    version?: number;
}

export class ListOfItemActivation implements IListOfItemActivation {
    totalItemCount!: number;
    items!: ItemActivation[];

    constructor(data?: IListOfItemActivation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ItemActivation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfItemActivation {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfItemActivation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfItemActivation {
    totalItemCount: number;
    items: ItemActivation[];
}

export class ItemActivation implements IItemActivation {
    id?: string | undefined;
    itemId?: string | undefined;
    itemType?: string | undefined;
    itemName?: string | undefined;
    programs?: ProgramInItemActivation[] | undefined;
    publisherId?: string | undefined;
    publisherName?: string | undefined;
    consumerOrganisationId?: string | undefined;
    consumerType?: string | undefined;
    consumerId?: string | undefined;
    consumerName?: string | undefined;
    activated?: boolean;
    version?: number;
    created?: Date;
    modified?: Date;

    constructor(data?: IItemActivation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.itemId = _data["itemId"];
            this.itemType = _data["itemType"];
            this.itemName = _data["itemName"];
            if (Array.isArray(_data["programs"])) {
                this.programs = [] as any;
                for (let item of _data["programs"])
                    this.programs!.push(ProgramInItemActivation.fromJS(item));
            }
            this.publisherId = _data["publisherId"];
            this.publisherName = _data["publisherName"];
            this.consumerOrganisationId = _data["consumerOrganisationId"];
            this.consumerType = _data["consumerType"];
            this.consumerId = _data["consumerId"];
            this.consumerName = _data["consumerName"];
            this.activated = _data["activated"];
            this.version = _data["version"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ItemActivation {
        data = typeof data === 'object' ? data : {};
        let result = new ItemActivation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["itemId"] = this.itemId;
        data["itemType"] = this.itemType;
        data["itemName"] = this.itemName;
        if (Array.isArray(this.programs)) {
            data["programs"] = [];
            for (let item of this.programs)
                data["programs"].push(item.toJSON());
        }
        data["publisherId"] = this.publisherId;
        data["publisherName"] = this.publisherName;
        data["consumerOrganisationId"] = this.consumerOrganisationId;
        data["consumerType"] = this.consumerType;
        data["consumerId"] = this.consumerId;
        data["consumerName"] = this.consumerName;
        data["activated"] = this.activated;
        data["version"] = this.version;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IItemActivation {
    id?: string | undefined;
    itemId?: string | undefined;
    itemType?: string | undefined;
    itemName?: string | undefined;
    programs?: ProgramInItemActivation[] | undefined;
    publisherId?: string | undefined;
    publisherName?: string | undefined;
    consumerOrganisationId?: string | undefined;
    consumerType?: string | undefined;
    consumerId?: string | undefined;
    consumerName?: string | undefined;
    activated?: boolean;
    version?: number;
    created?: Date;
    modified?: Date;
}

export class ProgramInItemActivation implements IProgramInItemActivation {
    id?: string | undefined;
    name?: string | undefined;

    constructor(data?: IProgramInItemActivation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ProgramInItemActivation {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramInItemActivation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IProgramInItemActivation {
    id?: string | undefined;
    name?: string | undefined;
}

export class ListOfProgramActivation implements IListOfProgramActivation {
    totalItemCount!: number;
    items!: ProgramActivation[];

    constructor(data?: IListOfProgramActivation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProgramActivation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfProgramActivation {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfProgramActivation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfProgramActivation {
    totalItemCount: number;
    items: ProgramActivation[];
}

export class ProgramActivation implements IProgramActivation {
    id?: string | undefined;
    programId?: string | undefined;
    consumerType?: string | undefined;
    consumerId?: string | undefined;
    consumerName?: string | undefined;
    launchedAt?: Date;
    sponsor?: string | undefined;
    currentPhaseId?: string | undefined;
    phaseActivations?: PhaseActivationInProgramActivation[] | undefined;
    version?: number;

    constructor(data?: IProgramActivation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.programId = _data["programId"];
            this.consumerType = _data["consumerType"];
            this.consumerId = _data["consumerId"];
            this.consumerName = _data["consumerName"];
            this.launchedAt = _data["launchedAt"] ? new Date(_data["launchedAt"].toString()) : <any>undefined;
            this.sponsor = _data["sponsor"];
            this.currentPhaseId = _data["currentPhaseId"];
            if (Array.isArray(_data["phaseActivations"])) {
                this.phaseActivations = [] as any;
                for (let item of _data["phaseActivations"])
                    this.phaseActivations!.push(PhaseActivationInProgramActivation.fromJS(item));
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): ProgramActivation {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramActivation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["programId"] = this.programId;
        data["consumerType"] = this.consumerType;
        data["consumerId"] = this.consumerId;
        data["consumerName"] = this.consumerName;
        data["launchedAt"] = this.launchedAt ? this.launchedAt.toISOString() : <any>undefined;
        data["sponsor"] = this.sponsor;
        data["currentPhaseId"] = this.currentPhaseId;
        if (Array.isArray(this.phaseActivations)) {
            data["phaseActivations"] = [];
            for (let item of this.phaseActivations)
                data["phaseActivations"].push(item.toJSON());
        }
        data["version"] = this.version;
        return data; 
    }
}

export interface IProgramActivation {
    id?: string | undefined;
    programId?: string | undefined;
    consumerType?: string | undefined;
    consumerId?: string | undefined;
    consumerName?: string | undefined;
    launchedAt?: Date;
    sponsor?: string | undefined;
    currentPhaseId?: string | undefined;
    phaseActivations?: PhaseActivationInProgramActivation[] | undefined;
    version?: number;
}

export class PhaseActivationInProgramActivation implements IPhaseActivationInProgramActivation {
    id?: string | undefined;
    status?: ProgramPhaseActivationStatus;

    constructor(data?: IPhaseActivationInProgramActivation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): PhaseActivationInProgramActivation {
        data = typeof data === 'object' ? data : {};
        let result = new PhaseActivationInProgramActivation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        return data; 
    }
}

export interface IPhaseActivationInProgramActivation {
    id?: string | undefined;
    status?: ProgramPhaseActivationStatus;
}

/** 0 = NotActivated 1 = Requested 2 = Activated 3 = Deactivated */
export enum ProgramPhaseActivationStatus {
    NotActivated = 0,
    Requested = 1,
    Activated = 2,
    Deactivated = 3,
}

export class ActivateProgramPhaseSettings implements IActivateProgramPhaseSettings {
    consumerId!: string;
    programPhaseId!: string;
    sponsor?: string | undefined;

    constructor(data?: IActivateProgramPhaseSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.consumerId = _data["consumerId"];
            this.programPhaseId = _data["programPhaseId"];
            this.sponsor = _data["sponsor"];
        }
    }

    static fromJS(data: any): ActivateProgramPhaseSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateProgramPhaseSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consumerId"] = this.consumerId;
        data["programPhaseId"] = this.programPhaseId;
        data["sponsor"] = this.sponsor;
        return data; 
    }
}

export interface IActivateProgramPhaseSettings {
    consumerId: string;
    programPhaseId: string;
    sponsor?: string | undefined;
}

export class ListOfProgram implements IListOfProgram {
    totalItemCount!: number;
    items!: Program[];

    constructor(data?: IListOfProgram) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Program.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfProgram {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfProgram();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfProgram {
    totalItemCount: number;
    items: Program[];
}

export class Program implements IProgram {
    id?: string | undefined;
    name?: string | undefined;
    logoUri?: string | undefined;
    bannerUri?: string | undefined;
    publisherId?: string | undefined;
    publisherName?: string | undefined;
    publisherLogoUri?: string | undefined;
    resources?: ProgramResource[] | undefined;
    phases?: ProgramPhaseInProgram[] | undefined;
    version?: number;

    constructor(data?: IProgram) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.logoUri = _data["logoUri"];
            this.bannerUri = _data["bannerUri"];
            this.publisherId = _data["publisherId"];
            this.publisherName = _data["publisherName"];
            this.publisherLogoUri = _data["publisherLogoUri"];
            if (Array.isArray(_data["resources"])) {
                this.resources = [] as any;
                for (let item of _data["resources"])
                    this.resources!.push(ProgramResource.fromJS(item));
            }
            if (Array.isArray(_data["phases"])) {
                this.phases = [] as any;
                for (let item of _data["phases"])
                    this.phases!.push(ProgramPhaseInProgram.fromJS(item));
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): Program {
        data = typeof data === 'object' ? data : {};
        let result = new Program();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["logoUri"] = this.logoUri;
        data["bannerUri"] = this.bannerUri;
        data["publisherId"] = this.publisherId;
        data["publisherName"] = this.publisherName;
        data["publisherLogoUri"] = this.publisherLogoUri;
        if (Array.isArray(this.resources)) {
            data["resources"] = [];
            for (let item of this.resources)
                data["resources"].push(item.toJSON());
        }
        if (Array.isArray(this.phases)) {
            data["phases"] = [];
            for (let item of this.phases)
                data["phases"].push(item.toJSON());
        }
        data["version"] = this.version;
        return data; 
    }
}

export interface IProgram {
    id?: string | undefined;
    name?: string | undefined;
    logoUri?: string | undefined;
    bannerUri?: string | undefined;
    publisherId?: string | undefined;
    publisherName?: string | undefined;
    publisherLogoUri?: string | undefined;
    resources?: ProgramResource[] | undefined;
    phases?: ProgramPhaseInProgram[] | undefined;
    version?: number;
}

export class ProgramResource implements IProgramResource {
    id?: string | undefined;
    type?: ProgramResourceType;

    constructor(data?: IProgramResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ProgramResource {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        return data; 
    }
}

export interface IProgramResource {
    id?: string | undefined;
    type?: ProgramResourceType;
}

/** 0 = Course 1 = ObservationDefinition 2 = Survey 3 = Implementation */
export enum ProgramResourceType {
    Course = 0,
    ObservationDefinition = 1,
    Survey = 2,
    Implementation = 3,
}

export class ProgramPhaseInProgram implements IProgramPhaseInProgram {
    id?: string | undefined;
    resources?: ProgramResource[] | undefined;

    constructor(data?: IProgramPhaseInProgram) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["resources"])) {
                this.resources = [] as any;
                for (let item of _data["resources"])
                    this.resources!.push(ProgramResource.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProgramPhaseInProgram {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramPhaseInProgram();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.resources)) {
            data["resources"] = [];
            for (let item of this.resources)
                data["resources"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProgramPhaseInProgram {
    id?: string | undefined;
    resources?: ProgramResource[] | undefined;
}

export class CreateProgramSettings implements ICreateProgramSettings {
    publisherId!: string;
    name!: string;
    bannerUri?: string | undefined;
    logoUri?: string | undefined;
    resources?: ProgramResource[] | undefined;

    constructor(data?: ICreateProgramSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.publisherId = _data["publisherId"];
            this.name = _data["name"];
            this.bannerUri = _data["bannerUri"];
            this.logoUri = _data["logoUri"];
            if (Array.isArray(_data["resources"])) {
                this.resources = [] as any;
                for (let item of _data["resources"])
                    this.resources!.push(ProgramResource.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateProgramSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProgramSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["publisherId"] = this.publisherId;
        data["name"] = this.name;
        data["bannerUri"] = this.bannerUri;
        data["logoUri"] = this.logoUri;
        if (Array.isArray(this.resources)) {
            data["resources"] = [];
            for (let item of this.resources)
                data["resources"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateProgramSettings {
    publisherId: string;
    name: string;
    bannerUri?: string | undefined;
    logoUri?: string | undefined;
    resources?: ProgramResource[] | undefined;
}

export class UpdateProgramSettings implements IUpdateProgramSettings {
    name!: string;
    bannerUri?: string | undefined;
    logoUri?: string | undefined;
    resources?: ProgramResource[] | undefined;
    version?: number;

    constructor(data?: IUpdateProgramSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.bannerUri = _data["bannerUri"];
            this.logoUri = _data["logoUri"];
            if (Array.isArray(_data["resources"])) {
                this.resources = [] as any;
                for (let item of _data["resources"])
                    this.resources!.push(ProgramResource.fromJS(item));
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateProgramSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProgramSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["bannerUri"] = this.bannerUri;
        data["logoUri"] = this.logoUri;
        if (Array.isArray(this.resources)) {
            data["resources"] = [];
            for (let item of this.resources)
                data["resources"].push(item.toJSON());
        }
        data["version"] = this.version;
        return data; 
    }
}

export interface IUpdateProgramSettings {
    name: string;
    bannerUri?: string | undefined;
    logoUri?: string | undefined;
    resources?: ProgramResource[] | undefined;
    version?: number;
}

export class ProgramPhase implements IProgramPhase {
    id?: string | undefined;
    publisherId?: string | undefined;
    publisherName?: string | undefined;
    publisherLogoUri?: string | undefined;
    programId?: string | undefined;
    programName?: string | undefined;
    programLogoUri?: string | undefined;
    programBannerUri?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    resources?: ProgramResource[] | undefined;
    version?: number;

    constructor(data?: IProgramPhase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.publisherId = _data["publisherId"];
            this.publisherName = _data["publisherName"];
            this.publisherLogoUri = _data["publisherLogoUri"];
            this.programId = _data["programId"];
            this.programName = _data["programName"];
            this.programLogoUri = _data["programLogoUri"];
            this.programBannerUri = _data["programBannerUri"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["resources"])) {
                this.resources = [] as any;
                for (let item of _data["resources"])
                    this.resources!.push(ProgramResource.fromJS(item));
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): ProgramPhase {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramPhase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["publisherId"] = this.publisherId;
        data["publisherName"] = this.publisherName;
        data["publisherLogoUri"] = this.publisherLogoUri;
        data["programId"] = this.programId;
        data["programName"] = this.programName;
        data["programLogoUri"] = this.programLogoUri;
        data["programBannerUri"] = this.programBannerUri;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.resources)) {
            data["resources"] = [];
            for (let item of this.resources)
                data["resources"].push(item.toJSON());
        }
        data["version"] = this.version;
        return data; 
    }
}

export interface IProgramPhase {
    id?: string | undefined;
    publisherId?: string | undefined;
    publisherName?: string | undefined;
    publisherLogoUri?: string | undefined;
    programId?: string | undefined;
    programName?: string | undefined;
    programLogoUri?: string | undefined;
    programBannerUri?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    resources?: ProgramResource[] | undefined;
    version?: number;
}

export class CreateProgramPhaseSettings implements ICreateProgramPhaseSettings {
    programId!: string;
    name!: string;
    description?: string | undefined;
    resources?: ProgramResource[] | undefined;

    constructor(data?: ICreateProgramPhaseSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.programId = _data["programId"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["resources"])) {
                this.resources = [] as any;
                for (let item of _data["resources"])
                    this.resources!.push(ProgramResource.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateProgramPhaseSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProgramPhaseSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["programId"] = this.programId;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.resources)) {
            data["resources"] = [];
            for (let item of this.resources)
                data["resources"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateProgramPhaseSettings {
    programId: string;
    name: string;
    description?: string | undefined;
    resources?: ProgramResource[] | undefined;
}

export class UpdateProgramPhaseSettings implements IUpdateProgramPhaseSettings {
    name!: string;
    description?: string | undefined;
    resources?: ProgramResource[] | undefined;
    version?: number;

    constructor(data?: IUpdateProgramPhaseSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["resources"])) {
                this.resources = [] as any;
                for (let item of _data["resources"])
                    this.resources!.push(ProgramResource.fromJS(item));
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateProgramPhaseSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProgramPhaseSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.resources)) {
            data["resources"] = [];
            for (let item of this.resources)
                data["resources"].push(item.toJSON());
        }
        data["version"] = this.version;
        return data; 
    }
}

export interface IUpdateProgramPhaseSettings {
    name: string;
    description?: string | undefined;
    resources?: ProgramResource[] | undefined;
    version?: number;
}

export class ListOfComment implements IListOfComment {
    totalItemCount!: number;
    items!: Comment[];

    constructor(data?: IListOfComment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Comment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfComment {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfComment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfComment {
    totalItemCount: number;
    items: Comment[];
}

export class Comment implements IComment {
    id?: string | undefined;
    rootId?: string | undefined;
    parentId?: string | undefined;
    content?: string | undefined;
    creatorId?: string | undefined;
    creatorName?: string | undefined;
    creatorImageUri?: string | undefined;
    creatorJobTypeId?: string | undefined;
    creatorJobTypeName?: string | undefined;
    created?: Date;
    modifierId?: string | undefined;
    modifierName?: string | undefined;
    modified?: Date;
    replyCount?: number;
    version?: number;

    constructor(data?: IComment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.rootId = _data["rootId"];
            this.parentId = _data["parentId"];
            this.content = _data["content"];
            this.creatorId = _data["creatorId"];
            this.creatorName = _data["creatorName"];
            this.creatorImageUri = _data["creatorImageUri"];
            this.creatorJobTypeId = _data["creatorJobTypeId"];
            this.creatorJobTypeName = _data["creatorJobTypeName"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.modifierId = _data["modifierId"];
            this.modifierName = _data["modifierName"];
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
            this.replyCount = _data["replyCount"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): Comment {
        data = typeof data === 'object' ? data : {};
        let result = new Comment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["rootId"] = this.rootId;
        data["parentId"] = this.parentId;
        data["content"] = this.content;
        data["creatorId"] = this.creatorId;
        data["creatorName"] = this.creatorName;
        data["creatorImageUri"] = this.creatorImageUri;
        data["creatorJobTypeId"] = this.creatorJobTypeId;
        data["creatorJobTypeName"] = this.creatorJobTypeName;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["modifierId"] = this.modifierId;
        data["modifierName"] = this.modifierName;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        data["replyCount"] = this.replyCount;
        data["version"] = this.version;
        return data; 
    }
}

export interface IComment {
    id?: string | undefined;
    rootId?: string | undefined;
    parentId?: string | undefined;
    content?: string | undefined;
    creatorId?: string | undefined;
    creatorName?: string | undefined;
    creatorImageUri?: string | undefined;
    creatorJobTypeId?: string | undefined;
    creatorJobTypeName?: string | undefined;
    created?: Date;
    modifierId?: string | undefined;
    modifierName?: string | undefined;
    modified?: Date;
    replyCount?: number;
    version?: number;
}

export class CreateCommentSettings implements ICreateCommentSettings {
    parentId?: string | undefined;
    content!: string;

    constructor(data?: ICreateCommentSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentId = _data["parentId"];
            this.content = _data["content"];
        }
    }

    static fromJS(data: any): CreateCommentSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCommentSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["content"] = this.content;
        return data; 
    }
}

export interface ICreateCommentSettings {
    parentId?: string | undefined;
    content: string;
}

export class UpdateCommentSettings implements IUpdateCommentSettings {
    content!: string;
    version?: number;

    constructor(data?: IUpdateCommentSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.content = _data["content"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateCommentSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCommentSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        data["version"] = this.version;
        return data; 
    }
}

export interface IUpdateCommentSettings {
    content: string;
    version?: number;
}

export class CreateTaskSettings implements ICreateTaskSettings {
    groupId!: string;
    templateId?: string | undefined;
    name!: string;
    description?: string | undefined;
    estimatedDuration?: string;
    due?: Date | undefined;
    subtasks?: TaskSubtask[] | undefined;
    assigneeIds?: string[] | undefined;

    constructor(data?: ICreateTaskSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupId = _data["groupId"];
            this.templateId = _data["templateId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.estimatedDuration = _data["estimatedDuration"];
            this.due = _data["due"] ? new Date(_data["due"].toString()) : <any>undefined;
            if (Array.isArray(_data["subtasks"])) {
                this.subtasks = [] as any;
                for (let item of _data["subtasks"])
                    this.subtasks!.push(TaskSubtask.fromJS(item));
            }
            if (Array.isArray(_data["assigneeIds"])) {
                this.assigneeIds = [] as any;
                for (let item of _data["assigneeIds"])
                    this.assigneeIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateTaskSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTaskSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        data["templateId"] = this.templateId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["estimatedDuration"] = this.estimatedDuration;
        data["due"] = this.due ? this.due.toISOString() : <any>undefined;
        if (Array.isArray(this.subtasks)) {
            data["subtasks"] = [];
            for (let item of this.subtasks)
                data["subtasks"].push(item.toJSON());
        }
        if (Array.isArray(this.assigneeIds)) {
            data["assigneeIds"] = [];
            for (let item of this.assigneeIds)
                data["assigneeIds"].push(item);
        }
        return data; 
    }
}

export interface ICreateTaskSettings {
    groupId: string;
    templateId?: string | undefined;
    name: string;
    description?: string | undefined;
    estimatedDuration?: string;
    due?: Date | undefined;
    subtasks?: TaskSubtask[] | undefined;
    assigneeIds?: string[] | undefined;
}

export class TaskSubtask implements ITaskSubtask {
    id?: string | undefined;
    order?: number;

    constructor(data?: ITaskSubtask) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): TaskSubtask {
        data = typeof data === 'object' ? data : {};
        let result = new TaskSubtask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["order"] = this.order;
        return data; 
    }
}

export interface ITaskSubtask {
    id?: string | undefined;
    order?: number;
}

export class UpdateTaskSettings implements IUpdateTaskSettings {
    name!: string;
    description?: string | undefined;
    estimatedDuration?: string;
    status?: TaskStatus;
    due?: Date | undefined;
    subtasks?: TaskSubtask[] | undefined;
    assigneeIds?: string[] | undefined;
    version?: number;

    constructor(data?: IUpdateTaskSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.estimatedDuration = _data["estimatedDuration"];
            this.status = _data["status"];
            this.due = _data["due"] ? new Date(_data["due"].toString()) : <any>undefined;
            if (Array.isArray(_data["subtasks"])) {
                this.subtasks = [] as any;
                for (let item of _data["subtasks"])
                    this.subtasks!.push(TaskSubtask.fromJS(item));
            }
            if (Array.isArray(_data["assigneeIds"])) {
                this.assigneeIds = [] as any;
                for (let item of _data["assigneeIds"])
                    this.assigneeIds!.push(item);
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateTaskSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTaskSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["estimatedDuration"] = this.estimatedDuration;
        data["status"] = this.status;
        data["due"] = this.due ? this.due.toISOString() : <any>undefined;
        if (Array.isArray(this.subtasks)) {
            data["subtasks"] = [];
            for (let item of this.subtasks)
                data["subtasks"].push(item.toJSON());
        }
        if (Array.isArray(this.assigneeIds)) {
            data["assigneeIds"] = [];
            for (let item of this.assigneeIds)
                data["assigneeIds"].push(item);
        }
        data["version"] = this.version;
        return data; 
    }
}

export interface IUpdateTaskSettings {
    name: string;
    description?: string | undefined;
    estimatedDuration?: string;
    status?: TaskStatus;
    due?: Date | undefined;
    subtasks?: TaskSubtask[] | undefined;
    assigneeIds?: string[] | undefined;
    version?: number;
}

export class Sharing implements ISharing {
    id?: string | undefined;
    aliasId?: string | undefined;
    note?: string | undefined;
    type?: SharingType;
    payload?: any | undefined;
    creatorId?: string | undefined;
    creatorType?: IdentityType;
    created?: Date;
    expires?: Date;
    disabled?: boolean;

    constructor(data?: ISharing) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.aliasId = _data["aliasId"];
            this.note = _data["note"];
            this.type = _data["type"];
            this.payload = _data["payload"];
            this.creatorId = _data["creatorId"];
            this.creatorType = _data["creatorType"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.expires = _data["expires"] ? new Date(_data["expires"].toString()) : <any>undefined;
            this.disabled = _data["disabled"];
        }
    }

    static fromJS(data: any): Sharing {
        data = typeof data === 'object' ? data : {};
        let result = new Sharing();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["aliasId"] = this.aliasId;
        data["note"] = this.note;
        data["type"] = this.type;
        data["payload"] = this.payload;
        data["creatorId"] = this.creatorId;
        data["creatorType"] = this.creatorType;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["expires"] = this.expires ? this.expires.toISOString() : <any>undefined;
        data["disabled"] = this.disabled;
        return data; 
    }
}

export interface ISharing {
    id?: string | undefined;
    aliasId?: string | undefined;
    note?: string | undefined;
    type?: SharingType;
    payload?: any | undefined;
    creatorId?: string | undefined;
    creatorType?: IdentityType;
    created?: Date;
    expires?: Date;
    disabled?: boolean;
}

export enum SharingType {
    GroupInvitation = "GroupInvitation",
}

/** 0 = None 1 = User 2 = Organisation */
export enum IdentityType {
    None = 0,
    User = 1,
    Organisation = 2,
}

export class ListOfSharing implements IListOfSharing {
    totalItemCount!: number;
    items!: Sharing[];

    constructor(data?: IListOfSharing) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Sharing.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfSharing {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfSharing();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfSharing {
    totalItemCount: number;
    items: Sharing[];
}

export class CreateSharingSettingsBase implements ICreateSharingSettingsBase {
    aliasId?: string | undefined;
    note?: string | undefined;
    duration?: string | undefined;

    constructor(data?: ICreateSharingSettingsBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.aliasId = _data["aliasId"];
            this.note = _data["note"];
            this.duration = _data["duration"];
        }
    }

    static fromJS(data: any): CreateSharingSettingsBase {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSharingSettingsBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["aliasId"] = this.aliasId;
        data["note"] = this.note;
        data["duration"] = this.duration;
        return data; 
    }
}

export interface ICreateSharingSettingsBase {
    aliasId?: string | undefined;
    note?: string | undefined;
    duration?: string | undefined;
}

export class CreateGroupInvitationSharingSettings extends CreateSharingSettingsBase implements ICreateGroupInvitationSharingSettings {
    groupId!: string;
    roles?: string[] | undefined;

    constructor(data?: ICreateGroupInvitationSharingSettings) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.groupId = _data["groupId"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateGroupInvitationSharingSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateGroupInvitationSharingSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ICreateGroupInvitationSharingSettings extends ICreateSharingSettingsBase {
    groupId: string;
    roles?: string[] | undefined;
}

export class ListOfTicket implements IListOfTicket {
    totalItemCount!: number;
    items!: Ticket[];

    constructor(data?: IListOfTicket) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Ticket.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfTicket {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfTicket();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfTicket {
    totalItemCount: number;
    items: Ticket[];
}

export class Ticket implements ITicket {
    id?: string | undefined;
    version?: number;
    message?: string | undefined;
    ticketType?: TicketType;
    userId?: string | undefined;
    userEmail?: string | undefined;
    userName?: string | undefined;
    created?: Date;
    modified?: Date;
    status?: TicketStatus;
    statusReason?: string | undefined;

    constructor(data?: ITicket) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.version = _data["version"];
            this.message = _data["message"];
            this.ticketType = _data["ticketType"];
            this.userId = _data["userId"];
            this.userEmail = _data["userEmail"];
            this.userName = _data["userName"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.statusReason = _data["statusReason"];
        }
    }

    static fromJS(data: any): Ticket {
        data = typeof data === 'object' ? data : {};
        let result = new Ticket();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["version"] = this.version;
        data["message"] = this.message;
        data["ticketType"] = this.ticketType;
        data["userId"] = this.userId;
        data["userEmail"] = this.userEmail;
        data["userName"] = this.userName;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["statusReason"] = this.statusReason;
        return data; 
    }
}

export interface ITicket {
    id?: string | undefined;
    version?: number;
    message?: string | undefined;
    ticketType?: TicketType;
    userId?: string | undefined;
    userEmail?: string | undefined;
    userName?: string | undefined;
    created?: Date;
    modified?: Date;
    status?: TicketStatus;
    statusReason?: string | undefined;
}

/** 0 = None 1 = GeneralEnquiry */
export enum TicketType {
    None = 0,
    GeneralEnquiry = 1,
}

/** 0 = Open 1 = Resolved 2 = Rejected */
export enum TicketStatus {
    Open = 0,
    Resolved = 1,
    Rejected = 2,
}

export class CreateTicketSettings implements ICreateTicketSettings {
    userEmail!: string;
    userName!: string;
    message!: string;
    type?: TicketType;

    constructor(data?: ICreateTicketSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userEmail = _data["userEmail"];
            this.userName = _data["userName"];
            this.message = _data["message"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CreateTicketSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTicketSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userEmail"] = this.userEmail;
        data["userName"] = this.userName;
        data["message"] = this.message;
        data["type"] = this.type;
        return data; 
    }
}

export interface ICreateTicketSettings {
    userEmail: string;
    userName: string;
    message: string;
    type?: TicketType;
}

export class UpdateTicketSettings implements IUpdateTicketSettings {
    status?: TicketStatus;
    reason?: string | undefined;
    version!: number;

    constructor(data?: IUpdateTicketSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.reason = _data["reason"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateTicketSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTicketSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["reason"] = this.reason;
        data["version"] = this.version;
        return data; 
    }
}

export interface IUpdateTicketSettings {
    status?: TicketStatus;
    reason?: string | undefined;
    version: number;
}

export class ListOfSurveyContent implements IListOfSurveyContent {
    totalItemCount!: number;
    items!: SurveyContent[];

    constructor(data?: IListOfSurveyContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SurveyContent.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfSurveyContent {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfSurveyContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfSurveyContent {
    totalItemCount: number;
    items: SurveyContent[];
}

export class SurveyContent implements ISurveyContent {
    id?: string | undefined;
    publisherId?: string | undefined;
    surveyId?: string | undefined;
    sections?: QuestionSection[] | undefined;
    published?: boolean;
    created?: Date;
    modified?: Date;
    version?: number;

    constructor(data?: ISurveyContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.publisherId = _data["publisherId"];
            this.surveyId = _data["surveyId"];
            if (Array.isArray(_data["sections"])) {
                this.sections = [] as any;
                for (let item of _data["sections"])
                    this.sections!.push(QuestionSection.fromJS(item));
            }
            this.published = _data["published"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): SurveyContent {
        data = typeof data === 'object' ? data : {};
        let result = new SurveyContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["publisherId"] = this.publisherId;
        data["surveyId"] = this.surveyId;
        if (Array.isArray(this.sections)) {
            data["sections"] = [];
            for (let item of this.sections)
                data["sections"].push(item.toJSON());
        }
        data["published"] = this.published;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        data["version"] = this.version;
        return data; 
    }
}

export interface ISurveyContent {
    id?: string | undefined;
    publisherId?: string | undefined;
    surveyId?: string | undefined;
    sections?: QuestionSection[] | undefined;
    published?: boolean;
    created?: Date;
    modified?: Date;
    version?: number;
}

export class QuestionSection implements IQuestionSection {
    title?: string | undefined;
    questions?: any[] | undefined;

    constructor(data?: IQuestionSection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(item);
            }
        }
    }

    static fromJS(data: any): QuestionSection {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionSection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item);
        }
        return data; 
    }
}

export interface IQuestionSection {
    title?: string | undefined;
    questions?: any[] | undefined;
}

export class CreateSurveyContentSettings implements ICreateSurveyContentSettings {
    sections!: QuestionSection[];
    published?: boolean;

    constructor(data?: ICreateSurveyContentSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.sections = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["sections"])) {
                this.sections = [] as any;
                for (let item of _data["sections"])
                    this.sections!.push(QuestionSection.fromJS(item));
            }
            this.published = _data["published"];
        }
    }

    static fromJS(data: any): CreateSurveyContentSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSurveyContentSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.sections)) {
            data["sections"] = [];
            for (let item of this.sections)
                data["sections"].push(item.toJSON());
        }
        data["published"] = this.published;
        return data; 
    }
}

export interface ICreateSurveyContentSettings {
    sections: QuestionSection[];
    published?: boolean;
}

export class UpdateSurveyContentSettings implements IUpdateSurveyContentSettings {
    sections!: QuestionSection[];
    version?: number;

    constructor(data?: IUpdateSurveyContentSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.sections = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["sections"])) {
                this.sections = [] as any;
                for (let item of _data["sections"])
                    this.sections!.push(QuestionSection.fromJS(item));
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateSurveyContentSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSurveyContentSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.sections)) {
            data["sections"] = [];
            for (let item of this.sections)
                data["sections"].push(item.toJSON());
        }
        data["version"] = this.version;
        return data; 
    }
}

export interface IUpdateSurveyContentSettings {
    sections: QuestionSection[];
    version?: number;
}

export class SurveyQuestionTypes implements ISurveyQuestionTypes {
    listQuestion?: ListQuestion | undefined;
    compositeQuestion?: CompositeQuestion | undefined;
    decimalQuestion?: DecimalQuestion | undefined;
    integerQuestion?: IntegerQuestion | undefined;
    multipleChoiceQuestion?: MultipleChoiceQuestion | undefined;
    stringQuestion?: StringQuestion | undefined;
    percentageQuestion?: PercentageQuestion | undefined;
    dateTimeQuestion?: DateTimeQuestion | undefined;
    timeSpanQuestion?: TimeSpanQuestion | undefined;
    userQuestion?: UserQuestion | undefined;
    groupQuestion?: GroupQuestion | undefined;
    fileQuestion?: FileQuestion | undefined;
    binaryQuestion?: BinaryQuestion | undefined;
    timeOfDayQuestion?: TimeOfDayQuestion | undefined;
    emailQuestion?: EmailQuestion | undefined;
    labelQuestion?: LabelQuestion | undefined;

    constructor(data?: ISurveyQuestionTypes) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.listQuestion = _data["listQuestion"] ? ListQuestion.fromJS(_data["listQuestion"]) : <any>undefined;
            this.compositeQuestion = _data["compositeQuestion"] ? CompositeQuestion.fromJS(_data["compositeQuestion"]) : <any>undefined;
            this.decimalQuestion = _data["decimalQuestion"] ? DecimalQuestion.fromJS(_data["decimalQuestion"]) : <any>undefined;
            this.integerQuestion = _data["integerQuestion"] ? IntegerQuestion.fromJS(_data["integerQuestion"]) : <any>undefined;
            this.multipleChoiceQuestion = _data["multipleChoiceQuestion"] ? MultipleChoiceQuestion.fromJS(_data["multipleChoiceQuestion"]) : <any>undefined;
            this.stringQuestion = _data["stringQuestion"] ? StringQuestion.fromJS(_data["stringQuestion"]) : <any>undefined;
            this.percentageQuestion = _data["percentageQuestion"] ? PercentageQuestion.fromJS(_data["percentageQuestion"]) : <any>undefined;
            this.dateTimeQuestion = _data["dateTimeQuestion"] ? DateTimeQuestion.fromJS(_data["dateTimeQuestion"]) : <any>undefined;
            this.timeSpanQuestion = _data["timeSpanQuestion"] ? TimeSpanQuestion.fromJS(_data["timeSpanQuestion"]) : <any>undefined;
            this.userQuestion = _data["userQuestion"] ? UserQuestion.fromJS(_data["userQuestion"]) : <any>undefined;
            this.groupQuestion = _data["groupQuestion"] ? GroupQuestion.fromJS(_data["groupQuestion"]) : <any>undefined;
            this.fileQuestion = _data["fileQuestion"] ? FileQuestion.fromJS(_data["fileQuestion"]) : <any>undefined;
            this.binaryQuestion = _data["binaryQuestion"] ? BinaryQuestion.fromJS(_data["binaryQuestion"]) : <any>undefined;
            this.timeOfDayQuestion = _data["timeOfDayQuestion"] ? TimeOfDayQuestion.fromJS(_data["timeOfDayQuestion"]) : <any>undefined;
            this.emailQuestion = _data["emailQuestion"] ? EmailQuestion.fromJS(_data["emailQuestion"]) : <any>undefined;
            this.labelQuestion = _data["labelQuestion"] ? LabelQuestion.fromJS(_data["labelQuestion"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SurveyQuestionTypes {
        data = typeof data === 'object' ? data : {};
        let result = new SurveyQuestionTypes();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["listQuestion"] = this.listQuestion ? this.listQuestion.toJSON() : <any>undefined;
        data["compositeQuestion"] = this.compositeQuestion ? this.compositeQuestion.toJSON() : <any>undefined;
        data["decimalQuestion"] = this.decimalQuestion ? this.decimalQuestion.toJSON() : <any>undefined;
        data["integerQuestion"] = this.integerQuestion ? this.integerQuestion.toJSON() : <any>undefined;
        data["multipleChoiceQuestion"] = this.multipleChoiceQuestion ? this.multipleChoiceQuestion.toJSON() : <any>undefined;
        data["stringQuestion"] = this.stringQuestion ? this.stringQuestion.toJSON() : <any>undefined;
        data["percentageQuestion"] = this.percentageQuestion ? this.percentageQuestion.toJSON() : <any>undefined;
        data["dateTimeQuestion"] = this.dateTimeQuestion ? this.dateTimeQuestion.toJSON() : <any>undefined;
        data["timeSpanQuestion"] = this.timeSpanQuestion ? this.timeSpanQuestion.toJSON() : <any>undefined;
        data["userQuestion"] = this.userQuestion ? this.userQuestion.toJSON() : <any>undefined;
        data["groupQuestion"] = this.groupQuestion ? this.groupQuestion.toJSON() : <any>undefined;
        data["fileQuestion"] = this.fileQuestion ? this.fileQuestion.toJSON() : <any>undefined;
        data["binaryQuestion"] = this.binaryQuestion ? this.binaryQuestion.toJSON() : <any>undefined;
        data["timeOfDayQuestion"] = this.timeOfDayQuestion ? this.timeOfDayQuestion.toJSON() : <any>undefined;
        data["emailQuestion"] = this.emailQuestion ? this.emailQuestion.toJSON() : <any>undefined;
        data["labelQuestion"] = this.labelQuestion ? this.labelQuestion.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISurveyQuestionTypes {
    listQuestion?: ListQuestion | undefined;
    compositeQuestion?: CompositeQuestion | undefined;
    decimalQuestion?: DecimalQuestion | undefined;
    integerQuestion?: IntegerQuestion | undefined;
    multipleChoiceQuestion?: MultipleChoiceQuestion | undefined;
    stringQuestion?: StringQuestion | undefined;
    percentageQuestion?: PercentageQuestion | undefined;
    dateTimeQuestion?: DateTimeQuestion | undefined;
    timeSpanQuestion?: TimeSpanQuestion | undefined;
    userQuestion?: UserQuestion | undefined;
    groupQuestion?: GroupQuestion | undefined;
    fileQuestion?: FileQuestion | undefined;
    binaryQuestion?: BinaryQuestion | undefined;
    timeOfDayQuestion?: TimeOfDayQuestion | undefined;
    emailQuestion?: EmailQuestion | undefined;
    labelQuestion?: LabelQuestion | undefined;
}

export abstract class QuestionBase implements IQuestionBase {
    type?: string | undefined;
    name?: string | undefined;
    body?: string | undefined;
    label?: string | undefined;
    required?: boolean;

    constructor(data?: IQuestionBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.name = _data["name"];
            this.body = _data["body"];
            this.label = _data["label"];
            this.required = _data["required"];
        }
    }

    static fromJS(data: any): QuestionBase {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'QuestionBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["name"] = this.name;
        data["body"] = this.body;
        data["label"] = this.label;
        data["required"] = this.required;
        return data; 
    }
}

export interface IQuestionBase {
    type?: string | undefined;
    name?: string | undefined;
    body?: string | undefined;
    label?: string | undefined;
    required?: boolean;
}

export class ListQuestion extends QuestionBase implements IListQuestion {
    layout?: LayoutType;
    question?: any | undefined;
    minimumAnswers?: number | undefined;
    maximumAnswers?: number | undefined;

    constructor(data?: IListQuestion) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.layout = _data["layout"];
            this.question = _data["question"];
            this.minimumAnswers = _data["minimumAnswers"];
            this.maximumAnswers = _data["maximumAnswers"];
        }
    }

    static fromJS(data: any): ListQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new ListQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layout"] = this.layout;
        data["question"] = this.question;
        data["minimumAnswers"] = this.minimumAnswers;
        data["maximumAnswers"] = this.maximumAnswers;
        super.toJSON(data);
        return data; 
    }
}

export interface IListQuestion extends IQuestionBase {
    layout?: LayoutType;
    question?: any | undefined;
    minimumAnswers?: number | undefined;
    maximumAnswers?: number | undefined;
}

/** 0 = None 1 = Horizontal 2 = Vertical */
export enum LayoutType {
    None = 0,
    Horizontal = 1,
    Vertical = 2,
}

export class CompositeQuestion extends QuestionBase implements ICompositeQuestion {
    layout?: LayoutType;
    questions?: any[] | undefined;

    constructor(data?: ICompositeQuestion) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.layout = _data["layout"];
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(item);
            }
        }
    }

    static fromJS(data: any): CompositeQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new CompositeQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layout"] = this.layout;
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item);
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ICompositeQuestion extends IQuestionBase {
    layout?: LayoutType;
    questions?: any[] | undefined;
}

export class DecimalQuestion extends QuestionBase implements IDecimalQuestion {
    minimum?: number | undefined;
    maximum?: number | undefined;

    constructor(data?: IDecimalQuestion) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.minimum = _data["minimum"];
            this.maximum = _data["maximum"];
        }
    }

    static fromJS(data: any): DecimalQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new DecimalQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minimum"] = this.minimum;
        data["maximum"] = this.maximum;
        super.toJSON(data);
        return data; 
    }
}

export interface IDecimalQuestion extends IQuestionBase {
    minimum?: number | undefined;
    maximum?: number | undefined;
}

export class IntegerQuestion extends QuestionBase implements IIntegerQuestion {
    display?: IntegerQuestionDisplayType;
    minimum?: number | undefined;
    maximum?: number | undefined;

    constructor(data?: IIntegerQuestion) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.display = _data["display"];
            this.minimum = _data["minimum"];
            this.maximum = _data["maximum"];
        }
    }

    static fromJS(data: any): IntegerQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new IntegerQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["display"] = this.display;
        data["minimum"] = this.minimum;
        data["maximum"] = this.maximum;
        super.toJSON(data);
        return data; 
    }
}

export interface IIntegerQuestion extends IQuestionBase {
    display?: IntegerQuestionDisplayType;
    minimum?: number | undefined;
    maximum?: number | undefined;
}

/** 0 = None 1 = Counter */
export enum IntegerQuestionDisplayType {
    None = 0,
    Counter = 1,
}

export class MultipleChoiceQuestion extends QuestionBase implements IMultipleChoiceQuestion {
    options?: string[] | undefined;
    minimumResponses?: number | undefined;
    maximumResponses?: number | undefined;

    constructor(data?: IMultipleChoiceQuestion) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["options"])) {
                this.options = [] as any;
                for (let item of _data["options"])
                    this.options!.push(item);
            }
            this.minimumResponses = _data["minimumResponses"];
            this.maximumResponses = _data["maximumResponses"];
        }
    }

    static fromJS(data: any): MultipleChoiceQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new MultipleChoiceQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item);
        }
        data["minimumResponses"] = this.minimumResponses;
        data["maximumResponses"] = this.maximumResponses;
        super.toJSON(data);
        return data; 
    }
}

export interface IMultipleChoiceQuestion extends IQuestionBase {
    options?: string[] | undefined;
    minimumResponses?: number | undefined;
    maximumResponses?: number | undefined;
}

export class StringQuestion extends QuestionBase implements IStringQuestion {
    lineType?: LineType;
    minimumLength?: number | undefined;
    maximumLength?: number | undefined;

    constructor(data?: IStringQuestion) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.lineType = _data["lineType"];
            this.minimumLength = _data["minimumLength"];
            this.maximumLength = _data["maximumLength"];
        }
    }

    static fromJS(data: any): StringQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new StringQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lineType"] = this.lineType;
        data["minimumLength"] = this.minimumLength;
        data["maximumLength"] = this.maximumLength;
        super.toJSON(data);
        return data; 
    }
}

export interface IStringQuestion extends IQuestionBase {
    lineType?: LineType;
    minimumLength?: number | undefined;
    maximumLength?: number | undefined;
}

/** 0 = None 1 = SingleLine 2 = MultiLine */
export enum LineType {
    None = 0,
    SingleLine = 1,
    MultiLine = 2,
}

export class PercentageQuestion extends QuestionBase implements IPercentageQuestion {
    minimum?: number | undefined;
    maximum?: number | undefined;

    constructor(data?: IPercentageQuestion) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.minimum = _data["minimum"];
            this.maximum = _data["maximum"];
        }
    }

    static fromJS(data: any): PercentageQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new PercentageQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minimum"] = this.minimum;
        data["maximum"] = this.maximum;
        super.toJSON(data);
        return data; 
    }
}

export interface IPercentageQuestion extends IQuestionBase {
    minimum?: number | undefined;
    maximum?: number | undefined;
}

export class DateTimeQuestion extends QuestionBase implements IDateTimeQuestion {
    constraint?: DateTimeConstraintType;
    minimum?: Date | undefined;
    maximum?: Date | undefined;

    constructor(data?: IDateTimeQuestion) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.constraint = _data["constraint"];
            this.minimum = _data["minimum"] ? new Date(_data["minimum"].toString()) : <any>undefined;
            this.maximum = _data["maximum"] ? new Date(_data["maximum"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DateTimeQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new DateTimeQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["constraint"] = this.constraint;
        data["minimum"] = this.minimum ? this.minimum.toISOString() : <any>undefined;
        data["maximum"] = this.maximum ? this.maximum.toISOString() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IDateTimeQuestion extends IQuestionBase {
    constraint?: DateTimeConstraintType;
    minimum?: Date | undefined;
    maximum?: Date | undefined;
}

/** 0 = None 1 = Date */
export enum DateTimeConstraintType {
    None = 0,
    Date = 1,
}

export class TimeSpanQuestion extends QuestionBase implements ITimeSpanQuestion {
    constraint?: TimeSpanConstraintType;
    minimum?: string | undefined;
    maximum?: string | undefined;

    constructor(data?: ITimeSpanQuestion) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.constraint = _data["constraint"];
            this.minimum = _data["minimum"];
            this.maximum = _data["maximum"];
        }
    }

    static fromJS(data: any): TimeSpanQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new TimeSpanQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["constraint"] = this.constraint;
        data["minimum"] = this.minimum;
        data["maximum"] = this.maximum;
        super.toJSON(data);
        return data; 
    }
}

export interface ITimeSpanQuestion extends IQuestionBase {
    constraint?: TimeSpanConstraintType;
    minimum?: string | undefined;
    maximum?: string | undefined;
}

/** 0 = None 1 = Days 2 = Hours 3 = Minutes 4 = Seconds */
export enum TimeSpanConstraintType {
    None = 0,
    Days = 1,
    Hours = 2,
    Minutes = 3,
    Seconds = 4,
}

export class UserQuestion extends QuestionBase implements IUserQuestion {
    jobTypeCategories?: string[] | undefined;
    jobTypeIds?: string[] | undefined;

    constructor(data?: IUserQuestion) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["jobTypeCategories"])) {
                this.jobTypeCategories = [] as any;
                for (let item of _data["jobTypeCategories"])
                    this.jobTypeCategories!.push(item);
            }
            if (Array.isArray(_data["jobTypeIds"])) {
                this.jobTypeIds = [] as any;
                for (let item of _data["jobTypeIds"])
                    this.jobTypeIds!.push(item);
            }
        }
    }

    static fromJS(data: any): UserQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new UserQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.jobTypeCategories)) {
            data["jobTypeCategories"] = [];
            for (let item of this.jobTypeCategories)
                data["jobTypeCategories"].push(item);
        }
        if (Array.isArray(this.jobTypeIds)) {
            data["jobTypeIds"] = [];
            for (let item of this.jobTypeIds)
                data["jobTypeIds"].push(item);
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IUserQuestion extends IQuestionBase {
    jobTypeCategories?: string[] | undefined;
    jobTypeIds?: string[] | undefined;
}

export class GroupQuestion extends QuestionBase implements IGroupQuestion {
    groupType?: string | undefined;

    constructor(data?: IGroupQuestion) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.groupType = _data["groupType"];
        }
    }

    static fromJS(data: any): GroupQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new GroupQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupType"] = this.groupType;
        super.toJSON(data);
        return data; 
    }
}

export interface IGroupQuestion extends IQuestionBase {
    groupType?: string | undefined;
}

export class FileQuestion extends QuestionBase implements IFileQuestion {
    contentTypes?: string[] | undefined;

    constructor(data?: IFileQuestion) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["contentTypes"])) {
                this.contentTypes = [] as any;
                for (let item of _data["contentTypes"])
                    this.contentTypes!.push(item);
            }
        }
    }

    static fromJS(data: any): FileQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new FileQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.contentTypes)) {
            data["contentTypes"] = [];
            for (let item of this.contentTypes)
                data["contentTypes"].push(item);
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IFileQuestion extends IQuestionBase {
    contentTypes?: string[] | undefined;
}

export class BinaryQuestion extends QuestionBase implements IBinaryQuestion {

    constructor(data?: IBinaryQuestion) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): BinaryQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new BinaryQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IBinaryQuestion extends IQuestionBase {
}

export class TimeOfDayQuestion extends QuestionBase implements ITimeOfDayQuestion {

    constructor(data?: ITimeOfDayQuestion) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): TimeOfDayQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new TimeOfDayQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ITimeOfDayQuestion extends IQuestionBase {
}

export class EmailQuestion extends QuestionBase implements IEmailQuestion {
    constraint?: DomainConstraint | undefined;

    constructor(data?: IEmailQuestion) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.constraint = _data["constraint"] ? DomainConstraint.fromJS(_data["constraint"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EmailQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new EmailQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["constraint"] = this.constraint ? this.constraint.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IEmailQuestion extends IQuestionBase {
    constraint?: DomainConstraint | undefined;
}

export class DomainConstraint implements IDomainConstraint {
    type?: DomainConstraintType;
    domains?: string[] | undefined;

    constructor(data?: IDomainConstraint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            if (Array.isArray(_data["domains"])) {
                this.domains = [] as any;
                for (let item of _data["domains"])
                    this.domains!.push(item);
            }
        }
    }

    static fromJS(data: any): DomainConstraint {
        data = typeof data === 'object' ? data : {};
        let result = new DomainConstraint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        if (Array.isArray(this.domains)) {
            data["domains"] = [];
            for (let item of this.domains)
                data["domains"].push(item);
        }
        return data; 
    }
}

export interface IDomainConstraint {
    type?: DomainConstraintType;
    domains?: string[] | undefined;
}

/** 0 = Black 1 = White */
export enum DomainConstraintType {
    Black = 0,
    White = 1,
}

export class LabelQuestion extends QuestionBase implements ILabelQuestion {
    minimumResponses?: number | undefined;
    maximumResponses?: number | undefined;

    constructor(data?: ILabelQuestion) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.minimumResponses = _data["minimumResponses"];
            this.maximumResponses = _data["maximumResponses"];
        }
    }

    static fromJS(data: any): LabelQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new LabelQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minimumResponses"] = this.minimumResponses;
        data["maximumResponses"] = this.maximumResponses;
        super.toJSON(data);
        return data; 
    }
}

export interface ILabelQuestion extends IQuestionBase {
    minimumResponses?: number | undefined;
    maximumResponses?: number | undefined;
}

export class SurveyAnswerTypes implements ISurveyAnswerTypes {
    listAnswer?: ListAnswer | undefined;
    compositeAnswer?: CompositeAnswer | undefined;
    decimalAnswer?: DecimalAnswer | undefined;
    integerAnswer?: IntegerAnswer | undefined;
    multipleChoiceAnswer?: MultipleChoiceAnswer | undefined;
    stringAnswer?: StringAnswer | undefined;
    percentageAnswer?: PercentageAnswer | undefined;
    dateTimeAnswer?: DateTimeAnswer | undefined;
    timeSpanAnswer?: TimeSpanAnswer | undefined;
    userAnswer?: UserAnswer | undefined;
    groupAnswer?: GroupAnswer | undefined;
    fileAnswer?: FileAnswer | undefined;
    binaryAnswer?: BinaryAnswer | undefined;
    timeOfDayAnswer?: TimeOfDayAnswer | undefined;
    emailAnswer?: EmailAnswer | undefined;
    labelAnswer?: LabelAnswer | undefined;

    constructor(data?: ISurveyAnswerTypes) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.listAnswer = _data["listAnswer"] ? ListAnswer.fromJS(_data["listAnswer"]) : <any>undefined;
            this.compositeAnswer = _data["compositeAnswer"] ? CompositeAnswer.fromJS(_data["compositeAnswer"]) : <any>undefined;
            this.decimalAnswer = _data["decimalAnswer"] ? DecimalAnswer.fromJS(_data["decimalAnswer"]) : <any>undefined;
            this.integerAnswer = _data["integerAnswer"] ? IntegerAnswer.fromJS(_data["integerAnswer"]) : <any>undefined;
            this.multipleChoiceAnswer = _data["multipleChoiceAnswer"] ? MultipleChoiceAnswer.fromJS(_data["multipleChoiceAnswer"]) : <any>undefined;
            this.stringAnswer = _data["stringAnswer"] ? StringAnswer.fromJS(_data["stringAnswer"]) : <any>undefined;
            this.percentageAnswer = _data["percentageAnswer"] ? PercentageAnswer.fromJS(_data["percentageAnswer"]) : <any>undefined;
            this.dateTimeAnswer = _data["dateTimeAnswer"] ? DateTimeAnswer.fromJS(_data["dateTimeAnswer"]) : <any>undefined;
            this.timeSpanAnswer = _data["timeSpanAnswer"] ? TimeSpanAnswer.fromJS(_data["timeSpanAnswer"]) : <any>undefined;
            this.userAnswer = _data["userAnswer"] ? UserAnswer.fromJS(_data["userAnswer"]) : <any>undefined;
            this.groupAnswer = _data["groupAnswer"] ? GroupAnswer.fromJS(_data["groupAnswer"]) : <any>undefined;
            this.fileAnswer = _data["fileAnswer"] ? FileAnswer.fromJS(_data["fileAnswer"]) : <any>undefined;
            this.binaryAnswer = _data["binaryAnswer"] ? BinaryAnswer.fromJS(_data["binaryAnswer"]) : <any>undefined;
            this.timeOfDayAnswer = _data["timeOfDayAnswer"] ? TimeOfDayAnswer.fromJS(_data["timeOfDayAnswer"]) : <any>undefined;
            this.emailAnswer = _data["emailAnswer"] ? EmailAnswer.fromJS(_data["emailAnswer"]) : <any>undefined;
            this.labelAnswer = _data["labelAnswer"] ? LabelAnswer.fromJS(_data["labelAnswer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SurveyAnswerTypes {
        data = typeof data === 'object' ? data : {};
        let result = new SurveyAnswerTypes();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["listAnswer"] = this.listAnswer ? this.listAnswer.toJSON() : <any>undefined;
        data["compositeAnswer"] = this.compositeAnswer ? this.compositeAnswer.toJSON() : <any>undefined;
        data["decimalAnswer"] = this.decimalAnswer ? this.decimalAnswer.toJSON() : <any>undefined;
        data["integerAnswer"] = this.integerAnswer ? this.integerAnswer.toJSON() : <any>undefined;
        data["multipleChoiceAnswer"] = this.multipleChoiceAnswer ? this.multipleChoiceAnswer.toJSON() : <any>undefined;
        data["stringAnswer"] = this.stringAnswer ? this.stringAnswer.toJSON() : <any>undefined;
        data["percentageAnswer"] = this.percentageAnswer ? this.percentageAnswer.toJSON() : <any>undefined;
        data["dateTimeAnswer"] = this.dateTimeAnswer ? this.dateTimeAnswer.toJSON() : <any>undefined;
        data["timeSpanAnswer"] = this.timeSpanAnswer ? this.timeSpanAnswer.toJSON() : <any>undefined;
        data["userAnswer"] = this.userAnswer ? this.userAnswer.toJSON() : <any>undefined;
        data["groupAnswer"] = this.groupAnswer ? this.groupAnswer.toJSON() : <any>undefined;
        data["fileAnswer"] = this.fileAnswer ? this.fileAnswer.toJSON() : <any>undefined;
        data["binaryAnswer"] = this.binaryAnswer ? this.binaryAnswer.toJSON() : <any>undefined;
        data["timeOfDayAnswer"] = this.timeOfDayAnswer ? this.timeOfDayAnswer.toJSON() : <any>undefined;
        data["emailAnswer"] = this.emailAnswer ? this.emailAnswer.toJSON() : <any>undefined;
        data["labelAnswer"] = this.labelAnswer ? this.labelAnswer.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISurveyAnswerTypes {
    listAnswer?: ListAnswer | undefined;
    compositeAnswer?: CompositeAnswer | undefined;
    decimalAnswer?: DecimalAnswer | undefined;
    integerAnswer?: IntegerAnswer | undefined;
    multipleChoiceAnswer?: MultipleChoiceAnswer | undefined;
    stringAnswer?: StringAnswer | undefined;
    percentageAnswer?: PercentageAnswer | undefined;
    dateTimeAnswer?: DateTimeAnswer | undefined;
    timeSpanAnswer?: TimeSpanAnswer | undefined;
    userAnswer?: UserAnswer | undefined;
    groupAnswer?: GroupAnswer | undefined;
    fileAnswer?: FileAnswer | undefined;
    binaryAnswer?: BinaryAnswer | undefined;
    timeOfDayAnswer?: TimeOfDayAnswer | undefined;
    emailAnswer?: EmailAnswer | undefined;
    labelAnswer?: LabelAnswer | undefined;
}

export abstract class AnswerBase implements IAnswerBase {
    type?: string | undefined;
    questionIndex?: number;

    constructor(data?: IAnswerBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.questionIndex = _data["questionIndex"];
        }
    }

    static fromJS(data: any): AnswerBase {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'AnswerBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["questionIndex"] = this.questionIndex;
        return data; 
    }
}

export interface IAnswerBase {
    type?: string | undefined;
    questionIndex?: number;
}

export class ListAnswer extends AnswerBase implements IListAnswer {
    answers?: any[] | undefined;

    constructor(data?: IListAnswer) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(item);
            }
        }
    }

    static fromJS(data: any): ListAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new ListAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item);
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IListAnswer extends IAnswerBase {
    answers?: any[] | undefined;
}

export class CompositeAnswer extends AnswerBase implements ICompositeAnswer {
    answers?: any[] | undefined;

    constructor(data?: ICompositeAnswer) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(item);
            }
        }
    }

    static fromJS(data: any): CompositeAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new CompositeAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item);
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ICompositeAnswer extends IAnswerBase {
    answers?: any[] | undefined;
}

export class DecimalAnswer extends AnswerBase implements IDecimalAnswer {
    value?: number | undefined;

    constructor(data?: IDecimalAnswer) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): DecimalAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new DecimalAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        super.toJSON(data);
        return data; 
    }
}

export interface IDecimalAnswer extends IAnswerBase {
    value?: number | undefined;
}

export class IntegerAnswer extends AnswerBase implements IIntegerAnswer {
    value?: number | undefined;

    constructor(data?: IIntegerAnswer) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): IntegerAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new IntegerAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        super.toJSON(data);
        return data; 
    }
}

export interface IIntegerAnswer extends IAnswerBase {
    value?: number | undefined;
}

export class MultipleChoiceAnswer extends AnswerBase implements IMultipleChoiceAnswer {
    options?: number[] | undefined;

    constructor(data?: IMultipleChoiceAnswer) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["options"])) {
                this.options = [] as any;
                for (let item of _data["options"])
                    this.options!.push(item);
            }
        }
    }

    static fromJS(data: any): MultipleChoiceAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new MultipleChoiceAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item);
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IMultipleChoiceAnswer extends IAnswerBase {
    options?: number[] | undefined;
}

export class StringAnswer extends AnswerBase implements IStringAnswer {
    value?: string | undefined;

    constructor(data?: IStringAnswer) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): StringAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new StringAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        super.toJSON(data);
        return data; 
    }
}

export interface IStringAnswer extends IAnswerBase {
    value?: string | undefined;
}

export class PercentageAnswer extends AnswerBase implements IPercentageAnswer {
    value?: number | undefined;

    constructor(data?: IPercentageAnswer) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): PercentageAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new PercentageAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        super.toJSON(data);
        return data; 
    }
}

export interface IPercentageAnswer extends IAnswerBase {
    value?: number | undefined;
}

export class DateTimeAnswer extends AnswerBase implements IDateTimeAnswer {
    value?: Date | undefined;

    constructor(data?: IDateTimeAnswer) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.value = _data["value"] ? new Date(_data["value"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DateTimeAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new DateTimeAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value ? this.value.toISOString() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IDateTimeAnswer extends IAnswerBase {
    value?: Date | undefined;
}

export class TimeSpanAnswer extends AnswerBase implements ITimeSpanAnswer {
    value?: string | undefined;

    constructor(data?: ITimeSpanAnswer) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): TimeSpanAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new TimeSpanAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        super.toJSON(data);
        return data; 
    }
}

export interface ITimeSpanAnswer extends IAnswerBase {
    value?: string | undefined;
}

export class UserAnswer extends AnswerBase implements IUserAnswer {
    valueType?: UserValueType;
    value?: string | undefined;

    constructor(data?: IUserAnswer) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.valueType = _data["valueType"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): UserAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new UserAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["valueType"] = this.valueType;
        data["value"] = this.value;
        super.toJSON(data);
        return data; 
    }
}

export interface IUserAnswer extends IAnswerBase {
    valueType?: UserValueType;
    value?: string | undefined;
}

/** 0 = Id 1 = Name */
export enum UserValueType {
    Id = 0,
    Name = 1,
}

export class GroupAnswer extends AnswerBase implements IGroupAnswer {
    groupId?: string | undefined;

    constructor(data?: IGroupAnswer) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.groupId = _data["groupId"];
        }
    }

    static fromJS(data: any): GroupAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new GroupAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        super.toJSON(data);
        return data; 
    }
}

export interface IGroupAnswer extends IAnswerBase {
    groupId?: string | undefined;
}

export class FileAnswer extends AnswerBase implements IFileAnswer {
    uri?: string | undefined;

    constructor(data?: IFileAnswer) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.uri = _data["uri"];
        }
    }

    static fromJS(data: any): FileAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new FileAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uri"] = this.uri;
        super.toJSON(data);
        return data; 
    }
}

export interface IFileAnswer extends IAnswerBase {
    uri?: string | undefined;
}

export class BinaryAnswer extends AnswerBase implements IBinaryAnswer {
    value?: boolean;

    constructor(data?: IBinaryAnswer) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): BinaryAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new BinaryAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        super.toJSON(data);
        return data; 
    }
}

export interface IBinaryAnswer extends IAnswerBase {
    value?: boolean;
}

export class TimeOfDayAnswer extends AnswerBase implements ITimeOfDayAnswer {
    value?: string | undefined;

    constructor(data?: ITimeOfDayAnswer) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): TimeOfDayAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new TimeOfDayAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        super.toJSON(data);
        return data; 
    }
}

export interface ITimeOfDayAnswer extends IAnswerBase {
    value?: string | undefined;
}

export class EmailAnswer extends AnswerBase implements IEmailAnswer {
    value?: string | undefined;

    constructor(data?: IEmailAnswer) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): EmailAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new EmailAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        super.toJSON(data);
        return data; 
    }
}

export interface IEmailAnswer extends IAnswerBase {
    value?: string | undefined;
}

export class LabelAnswer extends AnswerBase implements ILabelAnswer {
    answers?: string[] | undefined;

    constructor(data?: ILabelAnswer) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(item);
            }
        }
    }

    static fromJS(data: any): LabelAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new LabelAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item);
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ILabelAnswer extends IAnswerBase {
    answers?: string[] | undefined;
}

export class SurveySettings implements ISurveySettings {
    sections?: QuestionSection[] | undefined;

    constructor(data?: ISurveySettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["sections"])) {
                this.sections = [] as any;
                for (let item of _data["sections"])
                    this.sections!.push(QuestionSection.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SurveySettings {
        data = typeof data === 'object' ? data : {};
        let result = new SurveySettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.sections)) {
            data["sections"] = [];
            for (let item of this.sections)
                data["sections"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISurveySettings {
    sections?: QuestionSection[] | undefined;
}

export class ListOfSurvey implements IListOfSurvey {
    totalItemCount!: number;
    items!: Survey[];

    constructor(data?: IListOfSurvey) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Survey.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfSurvey {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfSurvey();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfSurvey {
    totalItemCount: number;
    items: Survey[];
}

export class Survey implements ISurvey {
    id?: string | undefined;
    publisherId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    isPublic?: boolean;
    published?: boolean;
    publishedContentId?: string | undefined;
    version?: number;

    constructor(data?: ISurvey) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.publisherId = _data["publisherId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.isPublic = _data["isPublic"];
            this.published = _data["published"];
            this.publishedContentId = _data["publishedContentId"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): Survey {
        data = typeof data === 'object' ? data : {};
        let result = new Survey();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["publisherId"] = this.publisherId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["isPublic"] = this.isPublic;
        data["published"] = this.published;
        data["publishedContentId"] = this.publishedContentId;
        data["version"] = this.version;
        return data; 
    }
}

export interface ISurvey {
    id?: string | undefined;
    publisherId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    isPublic?: boolean;
    published?: boolean;
    publishedContentId?: string | undefined;
    version?: number;
}

export class CreateSurveySettings implements ICreateSurveySettings {
    publisherId!: string;
    name!: string;
    description?: string | undefined;
    isPublic?: boolean;

    constructor(data?: ICreateSurveySettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.publisherId = _data["publisherId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.isPublic = _data["isPublic"];
        }
    }

    static fromJS(data: any): CreateSurveySettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSurveySettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["publisherId"] = this.publisherId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["isPublic"] = this.isPublic;
        return data; 
    }
}

export interface ICreateSurveySettings {
    publisherId: string;
    name: string;
    description?: string | undefined;
    isPublic?: boolean;
}

export class UpdateSurveySettings implements IUpdateSurveySettings {
    name!: string;
    description?: string | undefined;
    isPublic?: boolean;
    version?: number;

    constructor(data?: IUpdateSurveySettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.isPublic = _data["isPublic"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateSurveySettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSurveySettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["isPublic"] = this.isPublic;
        data["version"] = this.version;
        return data; 
    }
}

export interface IUpdateSurveySettings {
    name: string;
    description?: string | undefined;
    isPublic?: boolean;
    version?: number;
}

export class ListOfSurveyRequest implements IListOfSurveyRequest {
    totalItemCount!: number;
    items!: SurveyRequest[];

    constructor(data?: IListOfSurveyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SurveyRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfSurveyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfSurveyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfSurveyRequest {
    totalItemCount: number;
    items: SurveyRequest[];
}

export class SurveyRequest implements ISurveyRequest {
    id?: string | undefined;
    surveyId?: string | undefined;
    surveyName?: string | undefined;
    surveyPublisherId?: string | undefined;
    groupId?: string | undefined;
    respondentId?: string | undefined;
    respondentName?: string | undefined;
    creatorId?: string | undefined;
    creatorName?: string | undefined;
    token?: string | undefined;
    created?: Date;
    version?: number;

    constructor(data?: ISurveyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.surveyId = _data["surveyId"];
            this.surveyName = _data["surveyName"];
            this.surveyPublisherId = _data["surveyPublisherId"];
            this.groupId = _data["groupId"];
            this.respondentId = _data["respondentId"];
            this.respondentName = _data["respondentName"];
            this.creatorId = _data["creatorId"];
            this.creatorName = _data["creatorName"];
            this.token = _data["token"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): SurveyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SurveyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["surveyId"] = this.surveyId;
        data["surveyName"] = this.surveyName;
        data["surveyPublisherId"] = this.surveyPublisherId;
        data["groupId"] = this.groupId;
        data["respondentId"] = this.respondentId;
        data["respondentName"] = this.respondentName;
        data["creatorId"] = this.creatorId;
        data["creatorName"] = this.creatorName;
        data["token"] = this.token;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["version"] = this.version;
        return data; 
    }
}

export interface ISurveyRequest {
    id?: string | undefined;
    surveyId?: string | undefined;
    surveyName?: string | undefined;
    surveyPublisherId?: string | undefined;
    groupId?: string | undefined;
    respondentId?: string | undefined;
    respondentName?: string | undefined;
    creatorId?: string | undefined;
    creatorName?: string | undefined;
    token?: string | undefined;
    created?: Date;
    version?: number;
}

export class Token implements IToken {
    value?: string | undefined;

    constructor(data?: IToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Token {
        data = typeof data === 'object' ? data : {};
        let result = new Token();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        return data; 
    }
}

export interface IToken {
    value?: string | undefined;
}

export class CreateSurveyRequestSettings implements ICreateSurveyRequestSettings {
    surveyId!: string;
    groupId!: string;
    respondentId!: string;
    message?: string | undefined;

    constructor(data?: ICreateSurveyRequestSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.surveyId = _data["surveyId"];
            this.groupId = _data["groupId"];
            this.respondentId = _data["respondentId"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): CreateSurveyRequestSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSurveyRequestSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["surveyId"] = this.surveyId;
        data["groupId"] = this.groupId;
        data["respondentId"] = this.respondentId;
        data["message"] = this.message;
        return data; 
    }
}

export interface ICreateSurveyRequestSettings {
    surveyId: string;
    groupId: string;
    respondentId: string;
    message?: string | undefined;
}

export class ListOfSurveyResponse implements IListOfSurveyResponse {
    totalItemCount!: number;
    items!: SurveyResponse[];

    constructor(data?: IListOfSurveyResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SurveyResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfSurveyResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfSurveyResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfSurveyResponse {
    totalItemCount: number;
    items: SurveyResponse[];
}

export class SurveyResponse implements ISurveyResponse {
    id?: string | undefined;
    surveyId?: string | undefined;
    surveyName?: string | undefined;
    surveyPublisherId?: string | undefined;
    surveyContentId?: string | undefined;
    surveyRequestId?: string | undefined;
    groupId?: string | undefined;
    parentGroupIds?: string[] | undefined;
    respondentId?: string | undefined;
    respondentName?: string | undefined;
    respondentIPAddress?: string | undefined;
    respondentUserAgent?: string | undefined;
    respondentJobTypeId?: string | undefined;
    sections?: AnswerSection[] | undefined;
    started?: Date;
    submitted?: Date | undefined;
    version?: number;

    constructor(data?: ISurveyResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.surveyId = _data["surveyId"];
            this.surveyName = _data["surveyName"];
            this.surveyPublisherId = _data["surveyPublisherId"];
            this.surveyContentId = _data["surveyContentId"];
            this.surveyRequestId = _data["surveyRequestId"];
            this.groupId = _data["groupId"];
            if (Array.isArray(_data["parentGroupIds"])) {
                this.parentGroupIds = [] as any;
                for (let item of _data["parentGroupIds"])
                    this.parentGroupIds!.push(item);
            }
            this.respondentId = _data["respondentId"];
            this.respondentName = _data["respondentName"];
            this.respondentIPAddress = _data["respondentIPAddress"];
            this.respondentUserAgent = _data["respondentUserAgent"];
            this.respondentJobTypeId = _data["respondentJobTypeId"];
            if (Array.isArray(_data["sections"])) {
                this.sections = [] as any;
                for (let item of _data["sections"])
                    this.sections!.push(AnswerSection.fromJS(item));
            }
            this.started = _data["started"] ? new Date(_data["started"].toString()) : <any>undefined;
            this.submitted = _data["submitted"] ? new Date(_data["submitted"].toString()) : <any>undefined;
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): SurveyResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SurveyResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["surveyId"] = this.surveyId;
        data["surveyName"] = this.surveyName;
        data["surveyPublisherId"] = this.surveyPublisherId;
        data["surveyContentId"] = this.surveyContentId;
        data["surveyRequestId"] = this.surveyRequestId;
        data["groupId"] = this.groupId;
        if (Array.isArray(this.parentGroupIds)) {
            data["parentGroupIds"] = [];
            for (let item of this.parentGroupIds)
                data["parentGroupIds"].push(item);
        }
        data["respondentId"] = this.respondentId;
        data["respondentName"] = this.respondentName;
        data["respondentIPAddress"] = this.respondentIPAddress;
        data["respondentUserAgent"] = this.respondentUserAgent;
        data["respondentJobTypeId"] = this.respondentJobTypeId;
        if (Array.isArray(this.sections)) {
            data["sections"] = [];
            for (let item of this.sections)
                data["sections"].push(item.toJSON());
        }
        data["started"] = this.started ? this.started.toISOString() : <any>undefined;
        data["submitted"] = this.submitted ? this.submitted.toISOString() : <any>undefined;
        data["version"] = this.version;
        return data; 
    }
}

export interface ISurveyResponse {
    id?: string | undefined;
    surveyId?: string | undefined;
    surveyName?: string | undefined;
    surveyPublisherId?: string | undefined;
    surveyContentId?: string | undefined;
    surveyRequestId?: string | undefined;
    groupId?: string | undefined;
    parentGroupIds?: string[] | undefined;
    respondentId?: string | undefined;
    respondentName?: string | undefined;
    respondentIPAddress?: string | undefined;
    respondentUserAgent?: string | undefined;
    respondentJobTypeId?: string | undefined;
    sections?: AnswerSection[] | undefined;
    started?: Date;
    submitted?: Date | undefined;
    version?: number;
}

export class AnswerSection implements IAnswerSection {
    sectionIndex?: number;
    answers?: any[] | undefined;

    constructor(data?: IAnswerSection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sectionIndex = _data["sectionIndex"];
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(item);
            }
        }
    }

    static fromJS(data: any): AnswerSection {
        data = typeof data === 'object' ? data : {};
        let result = new AnswerSection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sectionIndex"] = this.sectionIndex;
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item);
        }
        return data; 
    }
}

export interface IAnswerSection {
    sectionIndex?: number;
    answers?: any[] | undefined;
}

export class CreateSurveyResponseSettings implements ICreateSurveyResponseSettings {
    surveyContentId!: string;
    groupId!: string;
    surveyRequestId?: string | undefined;
    sections?: AnswerSection[] | undefined;
    submitted?: boolean;

    constructor(data?: ICreateSurveyResponseSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.surveyContentId = _data["surveyContentId"];
            this.groupId = _data["groupId"];
            this.surveyRequestId = _data["surveyRequestId"];
            if (Array.isArray(_data["sections"])) {
                this.sections = [] as any;
                for (let item of _data["sections"])
                    this.sections!.push(AnswerSection.fromJS(item));
            }
            this.submitted = _data["submitted"];
        }
    }

    static fromJS(data: any): CreateSurveyResponseSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSurveyResponseSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["surveyContentId"] = this.surveyContentId;
        data["groupId"] = this.groupId;
        data["surveyRequestId"] = this.surveyRequestId;
        if (Array.isArray(this.sections)) {
            data["sections"] = [];
            for (let item of this.sections)
                data["sections"].push(item.toJSON());
        }
        data["submitted"] = this.submitted;
        return data; 
    }
}

export interface ICreateSurveyResponseSettings {
    surveyContentId: string;
    groupId: string;
    surveyRequestId?: string | undefined;
    sections?: AnswerSection[] | undefined;
    submitted?: boolean;
}

export class UpdateSurveyResponseSettings implements IUpdateSurveyResponseSettings {
    sections?: AnswerSection[] | undefined;
    submitted?: boolean;
    version!: number;

    constructor(data?: IUpdateSurveyResponseSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["sections"])) {
                this.sections = [] as any;
                for (let item of _data["sections"])
                    this.sections!.push(AnswerSection.fromJS(item));
            }
            this.submitted = _data["submitted"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateSurveyResponseSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSurveyResponseSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.sections)) {
            data["sections"] = [];
            for (let item of this.sections)
                data["sections"].push(item.toJSON());
        }
        data["submitted"] = this.submitted;
        data["version"] = this.version;
        return data; 
    }
}

export interface IUpdateSurveyResponseSettings {
    sections?: AnswerSection[] | undefined;
    submitted?: boolean;
    version: number;
}

export class Actor implements IActor {
    id?: string | undefined;
    name?: string | undefined;
    imageUri?: string | undefined;
    type?: ActorType;

    constructor(data?: IActor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.imageUri = _data["imageUri"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): Actor {
        data = typeof data === 'object' ? data : {};
        let result = new Actor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["imageUri"] = this.imageUri;
        data["type"] = this.type;
        return data; 
    }
}

export interface IActor {
    id?: string | undefined;
    name?: string | undefined;
    imageUri?: string | undefined;
    type?: ActorType;
}

/** 0 = None 1 = User 2 = TrainingSession 3 = Team */
export enum ActorType {
    None = 0,
    User = 1,
    TrainingSession = 2,
    Team = 3,
}

export class ListOfModuleAttemptOfBookResult implements IListOfModuleAttemptOfBookResult {
    totalItemCount!: number;
    items!: ModuleAttemptOfBookResult[];

    constructor(data?: IListOfModuleAttemptOfBookResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ModuleAttemptOfBookResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfModuleAttemptOfBookResult {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfModuleAttemptOfBookResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfModuleAttemptOfBookResult {
    totalItemCount: number;
    items: ModuleAttemptOfBookResult[];
}

export class ModuleAttempt implements IModuleAttempt {
    id?: string | undefined;
    actorId?: string | undefined;
    actorType?: ActorType;
    actorName?: string | undefined;
    actorImageUri?: string | undefined;
    creatorId?: string | undefined;
    creatorName?: string | undefined;
    publisherId?: string | undefined;
    publisherName?: string | undefined;
    publisherLogoUri?: string | undefined;
    moduleId?: string | undefined;
    moduleName?: string | undefined;
    moduleContentId?: string | undefined;
    moduleType?: string | undefined;
    result?: any | undefined;
    calculatedResult?: CalculatedModuleResult;
    classIds?: string[] | undefined;
    trainingSessionId?: string | undefined;
    trainingSessionModuleAttemptId?: string | undefined;
    created?: Date;
    modified?: Date;
    passed?: Date | undefined;
    version?: number;

    constructor(data?: IModuleAttempt) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.actorId = _data["actorId"];
            this.actorType = _data["actorType"];
            this.actorName = _data["actorName"];
            this.actorImageUri = _data["actorImageUri"];
            this.creatorId = _data["creatorId"];
            this.creatorName = _data["creatorName"];
            this.publisherId = _data["publisherId"];
            this.publisherName = _data["publisherName"];
            this.publisherLogoUri = _data["publisherLogoUri"];
            this.moduleId = _data["moduleId"];
            this.moduleName = _data["moduleName"];
            this.moduleContentId = _data["moduleContentId"];
            this.moduleType = _data["moduleType"];
            this.result = _data["result"];
            this.calculatedResult = _data["calculatedResult"] ? CalculatedModuleResult.fromJS(_data["calculatedResult"]) : <any>undefined;
            if (Array.isArray(_data["classIds"])) {
                this.classIds = [] as any;
                for (let item of _data["classIds"])
                    this.classIds!.push(item);
            }
            this.trainingSessionId = _data["trainingSessionId"];
            this.trainingSessionModuleAttemptId = _data["trainingSessionModuleAttemptId"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
            this.passed = _data["passed"] ? new Date(_data["passed"].toString()) : <any>undefined;
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): ModuleAttempt {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleAttempt();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["actorId"] = this.actorId;
        data["actorType"] = this.actorType;
        data["actorName"] = this.actorName;
        data["actorImageUri"] = this.actorImageUri;
        data["creatorId"] = this.creatorId;
        data["creatorName"] = this.creatorName;
        data["publisherId"] = this.publisherId;
        data["publisherName"] = this.publisherName;
        data["publisherLogoUri"] = this.publisherLogoUri;
        data["moduleId"] = this.moduleId;
        data["moduleName"] = this.moduleName;
        data["moduleContentId"] = this.moduleContentId;
        data["moduleType"] = this.moduleType;
        data["result"] = this.result;
        data["calculatedResult"] = this.calculatedResult ? this.calculatedResult.toJSON() : <any>undefined;
        if (Array.isArray(this.classIds)) {
            data["classIds"] = [];
            for (let item of this.classIds)
                data["classIds"].push(item);
        }
        data["trainingSessionId"] = this.trainingSessionId;
        data["trainingSessionModuleAttemptId"] = this.trainingSessionModuleAttemptId;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        data["passed"] = this.passed ? this.passed.toISOString() : <any>undefined;
        data["version"] = this.version;
        return data; 
    }
}

export interface IModuleAttempt {
    id?: string | undefined;
    actorId?: string | undefined;
    actorType?: ActorType;
    actorName?: string | undefined;
    actorImageUri?: string | undefined;
    creatorId?: string | undefined;
    creatorName?: string | undefined;
    publisherId?: string | undefined;
    publisherName?: string | undefined;
    publisherLogoUri?: string | undefined;
    moduleId?: string | undefined;
    moduleName?: string | undefined;
    moduleContentId?: string | undefined;
    moduleType?: string | undefined;
    result?: any | undefined;
    calculatedResult?: CalculatedModuleResult;
    classIds?: string[] | undefined;
    trainingSessionId?: string | undefined;
    trainingSessionModuleAttemptId?: string | undefined;
    created?: Date;
    modified?: Date;
    passed?: Date | undefined;
    version?: number;
}

export class ModuleAttemptOfBookResult extends ModuleAttempt implements IModuleAttemptOfBookResult {
    result?: BookResult | undefined;

    constructor(data?: IModuleAttemptOfBookResult) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.result = _data["result"] ? BookResult.fromJS(_data["result"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ModuleAttemptOfBookResult {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleAttemptOfBookResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IModuleAttemptOfBookResult extends IModuleAttempt {
    result?: BookResult | undefined;
}

export class BookResult implements IBookResult {
    bookmark?: Bookmark | undefined;
    maxBookmark?: Bookmark | undefined;

    constructor(data?: IBookResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bookmark = _data["bookmark"] ? Bookmark.fromJS(_data["bookmark"]) : <any>undefined;
            this.maxBookmark = _data["maxBookmark"] ? Bookmark.fromJS(_data["maxBookmark"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BookResult {
        data = typeof data === 'object' ? data : {};
        let result = new BookResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bookmark"] = this.bookmark ? this.bookmark.toJSON() : <any>undefined;
        data["maxBookmark"] = this.maxBookmark ? this.maxBookmark.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBookResult {
    bookmark?: Bookmark | undefined;
    maxBookmark?: Bookmark | undefined;
}

export class Bookmark implements IBookmark {
    percentage?: number;

    constructor(data?: IBookmark) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.percentage = _data["percentage"];
        }
    }

    static fromJS(data: any): Bookmark {
        data = typeof data === 'object' ? data : {};
        let result = new Bookmark();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["percentage"] = this.percentage;
        return data; 
    }
}

export interface IBookmark {
    percentage?: number;
}

export class CalculatedModuleResult implements ICalculatedModuleResult {
    passed?: boolean;
    progress?: number;
    score?: number;

    constructor(data?: ICalculatedModuleResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.passed = _data["passed"];
            this.progress = _data["progress"];
            this.score = _data["score"];
        }
    }

    static fromJS(data: any): CalculatedModuleResult {
        data = typeof data === 'object' ? data : {};
        let result = new CalculatedModuleResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["passed"] = this.passed;
        data["progress"] = this.progress;
        data["score"] = this.score;
        return data; 
    }
}

export interface ICalculatedModuleResult {
    passed?: boolean;
    progress?: number;
    score?: number;
}

export class CreateModuleAttemptSettingsOfBookResult implements ICreateModuleAttemptSettingsOfBookResult {
    /** Id of the actor of ActorType being assessed */
    actorId!: string;
    moduleContentId!: string;
    result!: BookResult;

    constructor(data?: ICreateModuleAttemptSettingsOfBookResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new BookResult();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.actorId = _data["actorId"];
            this.moduleContentId = _data["moduleContentId"];
            this.result = _data["result"] ? BookResult.fromJS(_data["result"]) : new BookResult();
        }
    }

    static fromJS(data: any): CreateModuleAttemptSettingsOfBookResult {
        data = typeof data === 'object' ? data : {};
        let result = new CreateModuleAttemptSettingsOfBookResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actorId"] = this.actorId;
        data["moduleContentId"] = this.moduleContentId;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICreateModuleAttemptSettingsOfBookResult {
    /** Id of the actor of ActorType being assessed */
    actorId: string;
    moduleContentId: string;
    result: BookResult;
}

export class UpdateModuleAttemptSettingsOfBookResult implements IUpdateModuleAttemptSettingsOfBookResult {
    result!: BookResult;
    version?: number;

    constructor(data?: IUpdateModuleAttemptSettingsOfBookResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new BookResult();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? BookResult.fromJS(_data["result"]) : new BookResult();
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateModuleAttemptSettingsOfBookResult {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateModuleAttemptSettingsOfBookResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["version"] = this.version;
        return data; 
    }
}

export interface IUpdateModuleAttemptSettingsOfBookResult {
    result: BookResult;
    version?: number;
}

export class ListOfModuleContentOfBookSettings implements IListOfModuleContentOfBookSettings {
    totalItemCount!: number;
    items!: ModuleContentOfBookSettings[];

    constructor(data?: IListOfModuleContentOfBookSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ModuleContentOfBookSettings.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfModuleContentOfBookSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfModuleContentOfBookSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfModuleContentOfBookSettings {
    totalItemCount: number;
    items: ModuleContentOfBookSettings[];
}

export class ModuleContent implements IModuleContent {
    id?: string | undefined;
    publisherId?: string | undefined;
    moduleId?: string | undefined;
    type?: string | undefined;
    settings?: any | undefined;
    published?: boolean;
    created?: Date;
    modified?: Date;
    version?: number;

    constructor(data?: IModuleContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.publisherId = _data["publisherId"];
            this.moduleId = _data["moduleId"];
            this.type = _data["type"];
            this.settings = _data["settings"];
            this.published = _data["published"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): ModuleContent {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["publisherId"] = this.publisherId;
        data["moduleId"] = this.moduleId;
        data["type"] = this.type;
        data["settings"] = this.settings;
        data["published"] = this.published;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        data["version"] = this.version;
        return data; 
    }
}

export interface IModuleContent {
    id?: string | undefined;
    publisherId?: string | undefined;
    moduleId?: string | undefined;
    type?: string | undefined;
    settings?: any | undefined;
    published?: boolean;
    created?: Date;
    modified?: Date;
    version?: number;
}

export class ModuleContentOfBookSettings extends ModuleContent implements IModuleContentOfBookSettings {
    settings?: BookSettings | undefined;

    constructor(data?: IModuleContentOfBookSettings) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.settings = _data["settings"] ? BookSettings.fromJS(_data["settings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ModuleContentOfBookSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleContentOfBookSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IModuleContentOfBookSettings extends IModuleContent {
    settings?: BookSettings | undefined;
}

export class BookSettings implements IBookSettings {
    chapters!: Chapter[];

    constructor(data?: IBookSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.chapters = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["chapters"])) {
                this.chapters = [] as any;
                for (let item of _data["chapters"])
                    this.chapters!.push(Chapter.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BookSettings {
        data = typeof data === 'object' ? data : {};
        let result = new BookSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.chapters)) {
            data["chapters"] = [];
            for (let item of this.chapters)
                data["chapters"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IBookSettings {
    chapters: Chapter[];
}

export class Chapter implements IChapter {
    title?: string | undefined;
    body?: string | undefined;
    slides?: string[] | undefined;

    constructor(data?: IChapter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.body = _data["body"];
            if (Array.isArray(_data["slides"])) {
                this.slides = [] as any;
                for (let item of _data["slides"])
                    this.slides!.push(item);
            }
        }
    }

    static fromJS(data: any): Chapter {
        data = typeof data === 'object' ? data : {};
        let result = new Chapter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["body"] = this.body;
        if (Array.isArray(this.slides)) {
            data["slides"] = [];
            for (let item of this.slides)
                data["slides"].push(item);
        }
        return data; 
    }
}

export interface IChapter {
    title?: string | undefined;
    body?: string | undefined;
    slides?: string[] | undefined;
}

export class ModuleContentSettingsOfBookSettings implements IModuleContentSettingsOfBookSettings {
    settings!: BookSettings;
    files?: ModuleContentFileSettings[] | undefined;

    constructor(data?: IModuleContentSettingsOfBookSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.settings = new BookSettings();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.settings = _data["settings"] ? BookSettings.fromJS(_data["settings"]) : new BookSettings();
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(ModuleContentFileSettings.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ModuleContentSettingsOfBookSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleContentSettingsOfBookSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IModuleContentSettingsOfBookSettings {
    settings: BookSettings;
    files?: ModuleContentFileSettings[] | undefined;
}

export class CreateModuleContentSettingsOfBookSettings extends ModuleContentSettingsOfBookSettings implements ICreateModuleContentSettingsOfBookSettings {
    published?: boolean;

    constructor(data?: ICreateModuleContentSettingsOfBookSettings) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.published = _data["published"];
        }
    }

    static fromJS(data: any): CreateModuleContentSettingsOfBookSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateModuleContentSettingsOfBookSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["published"] = this.published;
        super.toJSON(data);
        return data; 
    }
}

export interface ICreateModuleContentSettingsOfBookSettings extends IModuleContentSettingsOfBookSettings {
    published?: boolean;
}

export class ModuleContentFileSettings implements IModuleContentFileSettings {
    name!: string;
    dataUri!: string;

    constructor(data?: IModuleContentFileSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.dataUri = _data["dataUri"];
        }
    }

    static fromJS(data: any): ModuleContentFileSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleContentFileSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["dataUri"] = this.dataUri;
        return data; 
    }
}

export interface IModuleContentFileSettings {
    name: string;
    dataUri: string;
}

export class UpdateModuleContentSettingsOfBookSettings extends ModuleContentSettingsOfBookSettings implements IUpdateModuleContentSettingsOfBookSettings {
    version?: number;

    constructor(data?: IUpdateModuleContentSettingsOfBookSettings) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateModuleContentSettingsOfBookSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateModuleContentSettingsOfBookSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        super.toJSON(data);
        return data; 
    }
}

export interface IUpdateModuleContentSettingsOfBookSettings extends IModuleContentSettingsOfBookSettings {
    version?: number;
}

export class ListOfCertificate implements IListOfCertificate {
    totalItemCount!: number;
    items!: Certificate[];

    constructor(data?: IListOfCertificate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Certificate.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfCertificate {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfCertificate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfCertificate {
    totalItemCount: number;
    items: Certificate[];
}

export class Certificate implements ICertificate {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    logoUri?: string | undefined;
    publisherId?: string | undefined;
    publisherName?: string | undefined;
    publisherLogoUri?: string | undefined;
    validityPeriod?: string;
    version?: number;

    constructor(data?: ICertificate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.logoUri = _data["logoUri"];
            this.publisherId = _data["publisherId"];
            this.publisherName = _data["publisherName"];
            this.publisherLogoUri = _data["publisherLogoUri"];
            this.validityPeriod = _data["validityPeriod"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): Certificate {
        data = typeof data === 'object' ? data : {};
        let result = new Certificate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["logoUri"] = this.logoUri;
        data["publisherId"] = this.publisherId;
        data["publisherName"] = this.publisherName;
        data["publisherLogoUri"] = this.publisherLogoUri;
        data["validityPeriod"] = this.validityPeriod;
        data["version"] = this.version;
        return data; 
    }
}

export interface ICertificate {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    logoUri?: string | undefined;
    publisherId?: string | undefined;
    publisherName?: string | undefined;
    publisherLogoUri?: string | undefined;
    validityPeriod?: string;
    version?: number;
}

export class CreateCertificateSettings implements ICreateCertificateSettings {
    publisherId!: string;
    name!: string;
    description?: string | undefined;
    logoUri?: string | undefined;
    validityPeriod?: string;

    constructor(data?: ICreateCertificateSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.publisherId = _data["publisherId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.logoUri = _data["logoUri"];
            this.validityPeriod = _data["validityPeriod"];
        }
    }

    static fromJS(data: any): CreateCertificateSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCertificateSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["publisherId"] = this.publisherId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["logoUri"] = this.logoUri;
        data["validityPeriod"] = this.validityPeriod;
        return data; 
    }
}

export interface ICreateCertificateSettings {
    publisherId: string;
    name: string;
    description?: string | undefined;
    logoUri?: string | undefined;
    validityPeriod?: string;
}

export class UpdateCertificateSettings implements IUpdateCertificateSettings {
    name!: string;
    description?: string | undefined;
    logoUri?: string | undefined;
    validityPeriod?: string;
    version?: number;

    constructor(data?: IUpdateCertificateSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.logoUri = _data["logoUri"];
            this.validityPeriod = _data["validityPeriod"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateCertificateSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCertificateSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["logoUri"] = this.logoUri;
        data["validityPeriod"] = this.validityPeriod;
        data["version"] = this.version;
        return data; 
    }
}

export interface IUpdateCertificateSettings {
    name: string;
    description?: string | undefined;
    logoUri?: string | undefined;
    validityPeriod?: string;
    version?: number;
}

export class ListOfCertification implements IListOfCertification {
    totalItemCount!: number;
    items!: Certification[];

    constructor(data?: IListOfCertification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Certification.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfCertification {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfCertification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfCertification {
    totalItemCount: number;
    items: Certification[];
}

export class Certification implements ICertification {
    id?: string | undefined;
    certificateId?: string | undefined;
    certificateName?: string | undefined;
    certificateLogoUri?: string | undefined;
    traineeId?: string | undefined;
    traineeName?: string | undefined;
    started?: Date;
    certified?: Date | undefined;
    expires?: Date | undefined;
    validityPeriod?: string;

    constructor(data?: ICertification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.certificateId = _data["certificateId"];
            this.certificateName = _data["certificateName"];
            this.certificateLogoUri = _data["certificateLogoUri"];
            this.traineeId = _data["traineeId"];
            this.traineeName = _data["traineeName"];
            this.started = _data["started"] ? new Date(_data["started"].toString()) : <any>undefined;
            this.certified = _data["certified"] ? new Date(_data["certified"].toString()) : <any>undefined;
            this.expires = _data["expires"] ? new Date(_data["expires"].toString()) : <any>undefined;
            this.validityPeriod = _data["validityPeriod"];
        }
    }

    static fromJS(data: any): Certification {
        data = typeof data === 'object' ? data : {};
        let result = new Certification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["certificateId"] = this.certificateId;
        data["certificateName"] = this.certificateName;
        data["certificateLogoUri"] = this.certificateLogoUri;
        data["traineeId"] = this.traineeId;
        data["traineeName"] = this.traineeName;
        data["started"] = this.started ? this.started.toISOString() : <any>undefined;
        data["certified"] = this.certified ? this.certified.toISOString() : <any>undefined;
        data["expires"] = this.expires ? this.expires.toISOString() : <any>undefined;
        data["validityPeriod"] = this.validityPeriod;
        return data; 
    }
}

export interface ICertification {
    id?: string | undefined;
    certificateId?: string | undefined;
    certificateName?: string | undefined;
    certificateLogoUri?: string | undefined;
    traineeId?: string | undefined;
    traineeName?: string | undefined;
    started?: Date;
    certified?: Date | undefined;
    expires?: Date | undefined;
    validityPeriod?: string;
}

export class ListOfCertificationFact implements IListOfCertificationFact {
    totalItemCount!: number;
    items!: CertificationFact[];

    constructor(data?: IListOfCertificationFact) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CertificationFact.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfCertificationFact {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfCertificationFact();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfCertificationFact {
    totalItemCount: number;
    items: CertificationFact[];
}

export class CertificationFact implements ICertificationFact {
    id?: string | undefined;
    certificationId?: string | undefined;
    certificateId?: string | undefined;
    traineeId?: string | undefined;
    created?: Date;
    started?: Date | undefined;
    certified?: Date | undefined;
    validityPeriod?: string | undefined;

    constructor(data?: ICertificationFact) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.certificationId = _data["certificationId"];
            this.certificateId = _data["certificateId"];
            this.traineeId = _data["traineeId"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.started = _data["started"] ? new Date(_data["started"].toString()) : <any>undefined;
            this.certified = _data["certified"] ? new Date(_data["certified"].toString()) : <any>undefined;
            this.validityPeriod = _data["validityPeriod"];
        }
    }

    static fromJS(data: any): CertificationFact {
        data = typeof data === 'object' ? data : {};
        let result = new CertificationFact();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["certificationId"] = this.certificationId;
        data["certificateId"] = this.certificateId;
        data["traineeId"] = this.traineeId;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["started"] = this.started ? this.started.toISOString() : <any>undefined;
        data["certified"] = this.certified ? this.certified.toISOString() : <any>undefined;
        data["validityPeriod"] = this.validityPeriod;
        return data; 
    }
}

export interface ICertificationFact {
    id?: string | undefined;
    certificationId?: string | undefined;
    certificateId?: string | undefined;
    traineeId?: string | undefined;
    created?: Date;
    started?: Date | undefined;
    certified?: Date | undefined;
    validityPeriod?: string | undefined;
}

/** 0 = None 1 = Left 2 = Requested 3 = Joined 4 = Banned */
export enum MemberStatus {
    None = 0,
    Left = 1,
    Requested = 2,
    Joined = 3,
    Banned = 4,
}

export class ListOfClass implements IListOfClass {
    totalItemCount!: number;
    items!: Class[];

    constructor(data?: IListOfClass) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Class.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfClass {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfClass();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfClass {
    totalItemCount: number;
    items: Class[];
}

export class Class implements IClass {
    id?: string | undefined;
    description?: string | undefined;
    gracePeriod?: string;
    allowAssessmentRequests?: boolean;
    teamId?: string | undefined;
    teamName?: string | undefined;
    teamCourseActivationId?: string | undefined;
    teamCourseActivated?: boolean;
    organisationId?: string | undefined;
    organisationName?: string | undefined;
    organisationLogoUri?: string | undefined;
    organisationCourseActivationId?: string | undefined;
    organisationCourseActivated?: boolean;
    publisherId?: string | undefined;
    publisherName?: string | undefined;
    publisherLogoUri?: string | undefined;
    courseId?: string | undefined;
    courseName?: string | undefined;
    courseDescription?: string | undefined;
    courseBannerUri?: string | undefined;
    courseLogoUri?: string | undefined;
    programs?: ProgramInClass[] | undefined;
    courseRecommendedJobTypeIds?: string[] | undefined;
    version?: number;

    constructor(data?: IClass) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.gracePeriod = _data["gracePeriod"];
            this.allowAssessmentRequests = _data["allowAssessmentRequests"];
            this.teamId = _data["teamId"];
            this.teamName = _data["teamName"];
            this.teamCourseActivationId = _data["teamCourseActivationId"];
            this.teamCourseActivated = _data["teamCourseActivated"];
            this.organisationId = _data["organisationId"];
            this.organisationName = _data["organisationName"];
            this.organisationLogoUri = _data["organisationLogoUri"];
            this.organisationCourseActivationId = _data["organisationCourseActivationId"];
            this.organisationCourseActivated = _data["organisationCourseActivated"];
            this.publisherId = _data["publisherId"];
            this.publisherName = _data["publisherName"];
            this.publisherLogoUri = _data["publisherLogoUri"];
            this.courseId = _data["courseId"];
            this.courseName = _data["courseName"];
            this.courseDescription = _data["courseDescription"];
            this.courseBannerUri = _data["courseBannerUri"];
            this.courseLogoUri = _data["courseLogoUri"];
            if (Array.isArray(_data["programs"])) {
                this.programs = [] as any;
                for (let item of _data["programs"])
                    this.programs!.push(ProgramInClass.fromJS(item));
            }
            if (Array.isArray(_data["courseRecommendedJobTypeIds"])) {
                this.courseRecommendedJobTypeIds = [] as any;
                for (let item of _data["courseRecommendedJobTypeIds"])
                    this.courseRecommendedJobTypeIds!.push(item);
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): Class {
        data = typeof data === 'object' ? data : {};
        let result = new Class();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["gracePeriod"] = this.gracePeriod;
        data["allowAssessmentRequests"] = this.allowAssessmentRequests;
        data["teamId"] = this.teamId;
        data["teamName"] = this.teamName;
        data["teamCourseActivationId"] = this.teamCourseActivationId;
        data["teamCourseActivated"] = this.teamCourseActivated;
        data["organisationId"] = this.organisationId;
        data["organisationName"] = this.organisationName;
        data["organisationLogoUri"] = this.organisationLogoUri;
        data["organisationCourseActivationId"] = this.organisationCourseActivationId;
        data["organisationCourseActivated"] = this.organisationCourseActivated;
        data["publisherId"] = this.publisherId;
        data["publisherName"] = this.publisherName;
        data["publisherLogoUri"] = this.publisherLogoUri;
        data["courseId"] = this.courseId;
        data["courseName"] = this.courseName;
        data["courseDescription"] = this.courseDescription;
        data["courseBannerUri"] = this.courseBannerUri;
        data["courseLogoUri"] = this.courseLogoUri;
        if (Array.isArray(this.programs)) {
            data["programs"] = [];
            for (let item of this.programs)
                data["programs"].push(item.toJSON());
        }
        if (Array.isArray(this.courseRecommendedJobTypeIds)) {
            data["courseRecommendedJobTypeIds"] = [];
            for (let item of this.courseRecommendedJobTypeIds)
                data["courseRecommendedJobTypeIds"].push(item);
        }
        data["version"] = this.version;
        return data; 
    }
}

export interface IClass {
    id?: string | undefined;
    description?: string | undefined;
    gracePeriod?: string;
    allowAssessmentRequests?: boolean;
    teamId?: string | undefined;
    teamName?: string | undefined;
    teamCourseActivationId?: string | undefined;
    teamCourseActivated?: boolean;
    organisationId?: string | undefined;
    organisationName?: string | undefined;
    organisationLogoUri?: string | undefined;
    organisationCourseActivationId?: string | undefined;
    organisationCourseActivated?: boolean;
    publisherId?: string | undefined;
    publisherName?: string | undefined;
    publisherLogoUri?: string | undefined;
    courseId?: string | undefined;
    courseName?: string | undefined;
    courseDescription?: string | undefined;
    courseBannerUri?: string | undefined;
    courseLogoUri?: string | undefined;
    programs?: ProgramInClass[] | undefined;
    courseRecommendedJobTypeIds?: string[] | undefined;
    version?: number;
}

export class ProgramInClass implements IProgramInClass {
    id?: string | undefined;
    name?: string | undefined;

    constructor(data?: IProgramInClass) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ProgramInClass {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramInClass();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IProgramInClass {
    id?: string | undefined;
    name?: string | undefined;
}

export class CreateClassSettings implements ICreateClassSettings {
    teamId!: string;
    courseId!: string;
    description?: string | undefined;
    gracePeriod?: string;
    allowAssessmentRequests?: boolean;

    constructor(data?: ICreateClassSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.teamId = _data["teamId"];
            this.courseId = _data["courseId"];
            this.description = _data["description"];
            this.gracePeriod = _data["gracePeriod"];
            this.allowAssessmentRequests = _data["allowAssessmentRequests"];
        }
    }

    static fromJS(data: any): CreateClassSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateClassSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["teamId"] = this.teamId;
        data["courseId"] = this.courseId;
        data["description"] = this.description;
        data["gracePeriod"] = this.gracePeriod;
        data["allowAssessmentRequests"] = this.allowAssessmentRequests;
        return data; 
    }
}

export interface ICreateClassSettings {
    teamId: string;
    courseId: string;
    description?: string | undefined;
    gracePeriod?: string;
    allowAssessmentRequests?: boolean;
}

export class UpdateClassSettings implements IUpdateClassSettings {
    description?: string | undefined;
    gracePeriod?: string;
    allowAssessmentRequests?: boolean;
    version?: number;

    constructor(data?: IUpdateClassSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.gracePeriod = _data["gracePeriod"];
            this.allowAssessmentRequests = _data["allowAssessmentRequests"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateClassSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateClassSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["gracePeriod"] = this.gracePeriod;
        data["allowAssessmentRequests"] = this.allowAssessmentRequests;
        data["version"] = this.version;
        return data; 
    }
}

export interface IUpdateClassSettings {
    description?: string | undefined;
    gracePeriod?: string;
    allowAssessmentRequests?: boolean;
    version?: number;
}

export class NotifyAssessorsSettings implements INotifyAssessorsSettings {
    enrolmentId!: string;
    assessmentId!: string;
    traineeId!: string;

    constructor(data?: INotifyAssessorsSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enrolmentId = _data["enrolmentId"];
            this.assessmentId = _data["assessmentId"];
            this.traineeId = _data["traineeId"];
        }
    }

    static fromJS(data: any): NotifyAssessorsSettings {
        data = typeof data === 'object' ? data : {};
        let result = new NotifyAssessorsSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enrolmentId"] = this.enrolmentId;
        data["assessmentId"] = this.assessmentId;
        data["traineeId"] = this.traineeId;
        return data; 
    }
}

export interface INotifyAssessorsSettings {
    enrolmentId: string;
    assessmentId: string;
    traineeId: string;
}

export class ListOfCourse implements IListOfCourse {
    totalItemCount!: number;
    items!: Course[];

    constructor(data?: IListOfCourse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Course.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfCourse {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfCourse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfCourse {
    totalItemCount: number;
    items: Course[];
}

export class Course implements ICourse {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    bannerUri?: string | undefined;
    logoUri?: string | undefined;
    mediaUris?: string[] | undefined;
    publisherId?: string | undefined;
    publisherName?: string | undefined;
    publisherLogoUri?: string | undefined;
    programs?: ProgramInCourse[] | undefined;
    sections?: SectionInCourse[] | undefined;
    certificates?: CertificateInCourse[] | undefined;
    recommendedJobTypeIds?: string[] | undefined;
    processReports?: ProcessReportInCourse[] | undefined;
    preSurvey?: SurveyInCourse | undefined;
    postSurvey?: SurveyInCourse | undefined;
    version?: number;

    constructor(data?: ICourse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.bannerUri = _data["bannerUri"];
            this.logoUri = _data["logoUri"];
            if (Array.isArray(_data["mediaUris"])) {
                this.mediaUris = [] as any;
                for (let item of _data["mediaUris"])
                    this.mediaUris!.push(item);
            }
            this.publisherId = _data["publisherId"];
            this.publisherName = _data["publisherName"];
            this.publisherLogoUri = _data["publisherLogoUri"];
            if (Array.isArray(_data["programs"])) {
                this.programs = [] as any;
                for (let item of _data["programs"])
                    this.programs!.push(ProgramInCourse.fromJS(item));
            }
            if (Array.isArray(_data["sections"])) {
                this.sections = [] as any;
                for (let item of _data["sections"])
                    this.sections!.push(SectionInCourse.fromJS(item));
            }
            if (Array.isArray(_data["certificates"])) {
                this.certificates = [] as any;
                for (let item of _data["certificates"])
                    this.certificates!.push(CertificateInCourse.fromJS(item));
            }
            if (Array.isArray(_data["recommendedJobTypeIds"])) {
                this.recommendedJobTypeIds = [] as any;
                for (let item of _data["recommendedJobTypeIds"])
                    this.recommendedJobTypeIds!.push(item);
            }
            if (Array.isArray(_data["processReports"])) {
                this.processReports = [] as any;
                for (let item of _data["processReports"])
                    this.processReports!.push(ProcessReportInCourse.fromJS(item));
            }
            this.preSurvey = _data["preSurvey"] ? SurveyInCourse.fromJS(_data["preSurvey"]) : <any>undefined;
            this.postSurvey = _data["postSurvey"] ? SurveyInCourse.fromJS(_data["postSurvey"]) : <any>undefined;
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): Course {
        data = typeof data === 'object' ? data : {};
        let result = new Course();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["bannerUri"] = this.bannerUri;
        data["logoUri"] = this.logoUri;
        if (Array.isArray(this.mediaUris)) {
            data["mediaUris"] = [];
            for (let item of this.mediaUris)
                data["mediaUris"].push(item);
        }
        data["publisherId"] = this.publisherId;
        data["publisherName"] = this.publisherName;
        data["publisherLogoUri"] = this.publisherLogoUri;
        if (Array.isArray(this.programs)) {
            data["programs"] = [];
            for (let item of this.programs)
                data["programs"].push(item.toJSON());
        }
        if (Array.isArray(this.sections)) {
            data["sections"] = [];
            for (let item of this.sections)
                data["sections"].push(item.toJSON());
        }
        if (Array.isArray(this.certificates)) {
            data["certificates"] = [];
            for (let item of this.certificates)
                data["certificates"].push(item.toJSON());
        }
        if (Array.isArray(this.recommendedJobTypeIds)) {
            data["recommendedJobTypeIds"] = [];
            for (let item of this.recommendedJobTypeIds)
                data["recommendedJobTypeIds"].push(item);
        }
        if (Array.isArray(this.processReports)) {
            data["processReports"] = [];
            for (let item of this.processReports)
                data["processReports"].push(item.toJSON());
        }
        data["preSurvey"] = this.preSurvey ? this.preSurvey.toJSON() : <any>undefined;
        data["postSurvey"] = this.postSurvey ? this.postSurvey.toJSON() : <any>undefined;
        data["version"] = this.version;
        return data; 
    }
}

export interface ICourse {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    bannerUri?: string | undefined;
    logoUri?: string | undefined;
    mediaUris?: string[] | undefined;
    publisherId?: string | undefined;
    publisherName?: string | undefined;
    publisherLogoUri?: string | undefined;
    programs?: ProgramInCourse[] | undefined;
    sections?: SectionInCourse[] | undefined;
    certificates?: CertificateInCourse[] | undefined;
    recommendedJobTypeIds?: string[] | undefined;
    processReports?: ProcessReportInCourse[] | undefined;
    preSurvey?: SurveyInCourse | undefined;
    postSurvey?: SurveyInCourse | undefined;
    version?: number;
}

export class ProgramInCourse implements IProgramInCourse {
    id?: string | undefined;
    name?: string | undefined;

    constructor(data?: IProgramInCourse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ProgramInCourse {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramInCourse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IProgramInCourse {
    id?: string | undefined;
    name?: string | undefined;
}

export class SectionInCourse implements ISectionInCourse {
    name?: string | undefined;
    modules?: ModuleInCourse[] | undefined;

    constructor(data?: ISectionInCourse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["modules"])) {
                this.modules = [] as any;
                for (let item of _data["modules"])
                    this.modules!.push(ModuleInCourse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SectionInCourse {
        data = typeof data === 'object' ? data : {};
        let result = new SectionInCourse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.modules)) {
            data["modules"] = [];
            for (let item of this.modules)
                data["modules"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISectionInCourse {
    name?: string | undefined;
    modules?: ModuleInCourse[] | undefined;
}

export class ModuleInCourse implements IModuleInCourse {
    id?: string | undefined;
    name?: string | undefined;
    type?: string | undefined;
    imageUri?: string | undefined;
    open?: boolean;

    constructor(data?: IModuleInCourse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.imageUri = _data["imageUri"];
            this.open = _data["open"];
        }
    }

    static fromJS(data: any): ModuleInCourse {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleInCourse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["type"] = this.type;
        data["imageUri"] = this.imageUri;
        data["open"] = this.open;
        return data; 
    }
}

export interface IModuleInCourse {
    id?: string | undefined;
    name?: string | undefined;
    type?: string | undefined;
    imageUri?: string | undefined;
    open?: boolean;
}

export class CertificateInCourse implements ICertificateInCourse {
    id?: string | undefined;
    name?: string | undefined;
    logoUri?: string | undefined;
    validityPeriod?: string;
    moduleIds?: string[] | undefined;

    constructor(data?: ICertificateInCourse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.logoUri = _data["logoUri"];
            this.validityPeriod = _data["validityPeriod"];
            if (Array.isArray(_data["moduleIds"])) {
                this.moduleIds = [] as any;
                for (let item of _data["moduleIds"])
                    this.moduleIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CertificateInCourse {
        data = typeof data === 'object' ? data : {};
        let result = new CertificateInCourse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["logoUri"] = this.logoUri;
        data["validityPeriod"] = this.validityPeriod;
        if (Array.isArray(this.moduleIds)) {
            data["moduleIds"] = [];
            for (let item of this.moduleIds)
                data["moduleIds"].push(item);
        }
        return data; 
    }
}

export interface ICertificateInCourse {
    id?: string | undefined;
    name?: string | undefined;
    logoUri?: string | undefined;
    validityPeriod?: string;
    moduleIds?: string[] | undefined;
}

export class ProcessReportInCourse implements IProcessReportInCourse {
    id?: string | undefined;
    name?: string | undefined;
    type?: string | undefined;

    constructor(data?: IProcessReportInCourse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ProcessReportInCourse {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessReportInCourse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["type"] = this.type;
        return data; 
    }
}

export interface IProcessReportInCourse {
    id?: string | undefined;
    name?: string | undefined;
    type?: string | undefined;
}

export class SurveyInCourse implements ISurveyInCourse {
    id?: string | undefined;
    name?: string | undefined;
    required?: boolean;

    constructor(data?: ISurveyInCourse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.required = _data["required"];
        }
    }

    static fromJS(data: any): SurveyInCourse {
        data = typeof data === 'object' ? data : {};
        let result = new SurveyInCourse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["required"] = this.required;
        return data; 
    }
}

export interface ISurveyInCourse {
    id?: string | undefined;
    name?: string | undefined;
    required?: boolean;
}

export class CreateCourseSettings implements ICreateCourseSettings {
    publisherId!: string;
    name!: string;
    /** A base64 encoded image or a URL of existing image
             */
    bannerUri?: string | undefined;
    /** A base64 encoded image or a URL of existing image
             */
    logoUri?: string | undefined;
    /** A list of promotional medias. Elements can be: 
    - base64 encoded image
    - uri of image
    - url of video (i.e. video has to be hosted elsewhere, at least for now) */
    mediaUris?: string[] | undefined;
    description?: string | undefined;
    sections?: CourseSection[] | undefined;
    recommendedJobTypeIds?: string[] | undefined;
    processReportIds?: string[] | undefined;
    preSurvey?: CourseSurvey | undefined;
    postSurvey?: CourseSurvey | undefined;

    constructor(data?: ICreateCourseSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.publisherId = _data["publisherId"];
            this.name = _data["name"];
            this.bannerUri = _data["bannerUri"];
            this.logoUri = _data["logoUri"];
            if (Array.isArray(_data["mediaUris"])) {
                this.mediaUris = [] as any;
                for (let item of _data["mediaUris"])
                    this.mediaUris!.push(item);
            }
            this.description = _data["description"];
            if (Array.isArray(_data["sections"])) {
                this.sections = [] as any;
                for (let item of _data["sections"])
                    this.sections!.push(CourseSection.fromJS(item));
            }
            if (Array.isArray(_data["recommendedJobTypeIds"])) {
                this.recommendedJobTypeIds = [] as any;
                for (let item of _data["recommendedJobTypeIds"])
                    this.recommendedJobTypeIds!.push(item);
            }
            if (Array.isArray(_data["processReportIds"])) {
                this.processReportIds = [] as any;
                for (let item of _data["processReportIds"])
                    this.processReportIds!.push(item);
            }
            this.preSurvey = _data["preSurvey"] ? CourseSurvey.fromJS(_data["preSurvey"]) : <any>undefined;
            this.postSurvey = _data["postSurvey"] ? CourseSurvey.fromJS(_data["postSurvey"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateCourseSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCourseSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["publisherId"] = this.publisherId;
        data["name"] = this.name;
        data["bannerUri"] = this.bannerUri;
        data["logoUri"] = this.logoUri;
        if (Array.isArray(this.mediaUris)) {
            data["mediaUris"] = [];
            for (let item of this.mediaUris)
                data["mediaUris"].push(item);
        }
        data["description"] = this.description;
        if (Array.isArray(this.sections)) {
            data["sections"] = [];
            for (let item of this.sections)
                data["sections"].push(item.toJSON());
        }
        if (Array.isArray(this.recommendedJobTypeIds)) {
            data["recommendedJobTypeIds"] = [];
            for (let item of this.recommendedJobTypeIds)
                data["recommendedJobTypeIds"].push(item);
        }
        if (Array.isArray(this.processReportIds)) {
            data["processReportIds"] = [];
            for (let item of this.processReportIds)
                data["processReportIds"].push(item);
        }
        data["preSurvey"] = this.preSurvey ? this.preSurvey.toJSON() : <any>undefined;
        data["postSurvey"] = this.postSurvey ? this.postSurvey.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICreateCourseSettings {
    publisherId: string;
    name: string;
    /** A base64 encoded image or a URL of existing image
             */
    bannerUri?: string | undefined;
    /** A base64 encoded image or a URL of existing image
             */
    logoUri?: string | undefined;
    /** A list of promotional medias. Elements can be: 
    - base64 encoded image
    - uri of image
    - url of video (i.e. video has to be hosted elsewhere, at least for now) */
    mediaUris?: string[] | undefined;
    description?: string | undefined;
    sections?: CourseSection[] | undefined;
    recommendedJobTypeIds?: string[] | undefined;
    processReportIds?: string[] | undefined;
    preSurvey?: CourseSurvey | undefined;
    postSurvey?: CourseSurvey | undefined;
}

export class CourseSection implements ICourseSection {
    name?: string | undefined;
    modules?: CourseModule[] | undefined;

    constructor(data?: ICourseSection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["modules"])) {
                this.modules = [] as any;
                for (let item of _data["modules"])
                    this.modules!.push(CourseModule.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CourseSection {
        data = typeof data === 'object' ? data : {};
        let result = new CourseSection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.modules)) {
            data["modules"] = [];
            for (let item of this.modules)
                data["modules"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICourseSection {
    name?: string | undefined;
    modules?: CourseModule[] | undefined;
}

export class CourseModule implements ICourseModule {
    id?: string | undefined;
    open?: boolean;
    certificateIds?: string[] | undefined;

    constructor(data?: ICourseModule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.open = _data["open"];
            if (Array.isArray(_data["certificateIds"])) {
                this.certificateIds = [] as any;
                for (let item of _data["certificateIds"])
                    this.certificateIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CourseModule {
        data = typeof data === 'object' ? data : {};
        let result = new CourseModule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["open"] = this.open;
        if (Array.isArray(this.certificateIds)) {
            data["certificateIds"] = [];
            for (let item of this.certificateIds)
                data["certificateIds"].push(item);
        }
        return data; 
    }
}

export interface ICourseModule {
    id?: string | undefined;
    open?: boolean;
    certificateIds?: string[] | undefined;
}

export class CourseSurvey implements ICourseSurvey {
    id?: string | undefined;
    required?: boolean;

    constructor(data?: ICourseSurvey) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.required = _data["required"];
        }
    }

    static fromJS(data: any): CourseSurvey {
        data = typeof data === 'object' ? data : {};
        let result = new CourseSurvey();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["required"] = this.required;
        return data; 
    }
}

export interface ICourseSurvey {
    id?: string | undefined;
    required?: boolean;
}

export class UpdateCourseSettings implements IUpdateCourseSettings {
    name!: string;
    bannerUri?: string | undefined;
    logoUri?: string | undefined;
    mediaUris?: string[] | undefined;
    description?: string | undefined;
    open?: boolean;
    sections?: CourseSection[] | undefined;
    recommendedJobTypeIds?: string[] | undefined;
    processReportIds?: string[] | undefined;
    preSurvey?: CourseSurvey | undefined;
    postSurvey?: CourseSurvey | undefined;
    version?: number;

    constructor(data?: IUpdateCourseSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.bannerUri = _data["bannerUri"];
            this.logoUri = _data["logoUri"];
            if (Array.isArray(_data["mediaUris"])) {
                this.mediaUris = [] as any;
                for (let item of _data["mediaUris"])
                    this.mediaUris!.push(item);
            }
            this.description = _data["description"];
            this.open = _data["open"];
            if (Array.isArray(_data["sections"])) {
                this.sections = [] as any;
                for (let item of _data["sections"])
                    this.sections!.push(CourseSection.fromJS(item));
            }
            if (Array.isArray(_data["recommendedJobTypeIds"])) {
                this.recommendedJobTypeIds = [] as any;
                for (let item of _data["recommendedJobTypeIds"])
                    this.recommendedJobTypeIds!.push(item);
            }
            if (Array.isArray(_data["processReportIds"])) {
                this.processReportIds = [] as any;
                for (let item of _data["processReportIds"])
                    this.processReportIds!.push(item);
            }
            this.preSurvey = _data["preSurvey"] ? CourseSurvey.fromJS(_data["preSurvey"]) : <any>undefined;
            this.postSurvey = _data["postSurvey"] ? CourseSurvey.fromJS(_data["postSurvey"]) : <any>undefined;
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateCourseSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCourseSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["bannerUri"] = this.bannerUri;
        data["logoUri"] = this.logoUri;
        if (Array.isArray(this.mediaUris)) {
            data["mediaUris"] = [];
            for (let item of this.mediaUris)
                data["mediaUris"].push(item);
        }
        data["description"] = this.description;
        data["open"] = this.open;
        if (Array.isArray(this.sections)) {
            data["sections"] = [];
            for (let item of this.sections)
                data["sections"].push(item.toJSON());
        }
        if (Array.isArray(this.recommendedJobTypeIds)) {
            data["recommendedJobTypeIds"] = [];
            for (let item of this.recommendedJobTypeIds)
                data["recommendedJobTypeIds"].push(item);
        }
        if (Array.isArray(this.processReportIds)) {
            data["processReportIds"] = [];
            for (let item of this.processReportIds)
                data["processReportIds"].push(item);
        }
        data["preSurvey"] = this.preSurvey ? this.preSurvey.toJSON() : <any>undefined;
        data["postSurvey"] = this.postSurvey ? this.postSurvey.toJSON() : <any>undefined;
        data["version"] = this.version;
        return data; 
    }
}

export interface IUpdateCourseSettings {
    name: string;
    bannerUri?: string | undefined;
    logoUri?: string | undefined;
    mediaUris?: string[] | undefined;
    description?: string | undefined;
    open?: boolean;
    sections?: CourseSection[] | undefined;
    recommendedJobTypeIds?: string[] | undefined;
    processReportIds?: string[] | undefined;
    preSurvey?: CourseSurvey | undefined;
    postSurvey?: CourseSurvey | undefined;
    version?: number;
}

export class ListOfEnrolment implements IListOfEnrolment {
    totalItemCount!: number;
    items!: Enrolment[];

    constructor(data?: IListOfEnrolment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Enrolment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfEnrolment {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfEnrolment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfEnrolment {
    totalItemCount: number;
    items: Enrolment[];
}

export class Enrolment2 implements IEnrolment2 {
    id?: string | undefined;
    traineeId?: string | undefined;
    traineeName?: string | undefined;
    traineeImageUri?: string | undefined;
    traineeJobTypeId?: string | undefined;
    traineeJobTypeName?: string | undefined;
    traineeCourseActivationId?: string | undefined;
    traineeCourseActivated?: boolean;
    publisherId?: string | undefined;
    publisherName?: string | undefined;
    publisherLogoUri?: string | undefined;
    programs?: ProgramInEnrolment[] | undefined;
    courseId?: string | undefined;
    courseName?: string | undefined;
    courseBannerUri?: string | undefined;
    courseLogoUri?: string | undefined;
    classes?: ClassInEnrolment[] | undefined;

    constructor(data?: IEnrolment2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.traineeId = _data["traineeId"];
            this.traineeName = _data["traineeName"];
            this.traineeImageUri = _data["traineeImageUri"];
            this.traineeJobTypeId = _data["traineeJobTypeId"];
            this.traineeJobTypeName = _data["traineeJobTypeName"];
            this.traineeCourseActivationId = _data["traineeCourseActivationId"];
            this.traineeCourseActivated = _data["traineeCourseActivated"];
            this.publisherId = _data["publisherId"];
            this.publisherName = _data["publisherName"];
            this.publisherLogoUri = _data["publisherLogoUri"];
            if (Array.isArray(_data["programs"])) {
                this.programs = [] as any;
                for (let item of _data["programs"])
                    this.programs!.push(ProgramInEnrolment.fromJS(item));
            }
            this.courseId = _data["courseId"];
            this.courseName = _data["courseName"];
            this.courseBannerUri = _data["courseBannerUri"];
            this.courseLogoUri = _data["courseLogoUri"];
            if (Array.isArray(_data["classes"])) {
                this.classes = [] as any;
                for (let item of _data["classes"])
                    this.classes!.push(ClassInEnrolment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Enrolment2 {
        data = typeof data === 'object' ? data : {};
        let result = new Enrolment2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["traineeId"] = this.traineeId;
        data["traineeName"] = this.traineeName;
        data["traineeImageUri"] = this.traineeImageUri;
        data["traineeJobTypeId"] = this.traineeJobTypeId;
        data["traineeJobTypeName"] = this.traineeJobTypeName;
        data["traineeCourseActivationId"] = this.traineeCourseActivationId;
        data["traineeCourseActivated"] = this.traineeCourseActivated;
        data["publisherId"] = this.publisherId;
        data["publisherName"] = this.publisherName;
        data["publisherLogoUri"] = this.publisherLogoUri;
        if (Array.isArray(this.programs)) {
            data["programs"] = [];
            for (let item of this.programs)
                data["programs"].push(item.toJSON());
        }
        data["courseId"] = this.courseId;
        data["courseName"] = this.courseName;
        data["courseBannerUri"] = this.courseBannerUri;
        data["courseLogoUri"] = this.courseLogoUri;
        if (Array.isArray(this.classes)) {
            data["classes"] = [];
            for (let item of this.classes)
                data["classes"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IEnrolment2 {
    id?: string | undefined;
    traineeId?: string | undefined;
    traineeName?: string | undefined;
    traineeImageUri?: string | undefined;
    traineeJobTypeId?: string | undefined;
    traineeJobTypeName?: string | undefined;
    traineeCourseActivationId?: string | undefined;
    traineeCourseActivated?: boolean;
    publisherId?: string | undefined;
    publisherName?: string | undefined;
    publisherLogoUri?: string | undefined;
    programs?: ProgramInEnrolment[] | undefined;
    courseId?: string | undefined;
    courseName?: string | undefined;
    courseBannerUri?: string | undefined;
    courseLogoUri?: string | undefined;
    classes?: ClassInEnrolment[] | undefined;
}

export class Enrolment extends Enrolment2 implements IEnrolment {
    courseSections?: CourseSectionInEnrolment[] | undefined;
    certifications?: CertificationInEnrolment[] | undefined;
    preSurveyResponse?: SurveyResponseInEnrolment | undefined;
    postSurveyResponse?: SurveyResponseInEnrolment | undefined;

    constructor(data?: IEnrolment) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["courseSections"])) {
                this.courseSections = [] as any;
                for (let item of _data["courseSections"])
                    this.courseSections!.push(CourseSectionInEnrolment.fromJS(item));
            }
            if (Array.isArray(_data["certifications"])) {
                this.certifications = [] as any;
                for (let item of _data["certifications"])
                    this.certifications!.push(CertificationInEnrolment.fromJS(item));
            }
            this.preSurveyResponse = _data["preSurveyResponse"] ? SurveyResponseInEnrolment.fromJS(_data["preSurveyResponse"]) : <any>undefined;
            this.postSurveyResponse = _data["postSurveyResponse"] ? SurveyResponseInEnrolment.fromJS(_data["postSurveyResponse"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Enrolment {
        data = typeof data === 'object' ? data : {};
        let result = new Enrolment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.courseSections)) {
            data["courseSections"] = [];
            for (let item of this.courseSections)
                data["courseSections"].push(item.toJSON());
        }
        if (Array.isArray(this.certifications)) {
            data["certifications"] = [];
            for (let item of this.certifications)
                data["certifications"].push(item.toJSON());
        }
        data["preSurveyResponse"] = this.preSurveyResponse ? this.preSurveyResponse.toJSON() : <any>undefined;
        data["postSurveyResponse"] = this.postSurveyResponse ? this.postSurveyResponse.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IEnrolment extends IEnrolment2 {
    courseSections?: CourseSectionInEnrolment[] | undefined;
    certifications?: CertificationInEnrolment[] | undefined;
    preSurveyResponse?: SurveyResponseInEnrolment | undefined;
    postSurveyResponse?: SurveyResponseInEnrolment | undefined;
}

export class CourseSectionInEnrolment implements ICourseSectionInEnrolment {
    name?: string | undefined;
    modules?: ModuleInEnrolment[] | undefined;

    constructor(data?: ICourseSectionInEnrolment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["modules"])) {
                this.modules = [] as any;
                for (let item of _data["modules"])
                    this.modules!.push(ModuleInEnrolment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CourseSectionInEnrolment {
        data = typeof data === 'object' ? data : {};
        let result = new CourseSectionInEnrolment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.modules)) {
            data["modules"] = [];
            for (let item of this.modules)
                data["modules"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICourseSectionInEnrolment {
    name?: string | undefined;
    modules?: ModuleInEnrolment[] | undefined;
}

export class ModuleInEnrolment implements IModuleInEnrolment {
    id?: string | undefined;
    name?: string | undefined;
    type?: string | undefined;
    imageUri?: string | undefined;
    open?: boolean;
    result?: CalculatedModuleResult | undefined;
    modified?: Date | undefined;

    constructor(data?: IModuleInEnrolment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.imageUri = _data["imageUri"];
            this.open = _data["open"];
            this.result = _data["result"] ? CalculatedModuleResult.fromJS(_data["result"]) : <any>undefined;
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ModuleInEnrolment {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleInEnrolment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["type"] = this.type;
        data["imageUri"] = this.imageUri;
        data["open"] = this.open;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IModuleInEnrolment {
    id?: string | undefined;
    name?: string | undefined;
    type?: string | undefined;
    imageUri?: string | undefined;
    open?: boolean;
    result?: CalculatedModuleResult | undefined;
    modified?: Date | undefined;
}

export class CertificationInEnrolment implements ICertificationInEnrolment {
    id?: string | undefined;
    certificateId?: string | undefined;
    certificateName?: string | undefined;
    certificateLogoUri?: string | undefined;
    certificateModuleIds?: string[] | undefined;
    started?: Date | undefined;
    certified?: Date | undefined;
    expires?: Date | undefined;

    constructor(data?: ICertificationInEnrolment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.certificateId = _data["certificateId"];
            this.certificateName = _data["certificateName"];
            this.certificateLogoUri = _data["certificateLogoUri"];
            if (Array.isArray(_data["certificateModuleIds"])) {
                this.certificateModuleIds = [] as any;
                for (let item of _data["certificateModuleIds"])
                    this.certificateModuleIds!.push(item);
            }
            this.started = _data["started"] ? new Date(_data["started"].toString()) : <any>undefined;
            this.certified = _data["certified"] ? new Date(_data["certified"].toString()) : <any>undefined;
            this.expires = _data["expires"] ? new Date(_data["expires"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CertificationInEnrolment {
        data = typeof data === 'object' ? data : {};
        let result = new CertificationInEnrolment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["certificateId"] = this.certificateId;
        data["certificateName"] = this.certificateName;
        data["certificateLogoUri"] = this.certificateLogoUri;
        if (Array.isArray(this.certificateModuleIds)) {
            data["certificateModuleIds"] = [];
            for (let item of this.certificateModuleIds)
                data["certificateModuleIds"].push(item);
        }
        data["started"] = this.started ? this.started.toISOString() : <any>undefined;
        data["certified"] = this.certified ? this.certified.toISOString() : <any>undefined;
        data["expires"] = this.expires ? this.expires.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ICertificationInEnrolment {
    id?: string | undefined;
    certificateId?: string | undefined;
    certificateName?: string | undefined;
    certificateLogoUri?: string | undefined;
    certificateModuleIds?: string[] | undefined;
    started?: Date | undefined;
    certified?: Date | undefined;
    expires?: Date | undefined;
}

export class SurveyResponseInEnrolment implements ISurveyResponseInEnrolment {
    surveyId?: string | undefined;
    surveyName?: string | undefined;
    required?: boolean;
    started?: Date | undefined;
    submitted?: Date | undefined;

    constructor(data?: ISurveyResponseInEnrolment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.surveyId = _data["surveyId"];
            this.surveyName = _data["surveyName"];
            this.required = _data["required"];
            this.started = _data["started"] ? new Date(_data["started"].toString()) : <any>undefined;
            this.submitted = _data["submitted"] ? new Date(_data["submitted"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SurveyResponseInEnrolment {
        data = typeof data === 'object' ? data : {};
        let result = new SurveyResponseInEnrolment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["surveyId"] = this.surveyId;
        data["surveyName"] = this.surveyName;
        data["required"] = this.required;
        data["started"] = this.started ? this.started.toISOString() : <any>undefined;
        data["submitted"] = this.submitted ? this.submitted.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ISurveyResponseInEnrolment {
    surveyId?: string | undefined;
    surveyName?: string | undefined;
    required?: boolean;
    started?: Date | undefined;
    submitted?: Date | undefined;
}

export class ProgramInEnrolment implements IProgramInEnrolment {
    id?: string | undefined;
    name?: string | undefined;

    constructor(data?: IProgramInEnrolment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ProgramInEnrolment {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramInEnrolment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IProgramInEnrolment {
    id?: string | undefined;
    name?: string | undefined;
}

export class ClassInEnrolment implements IClassInEnrolment {
    id?: string | undefined;
    teamId?: string | undefined;
    teamName?: string | undefined;
    teamCourseActivationId?: string | undefined;
    teamCourseActivated?: boolean;
    organisationId?: string | undefined;
    organisationName?: string | undefined;
    organisationCourseActivationId?: string | undefined;
    organisationCourseActivated?: boolean;
    joined?: Date;
    gracePeriod?: string;
    description?: string | undefined;

    constructor(data?: IClassInEnrolment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.teamId = _data["teamId"];
            this.teamName = _data["teamName"];
            this.teamCourseActivationId = _data["teamCourseActivationId"];
            this.teamCourseActivated = _data["teamCourseActivated"];
            this.organisationId = _data["organisationId"];
            this.organisationName = _data["organisationName"];
            this.organisationCourseActivationId = _data["organisationCourseActivationId"];
            this.organisationCourseActivated = _data["organisationCourseActivated"];
            this.joined = _data["joined"] ? new Date(_data["joined"].toString()) : <any>undefined;
            this.gracePeriod = _data["gracePeriod"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ClassInEnrolment {
        data = typeof data === 'object' ? data : {};
        let result = new ClassInEnrolment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["teamId"] = this.teamId;
        data["teamName"] = this.teamName;
        data["teamCourseActivationId"] = this.teamCourseActivationId;
        data["teamCourseActivated"] = this.teamCourseActivated;
        data["organisationId"] = this.organisationId;
        data["organisationName"] = this.organisationName;
        data["organisationCourseActivationId"] = this.organisationCourseActivationId;
        data["organisationCourseActivated"] = this.organisationCourseActivated;
        data["joined"] = this.joined ? this.joined.toISOString() : <any>undefined;
        data["gracePeriod"] = this.gracePeriod;
        data["description"] = this.description;
        return data; 
    }
}

export interface IClassInEnrolment {
    id?: string | undefined;
    teamId?: string | undefined;
    teamName?: string | undefined;
    teamCourseActivationId?: string | undefined;
    teamCourseActivated?: boolean;
    organisationId?: string | undefined;
    organisationName?: string | undefined;
    organisationCourseActivationId?: string | undefined;
    organisationCourseActivated?: boolean;
    joined?: Date;
    gracePeriod?: string;
    description?: string | undefined;
}

export class ListOfModuleAttempt implements IListOfModuleAttempt {
    totalItemCount!: number;
    items!: ModuleAttempt[];

    constructor(data?: IListOfModuleAttempt) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ModuleAttempt.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfModuleAttempt {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfModuleAttempt();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfModuleAttempt {
    totalItemCount: number;
    items: ModuleAttempt[];
}

export class ListOfModule implements IListOfModule {
    totalItemCount!: number;
    items!: Module[];

    constructor(data?: IListOfModule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Module.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfModule {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfModule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfModule {
    totalItemCount: number;
    items: Module[];
}

export class Module implements IModule {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    imageUri?: string | undefined;
    publisherId?: string | undefined;
    publisherName?: string | undefined;
    publisherLogoUri?: string | undefined;
    type?: string | undefined;
    published?: boolean;
    publishedContentId?: string | undefined;
    version?: number;

    constructor(data?: IModule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.imageUri = _data["imageUri"];
            this.publisherId = _data["publisherId"];
            this.publisherName = _data["publisherName"];
            this.publisherLogoUri = _data["publisherLogoUri"];
            this.type = _data["type"];
            this.published = _data["published"];
            this.publishedContentId = _data["publishedContentId"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): Module {
        data = typeof data === 'object' ? data : {};
        let result = new Module();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["imageUri"] = this.imageUri;
        data["publisherId"] = this.publisherId;
        data["publisherName"] = this.publisherName;
        data["publisherLogoUri"] = this.publisherLogoUri;
        data["type"] = this.type;
        data["published"] = this.published;
        data["publishedContentId"] = this.publishedContentId;
        data["version"] = this.version;
        return data; 
    }
}

export interface IModule {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    imageUri?: string | undefined;
    publisherId?: string | undefined;
    publisherName?: string | undefined;
    publisherLogoUri?: string | undefined;
    type?: string | undefined;
    published?: boolean;
    publishedContentId?: string | undefined;
    version?: number;
}

export class CreateModuleSettings implements ICreateModuleSettings {
    publisherId!: string;
    type!: string;
    name!: string;
    description?: string | undefined;
    imageUri?: string | undefined;
    files?: CreateFileSettings[] | undefined;

    constructor(data?: ICreateModuleSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.publisherId = _data["publisherId"];
            this.type = _data["type"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.imageUri = _data["imageUri"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(CreateFileSettings.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateModuleSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateModuleSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["publisherId"] = this.publisherId;
        data["type"] = this.type;
        data["name"] = this.name;
        data["description"] = this.description;
        data["imageUri"] = this.imageUri;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateModuleSettings {
    publisherId: string;
    type: string;
    name: string;
    description?: string | undefined;
    imageUri?: string | undefined;
    files?: CreateFileSettings[] | undefined;
}

export class UpdateModuleSettings implements IUpdateModuleSettings {
    name!: string;
    description?: string | undefined;
    imageUri?: string | undefined;
    version?: number;

    constructor(data?: IUpdateModuleSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.imageUri = _data["imageUri"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateModuleSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateModuleSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["imageUri"] = this.imageUri;
        data["version"] = this.version;
        return data; 
    }
}

export interface IUpdateModuleSettings {
    name: string;
    description?: string | undefined;
    imageUri?: string | undefined;
    version?: number;
}

export class ListOfModuleNps implements IListOfModuleNps {
    totalItemCount!: number;
    items!: ModuleNps[];

    constructor(data?: IListOfModuleNps) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ModuleNps.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfModuleNps {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfModuleNps();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfModuleNps {
    totalItemCount: number;
    items: ModuleNps[];
}

export class ModuleNps implements IModuleNps {
    id?: string | undefined;
    score?: number;
    comments?: string | undefined;
    dismissed?: boolean;
    created?: Date;
    creatorId?: string | undefined;
    creatorName?: string | undefined;
    creatorImageUri?: string | undefined;
    creatorJobTypeId?: string | undefined;
    creatorJobTypeName?: string | undefined;
    moduleId?: string | undefined;
    moduleName?: string | undefined;
    moduleType?: string | undefined;

    constructor(data?: IModuleNps) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.score = _data["score"];
            this.comments = _data["comments"];
            this.dismissed = _data["dismissed"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.creatorId = _data["creatorId"];
            this.creatorName = _data["creatorName"];
            this.creatorImageUri = _data["creatorImageUri"];
            this.creatorJobTypeId = _data["creatorJobTypeId"];
            this.creatorJobTypeName = _data["creatorJobTypeName"];
            this.moduleId = _data["moduleId"];
            this.moduleName = _data["moduleName"];
            this.moduleType = _data["moduleType"];
        }
    }

    static fromJS(data: any): ModuleNps {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleNps();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["score"] = this.score;
        data["comments"] = this.comments;
        data["dismissed"] = this.dismissed;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["creatorId"] = this.creatorId;
        data["creatorName"] = this.creatorName;
        data["creatorImageUri"] = this.creatorImageUri;
        data["creatorJobTypeId"] = this.creatorJobTypeId;
        data["creatorJobTypeName"] = this.creatorJobTypeName;
        data["moduleId"] = this.moduleId;
        data["moduleName"] = this.moduleName;
        data["moduleType"] = this.moduleType;
        return data; 
    }
}

export interface IModuleNps {
    id?: string | undefined;
    score?: number;
    comments?: string | undefined;
    dismissed?: boolean;
    created?: Date;
    creatorId?: string | undefined;
    creatorName?: string | undefined;
    creatorImageUri?: string | undefined;
    creatorJobTypeId?: string | undefined;
    creatorJobTypeName?: string | undefined;
    moduleId?: string | undefined;
    moduleName?: string | undefined;
    moduleType?: string | undefined;
}

export class Nps implements INps {
    id?: string | undefined;
    itemId?: string | undefined;
    score?: number;
    comments?: string | undefined;
    dismissed?: boolean;
    created?: Date;
    creatorId?: string | undefined;
    creatorName?: string | undefined;
    creatorImageUri?: string | undefined;
    creatorJobTypeId?: string | undefined;
    creatorJobTypeName?: string | undefined;

    constructor(data?: INps) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.itemId = _data["itemId"];
            this.score = _data["score"];
            this.comments = _data["comments"];
            this.dismissed = _data["dismissed"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.creatorId = _data["creatorId"];
            this.creatorName = _data["creatorName"];
            this.creatorImageUri = _data["creatorImageUri"];
            this.creatorJobTypeId = _data["creatorJobTypeId"];
            this.creatorJobTypeName = _data["creatorJobTypeName"];
        }
    }

    static fromJS(data: any): Nps {
        data = typeof data === 'object' ? data : {};
        let result = new Nps();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["itemId"] = this.itemId;
        data["score"] = this.score;
        data["comments"] = this.comments;
        data["dismissed"] = this.dismissed;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["creatorId"] = this.creatorId;
        data["creatorName"] = this.creatorName;
        data["creatorImageUri"] = this.creatorImageUri;
        data["creatorJobTypeId"] = this.creatorJobTypeId;
        data["creatorJobTypeName"] = this.creatorJobTypeName;
        return data; 
    }
}

export interface INps {
    id?: string | undefined;
    itemId?: string | undefined;
    score?: number;
    comments?: string | undefined;
    dismissed?: boolean;
    created?: Date;
    creatorId?: string | undefined;
    creatorName?: string | undefined;
    creatorImageUri?: string | undefined;
    creatorJobTypeId?: string | undefined;
    creatorJobTypeName?: string | undefined;
}

export class CreateNpsSettings implements ICreateNpsSettings {
    moduleId!: string;
    comments?: string | undefined;
    score?: number;
    dismissed?: boolean;

    constructor(data?: ICreateNpsSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.moduleId = _data["moduleId"];
            this.comments = _data["comments"];
            this.score = _data["score"];
            this.dismissed = _data["dismissed"];
        }
    }

    static fromJS(data: any): CreateNpsSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateNpsSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["moduleId"] = this.moduleId;
        data["comments"] = this.comments;
        data["score"] = this.score;
        data["dismissed"] = this.dismissed;
        return data; 
    }
}

export interface ICreateNpsSettings {
    moduleId: string;
    comments?: string | undefined;
    score?: number;
    dismissed?: boolean;
}

export class ListOfModuleAttemptOfQuizResult implements IListOfModuleAttemptOfQuizResult {
    totalItemCount!: number;
    items!: ModuleAttemptOfQuizResult[];

    constructor(data?: IListOfModuleAttemptOfQuizResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ModuleAttemptOfQuizResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfModuleAttemptOfQuizResult {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfModuleAttemptOfQuizResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfModuleAttemptOfQuizResult {
    totalItemCount: number;
    items: ModuleAttemptOfQuizResult[];
}

export class ModuleAttemptOfQuizResult extends ModuleAttempt implements IModuleAttemptOfQuizResult {
    result?: QuizResult | undefined;

    constructor(data?: IModuleAttemptOfQuizResult) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.result = _data["result"] ? QuizResult.fromJS(_data["result"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ModuleAttemptOfQuizResult {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleAttemptOfQuizResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IModuleAttemptOfQuizResult extends IModuleAttempt {
    result?: QuizResult | undefined;
}

export class QuizResult implements IQuizResult {
    sections?: QuizSectionResult[] | undefined;
    submitted?: boolean;

    constructor(data?: IQuizResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["sections"])) {
                this.sections = [] as any;
                for (let item of _data["sections"])
                    this.sections!.push(QuizSectionResult.fromJS(item));
            }
            this.submitted = _data["submitted"];
        }
    }

    static fromJS(data: any): QuizResult {
        data = typeof data === 'object' ? data : {};
        let result = new QuizResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.sections)) {
            data["sections"] = [];
            for (let item of this.sections)
                data["sections"].push(item.toJSON());
        }
        data["submitted"] = this.submitted;
        return data; 
    }
}

export interface IQuizResult {
    sections?: QuizSectionResult[] | undefined;
    submitted?: boolean;
}

export class QuizSectionResult implements IQuizSectionResult {
    index?: number;
    questions?: QuizQuestionResult[] | undefined;

    constructor(data?: IQuizSectionResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.index = _data["index"];
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(QuizQuestionResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuizSectionResult {
        data = typeof data === 'object' ? data : {};
        let result = new QuizSectionResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["index"] = this.index;
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IQuizSectionResult {
    index?: number;
    questions?: QuizQuestionResult[] | undefined;
}

export class QuizQuestionResult implements IQuizQuestionResult {
    index?: number;
    answers?: number[] | undefined;

    constructor(data?: IQuizQuestionResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.index = _data["index"];
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(item);
            }
        }
    }

    static fromJS(data: any): QuizQuestionResult {
        data = typeof data === 'object' ? data : {};
        let result = new QuizQuestionResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["index"] = this.index;
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item);
        }
        return data; 
    }
}

export interface IQuizQuestionResult {
    index?: number;
    answers?: number[] | undefined;
}

export class CreateModuleAttemptSettingsOfQuizResult implements ICreateModuleAttemptSettingsOfQuizResult {
    /** Id of the actor of ActorType being assessed */
    actorId!: string;
    moduleContentId!: string;
    result!: QuizResult;

    constructor(data?: ICreateModuleAttemptSettingsOfQuizResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new QuizResult();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.actorId = _data["actorId"];
            this.moduleContentId = _data["moduleContentId"];
            this.result = _data["result"] ? QuizResult.fromJS(_data["result"]) : new QuizResult();
        }
    }

    static fromJS(data: any): CreateModuleAttemptSettingsOfQuizResult {
        data = typeof data === 'object' ? data : {};
        let result = new CreateModuleAttemptSettingsOfQuizResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actorId"] = this.actorId;
        data["moduleContentId"] = this.moduleContentId;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICreateModuleAttemptSettingsOfQuizResult {
    /** Id of the actor of ActorType being assessed */
    actorId: string;
    moduleContentId: string;
    result: QuizResult;
}

export class UpdateModuleAttemptSettingsOfQuizResult implements IUpdateModuleAttemptSettingsOfQuizResult {
    result!: QuizResult;
    version?: number;

    constructor(data?: IUpdateModuleAttemptSettingsOfQuizResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new QuizResult();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? QuizResult.fromJS(_data["result"]) : new QuizResult();
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateModuleAttemptSettingsOfQuizResult {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateModuleAttemptSettingsOfQuizResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["version"] = this.version;
        return data; 
    }
}

export interface IUpdateModuleAttemptSettingsOfQuizResult {
    result: QuizResult;
    version?: number;
}

export class ListOfModuleContentOfQuizSettings implements IListOfModuleContentOfQuizSettings {
    totalItemCount!: number;
    items!: ModuleContentOfQuizSettings[];

    constructor(data?: IListOfModuleContentOfQuizSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ModuleContentOfQuizSettings.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfModuleContentOfQuizSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfModuleContentOfQuizSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfModuleContentOfQuizSettings {
    totalItemCount: number;
    items: ModuleContentOfQuizSettings[];
}

export class ModuleContentOfQuizSettings extends ModuleContent implements IModuleContentOfQuizSettings {
    settings?: QuizSettings | undefined;

    constructor(data?: IModuleContentOfQuizSettings) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.settings = _data["settings"] ? QuizSettings.fromJS(_data["settings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ModuleContentOfQuizSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleContentOfQuizSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IModuleContentOfQuizSettings extends IModuleContent {
    settings?: QuizSettings | undefined;
}

export class QuizSettings implements IQuizSettings {
    sections!: QuizSection[];
    /** The percentage required to pass the module. */
    passScore!: number;
    /** If true, will cause the quiz to keep looping until participant passes all questions. */
    loop?: boolean;

    constructor(data?: IQuizSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.sections = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["sections"])) {
                this.sections = [] as any;
                for (let item of _data["sections"])
                    this.sections!.push(QuizSection.fromJS(item));
            }
            this.passScore = _data["passScore"];
            this.loop = _data["loop"];
        }
    }

    static fromJS(data: any): QuizSettings {
        data = typeof data === 'object' ? data : {};
        let result = new QuizSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.sections)) {
            data["sections"] = [];
            for (let item of this.sections)
                data["sections"].push(item.toJSON());
        }
        data["passScore"] = this.passScore;
        data["loop"] = this.loop;
        return data; 
    }
}

export interface IQuizSettings {
    sections: QuizSection[];
    /** The percentage required to pass the module. */
    passScore: number;
    /** If true, will cause the quiz to keep looping until participant passes all questions. */
    loop?: boolean;
}

export class QuizSection implements IQuizSection {
    title?: string | undefined;
    questions?: QuizQuestion[] | undefined;

    constructor(data?: IQuizSection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(QuizQuestion.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuizSection {
        data = typeof data === 'object' ? data : {};
        let result = new QuizSection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IQuizSection {
    title?: string | undefined;
    questions?: QuizQuestion[] | undefined;
}

export class QuizQuestion implements IQuizQuestion {
    label?: string | undefined;
    body?: string | undefined;
    answers?: QuizAnswer[] | undefined;

    constructor(data?: IQuizQuestion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            this.body = _data["body"];
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(QuizAnswer.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuizQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new QuizQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["body"] = this.body;
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IQuizQuestion {
    label?: string | undefined;
    body?: string | undefined;
    answers?: QuizAnswer[] | undefined;
}

export class QuizAnswer implements IQuizAnswer {
    label?: string | undefined;
    body?: string | undefined;
    correct?: boolean;

    constructor(data?: IQuizAnswer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            this.body = _data["body"];
            this.correct = _data["correct"];
        }
    }

    static fromJS(data: any): QuizAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new QuizAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["body"] = this.body;
        data["correct"] = this.correct;
        return data; 
    }
}

export interface IQuizAnswer {
    label?: string | undefined;
    body?: string | undefined;
    correct?: boolean;
}

export class ModuleContentSettingsOfQuizSettings implements IModuleContentSettingsOfQuizSettings {
    settings!: QuizSettings;
    files?: ModuleContentFileSettings[] | undefined;

    constructor(data?: IModuleContentSettingsOfQuizSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.settings = new QuizSettings();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.settings = _data["settings"] ? QuizSettings.fromJS(_data["settings"]) : new QuizSettings();
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(ModuleContentFileSettings.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ModuleContentSettingsOfQuizSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleContentSettingsOfQuizSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IModuleContentSettingsOfQuizSettings {
    settings: QuizSettings;
    files?: ModuleContentFileSettings[] | undefined;
}

export class CreateModuleContentSettingsOfQuizSettings extends ModuleContentSettingsOfQuizSettings implements ICreateModuleContentSettingsOfQuizSettings {
    published?: boolean;

    constructor(data?: ICreateModuleContentSettingsOfQuizSettings) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.published = _data["published"];
        }
    }

    static fromJS(data: any): CreateModuleContentSettingsOfQuizSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateModuleContentSettingsOfQuizSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["published"] = this.published;
        super.toJSON(data);
        return data; 
    }
}

export interface ICreateModuleContentSettingsOfQuizSettings extends IModuleContentSettingsOfQuizSettings {
    published?: boolean;
}

export class UpdateModuleContentSettingsOfQuizSettings extends ModuleContentSettingsOfQuizSettings implements IUpdateModuleContentSettingsOfQuizSettings {
    version?: number;

    constructor(data?: IUpdateModuleContentSettingsOfQuizSettings) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateModuleContentSettingsOfQuizSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateModuleContentSettingsOfQuizSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        super.toJSON(data);
        return data; 
    }
}

export interface IUpdateModuleContentSettingsOfQuizSettings extends IModuleContentSettingsOfQuizSettings {
    version?: number;
}

export class ListOfModuleAttemptOfRevisionResult implements IListOfModuleAttemptOfRevisionResult {
    totalItemCount!: number;
    items!: ModuleAttemptOfRevisionResult[];

    constructor(data?: IListOfModuleAttemptOfRevisionResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ModuleAttemptOfRevisionResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfModuleAttemptOfRevisionResult {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfModuleAttemptOfRevisionResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfModuleAttemptOfRevisionResult {
    totalItemCount: number;
    items: ModuleAttemptOfRevisionResult[];
}

export class ModuleAttemptOfRevisionResult extends ModuleAttempt implements IModuleAttemptOfRevisionResult {
    result?: RevisionResult | undefined;

    constructor(data?: IModuleAttemptOfRevisionResult) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.result = _data["result"] ? RevisionResult.fromJS(_data["result"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ModuleAttemptOfRevisionResult {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleAttemptOfRevisionResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IModuleAttemptOfRevisionResult extends IModuleAttempt {
    result?: RevisionResult | undefined;
}

export class RevisionResult implements IRevisionResult {
    topics?: RevisionTopicResult[] | undefined;

    constructor(data?: IRevisionResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["topics"])) {
                this.topics = [] as any;
                for (let item of _data["topics"])
                    this.topics!.push(RevisionTopicResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RevisionResult {
        data = typeof data === 'object' ? data : {};
        let result = new RevisionResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.topics)) {
            data["topics"] = [];
            for (let item of this.topics)
                data["topics"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRevisionResult {
    topics?: RevisionTopicResult[] | undefined;
}

export class RevisionTopicResult implements IRevisionTopicResult {
    index?: number;
    attempts?: TopicAttempt[] | undefined;

    constructor(data?: IRevisionTopicResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.index = _data["index"];
            if (Array.isArray(_data["attempts"])) {
                this.attempts = [] as any;
                for (let item of _data["attempts"])
                    this.attempts!.push(TopicAttempt.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RevisionTopicResult {
        data = typeof data === 'object' ? data : {};
        let result = new RevisionTopicResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["index"] = this.index;
        if (Array.isArray(this.attempts)) {
            data["attempts"] = [];
            for (let item of this.attempts)
                data["attempts"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRevisionTopicResult {
    index?: number;
    attempts?: TopicAttempt[] | undefined;
}

export class TopicAttempt implements ITopicAttempt {
    form?: TopicForm;
    correct?: boolean;

    constructor(data?: ITopicAttempt) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.form = _data["form"];
            this.correct = _data["correct"];
        }
    }

    static fromJS(data: any): TopicAttempt {
        data = typeof data === 'object' ? data : {};
        let result = new TopicAttempt();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["form"] = this.form;
        data["correct"] = this.correct;
        return data; 
    }
}

export interface ITopicAttempt {
    form?: TopicForm;
    correct?: boolean;
}

/** 0 = Flipcard 1 = TrueOrFalse 2 = MultipleChoices */
export enum TopicForm {
    Flipcard = 0,
    TrueOrFalse = 1,
    MultipleChoices = 2,
}

export class CreateModuleAttemptSettingsOfRevisionResult implements ICreateModuleAttemptSettingsOfRevisionResult {
    /** Id of the actor of ActorType being assessed */
    actorId!: string;
    moduleContentId!: string;
    result!: RevisionResult;

    constructor(data?: ICreateModuleAttemptSettingsOfRevisionResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new RevisionResult();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.actorId = _data["actorId"];
            this.moduleContentId = _data["moduleContentId"];
            this.result = _data["result"] ? RevisionResult.fromJS(_data["result"]) : new RevisionResult();
        }
    }

    static fromJS(data: any): CreateModuleAttemptSettingsOfRevisionResult {
        data = typeof data === 'object' ? data : {};
        let result = new CreateModuleAttemptSettingsOfRevisionResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actorId"] = this.actorId;
        data["moduleContentId"] = this.moduleContentId;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICreateModuleAttemptSettingsOfRevisionResult {
    /** Id of the actor of ActorType being assessed */
    actorId: string;
    moduleContentId: string;
    result: RevisionResult;
}

export class UpdateModuleAttemptSettingsOfRevisionResult implements IUpdateModuleAttemptSettingsOfRevisionResult {
    result!: RevisionResult;
    version?: number;

    constructor(data?: IUpdateModuleAttemptSettingsOfRevisionResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new RevisionResult();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? RevisionResult.fromJS(_data["result"]) : new RevisionResult();
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateModuleAttemptSettingsOfRevisionResult {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateModuleAttemptSettingsOfRevisionResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["version"] = this.version;
        return data; 
    }
}

export interface IUpdateModuleAttemptSettingsOfRevisionResult {
    result: RevisionResult;
    version?: number;
}

export class ListOfModuleContentOfRevisionSettings implements IListOfModuleContentOfRevisionSettings {
    totalItemCount!: number;
    items!: ModuleContentOfRevisionSettings[];

    constructor(data?: IListOfModuleContentOfRevisionSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ModuleContentOfRevisionSettings.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfModuleContentOfRevisionSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfModuleContentOfRevisionSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfModuleContentOfRevisionSettings {
    totalItemCount: number;
    items: ModuleContentOfRevisionSettings[];
}

export class ModuleContentOfRevisionSettings extends ModuleContent implements IModuleContentOfRevisionSettings {
    settings?: RevisionSettings | undefined;

    constructor(data?: IModuleContentOfRevisionSettings) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.settings = _data["settings"] ? RevisionSettings.fromJS(_data["settings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ModuleContentOfRevisionSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleContentOfRevisionSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IModuleContentOfRevisionSettings extends IModuleContent {
    settings?: RevisionSettings | undefined;
}

export class RevisionSettings implements IRevisionSettings {
    topics!: Topic[];
    /** The percentage required to pass the module. */
    passScore!: number;

    constructor(data?: IRevisionSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.topics = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["topics"])) {
                this.topics = [] as any;
                for (let item of _data["topics"])
                    this.topics!.push(Topic.fromJS(item));
            }
            this.passScore = _data["passScore"];
        }
    }

    static fromJS(data: any): RevisionSettings {
        data = typeof data === 'object' ? data : {};
        let result = new RevisionSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.topics)) {
            data["topics"] = [];
            for (let item of this.topics)
                data["topics"].push(item.toJSON());
        }
        data["passScore"] = this.passScore;
        return data; 
    }
}

export interface IRevisionSettings {
    topics: Topic[];
    /** The percentage required to pass the module. */
    passScore: number;
}

export class Topic implements ITopic {
    term!: string;
    definition!: string;
    hint?: string | undefined;

    constructor(data?: ITopic) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.term = _data["term"];
            this.definition = _data["definition"];
            this.hint = _data["hint"];
        }
    }

    static fromJS(data: any): Topic {
        data = typeof data === 'object' ? data : {};
        let result = new Topic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["term"] = this.term;
        data["definition"] = this.definition;
        data["hint"] = this.hint;
        return data; 
    }
}

export interface ITopic {
    term: string;
    definition: string;
    hint?: string | undefined;
}

export class ModuleContentSettingsOfRevisionSettings implements IModuleContentSettingsOfRevisionSettings {
    settings!: RevisionSettings;
    files?: ModuleContentFileSettings[] | undefined;

    constructor(data?: IModuleContentSettingsOfRevisionSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.settings = new RevisionSettings();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.settings = _data["settings"] ? RevisionSettings.fromJS(_data["settings"]) : new RevisionSettings();
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(ModuleContentFileSettings.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ModuleContentSettingsOfRevisionSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleContentSettingsOfRevisionSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IModuleContentSettingsOfRevisionSettings {
    settings: RevisionSettings;
    files?: ModuleContentFileSettings[] | undefined;
}

export class CreateModuleContentSettingsOfRevisionSettings extends ModuleContentSettingsOfRevisionSettings implements ICreateModuleContentSettingsOfRevisionSettings {
    published?: boolean;

    constructor(data?: ICreateModuleContentSettingsOfRevisionSettings) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.published = _data["published"];
        }
    }

    static fromJS(data: any): CreateModuleContentSettingsOfRevisionSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateModuleContentSettingsOfRevisionSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["published"] = this.published;
        super.toJSON(data);
        return data; 
    }
}

export interface ICreateModuleContentSettingsOfRevisionSettings extends IModuleContentSettingsOfRevisionSettings {
    published?: boolean;
}

export class UpdateModuleContentSettingsOfRevisionSettings extends ModuleContentSettingsOfRevisionSettings implements IUpdateModuleContentSettingsOfRevisionSettings {
    version?: number;

    constructor(data?: IUpdateModuleContentSettingsOfRevisionSettings) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateModuleContentSettingsOfRevisionSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateModuleContentSettingsOfRevisionSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        super.toJSON(data);
        return data; 
    }
}

export interface IUpdateModuleContentSettingsOfRevisionSettings extends IModuleContentSettingsOfRevisionSettings {
    version?: number;
}

export class ListOfTrainingSession implements IListOfTrainingSession {
    totalItemCount!: number;
    items!: TrainingSession[];

    constructor(data?: IListOfTrainingSession) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TrainingSession.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfTrainingSession {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfTrainingSession();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfTrainingSession {
    totalItemCount: number;
    items: TrainingSession[];
}

export class TrainingSession implements ITrainingSession {
    id?: string | undefined;
    groupId?: string | undefined;
    groupName?: string | undefined;
    organisationId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    location?: Location;
    modules?: ModuleInTrainingSession[] | undefined;
    start?: Date | undefined;
    end?: Date | undefined;
    status?: TrainingSessionStatus;
    version?: number;

    constructor(data?: ITrainingSession) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.groupId = _data["groupId"];
            this.groupName = _data["groupName"];
            this.organisationId = _data["organisationId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.location = _data["location"] ? Location.fromJS(_data["location"]) : <any>undefined;
            if (Array.isArray(_data["modules"])) {
                this.modules = [] as any;
                for (let item of _data["modules"])
                    this.modules!.push(ModuleInTrainingSession.fromJS(item));
            }
            this.start = _data["start"] ? new Date(_data["start"].toString()) : <any>undefined;
            this.end = _data["end"] ? new Date(_data["end"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): TrainingSession {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingSession();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["groupId"] = this.groupId;
        data["groupName"] = this.groupName;
        data["organisationId"] = this.organisationId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        if (Array.isArray(this.modules)) {
            data["modules"] = [];
            for (let item of this.modules)
                data["modules"].push(item.toJSON());
        }
        data["start"] = this.start ? this.start.toISOString() : <any>undefined;
        data["end"] = this.end ? this.end.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["version"] = this.version;
        return data; 
    }
}

export interface ITrainingSession {
    id?: string | undefined;
    groupId?: string | undefined;
    groupName?: string | undefined;
    organisationId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    location?: Location;
    modules?: ModuleInTrainingSession[] | undefined;
    start?: Date | undefined;
    end?: Date | undefined;
    status?: TrainingSessionStatus;
    version?: number;
}

export class ModuleInTrainingSession implements IModuleInTrainingSession {
    id?: string | undefined;
    name?: string | undefined;
    type?: string | undefined;

    constructor(data?: IModuleInTrainingSession) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ModuleInTrainingSession {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleInTrainingSession();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["type"] = this.type;
        return data; 
    }
}

export interface IModuleInTrainingSession {
    id?: string | undefined;
    name?: string | undefined;
    type?: string | undefined;
}

/** 0 = None 1 = NotStarted 2 = Started 3 = Complete */
export enum TrainingSessionStatus {
    None = 0,
    NotStarted = 1,
    Started = 2,
    Complete = 3,
}

export class CreateTrainingSessionSettings implements ICreateTrainingSessionSettings {
    /** The organisation or team id of the training session */
    groupId!: string;
    name!: string;
    description?: string | undefined;
    start?: Date | undefined;
    end?: Date | undefined;
    location?: LocationBuilder | undefined;
    modules?: TrainingSessionModule[] | undefined;

    constructor(data?: ICreateTrainingSessionSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupId = _data["groupId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.start = _data["start"] ? new Date(_data["start"].toString()) : <any>undefined;
            this.end = _data["end"] ? new Date(_data["end"].toString()) : <any>undefined;
            this.location = _data["location"] ? LocationBuilder.fromJS(_data["location"]) : <any>undefined;
            if (Array.isArray(_data["modules"])) {
                this.modules = [] as any;
                for (let item of _data["modules"])
                    this.modules!.push(TrainingSessionModule.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateTrainingSessionSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTrainingSessionSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["start"] = this.start ? this.start.toISOString() : <any>undefined;
        data["end"] = this.end ? this.end.toISOString() : <any>undefined;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        if (Array.isArray(this.modules)) {
            data["modules"] = [];
            for (let item of this.modules)
                data["modules"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateTrainingSessionSettings {
    /** The organisation or team id of the training session */
    groupId: string;
    name: string;
    description?: string | undefined;
    start?: Date | undefined;
    end?: Date | undefined;
    location?: LocationBuilder | undefined;
    modules?: TrainingSessionModule[] | undefined;
}

export class TrainingSessionModule implements ITrainingSessionModule {
    id?: string | undefined;

    constructor(data?: ITrainingSessionModule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TrainingSessionModule {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingSessionModule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ITrainingSessionModule {
    id?: string | undefined;
}

export class UpdateTrainingSessionSettings implements IUpdateTrainingSessionSettings {
    name!: string;
    description?: string | undefined;
    start?: Date | undefined;
    end?: Date | undefined;
    location?: LocationBuilder | undefined;
    modules?: TrainingSessionModule[] | undefined;
    status?: TrainingSessionStatus;
    version?: number;

    constructor(data?: IUpdateTrainingSessionSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.start = _data["start"] ? new Date(_data["start"].toString()) : <any>undefined;
            this.end = _data["end"] ? new Date(_data["end"].toString()) : <any>undefined;
            this.location = _data["location"] ? LocationBuilder.fromJS(_data["location"]) : <any>undefined;
            if (Array.isArray(_data["modules"])) {
                this.modules = [] as any;
                for (let item of _data["modules"])
                    this.modules!.push(TrainingSessionModule.fromJS(item));
            }
            this.status = _data["status"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateTrainingSessionSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTrainingSessionSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["start"] = this.start ? this.start.toISOString() : <any>undefined;
        data["end"] = this.end ? this.end.toISOString() : <any>undefined;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        if (Array.isArray(this.modules)) {
            data["modules"] = [];
            for (let item of this.modules)
                data["modules"].push(item.toJSON());
        }
        data["status"] = this.status;
        data["version"] = this.version;
        return data; 
    }
}

export interface IUpdateTrainingSessionSettings {
    name: string;
    description?: string | undefined;
    start?: Date | undefined;
    end?: Date | undefined;
    location?: LocationBuilder | undefined;
    modules?: TrainingSessionModule[] | undefined;
    status?: TrainingSessionStatus;
    version?: number;
}

export class ListOfModuleAttemptOfVideoResult implements IListOfModuleAttemptOfVideoResult {
    totalItemCount!: number;
    items!: ModuleAttemptOfVideoResult[];

    constructor(data?: IListOfModuleAttemptOfVideoResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ModuleAttemptOfVideoResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfModuleAttemptOfVideoResult {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfModuleAttemptOfVideoResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfModuleAttemptOfVideoResult {
    totalItemCount: number;
    items: ModuleAttemptOfVideoResult[];
}

export class ModuleAttemptOfVideoResult extends ModuleAttempt implements IModuleAttemptOfVideoResult {
    result?: VideoResult | undefined;

    constructor(data?: IModuleAttemptOfVideoResult) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.result = _data["result"] ? VideoResult.fromJS(_data["result"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ModuleAttemptOfVideoResult {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleAttemptOfVideoResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IModuleAttemptOfVideoResult extends IModuleAttempt {
    result?: VideoResult | undefined;
}

export class VideoResult implements IVideoResult {
    position?: string;
    maxPosition?: string;
    duration?: string;

    constructor(data?: IVideoResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.position = _data["position"];
            this.maxPosition = _data["maxPosition"];
            this.duration = _data["duration"];
        }
    }

    static fromJS(data: any): VideoResult {
        data = typeof data === 'object' ? data : {};
        let result = new VideoResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["position"] = this.position;
        data["maxPosition"] = this.maxPosition;
        data["duration"] = this.duration;
        return data; 
    }
}

export interface IVideoResult {
    position?: string;
    maxPosition?: string;
    duration?: string;
}

export class CreateModuleAttemptSettingsOfVideoResult implements ICreateModuleAttemptSettingsOfVideoResult {
    /** Id of the actor of ActorType being assessed */
    actorId!: string;
    moduleContentId!: string;
    result!: VideoResult;

    constructor(data?: ICreateModuleAttemptSettingsOfVideoResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new VideoResult();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.actorId = _data["actorId"];
            this.moduleContentId = _data["moduleContentId"];
            this.result = _data["result"] ? VideoResult.fromJS(_data["result"]) : new VideoResult();
        }
    }

    static fromJS(data: any): CreateModuleAttemptSettingsOfVideoResult {
        data = typeof data === 'object' ? data : {};
        let result = new CreateModuleAttemptSettingsOfVideoResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actorId"] = this.actorId;
        data["moduleContentId"] = this.moduleContentId;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICreateModuleAttemptSettingsOfVideoResult {
    /** Id of the actor of ActorType being assessed */
    actorId: string;
    moduleContentId: string;
    result: VideoResult;
}

export class UpdateModuleAttemptSettingsOfVideoResult implements IUpdateModuleAttemptSettingsOfVideoResult {
    result!: VideoResult;
    version?: number;

    constructor(data?: IUpdateModuleAttemptSettingsOfVideoResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new VideoResult();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? VideoResult.fromJS(_data["result"]) : new VideoResult();
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateModuleAttemptSettingsOfVideoResult {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateModuleAttemptSettingsOfVideoResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["version"] = this.version;
        return data; 
    }
}

export interface IUpdateModuleAttemptSettingsOfVideoResult {
    result: VideoResult;
    version?: number;
}

export class ListOfModuleContentOfVideoSettings implements IListOfModuleContentOfVideoSettings {
    totalItemCount!: number;
    items!: ModuleContentOfVideoSettings[];

    constructor(data?: IListOfModuleContentOfVideoSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ModuleContentOfVideoSettings.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfModuleContentOfVideoSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfModuleContentOfVideoSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfModuleContentOfVideoSettings {
    totalItemCount: number;
    items: ModuleContentOfVideoSettings[];
}

export class ModuleContentOfVideoSettings extends ModuleContent implements IModuleContentOfVideoSettings {
    settings?: VideoSettings | undefined;

    constructor(data?: IModuleContentOfVideoSettings) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.settings = _data["settings"] ? VideoSettings.fromJS(_data["settings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ModuleContentOfVideoSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleContentOfVideoSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IModuleContentOfVideoSettings extends IModuleContent {
    settings?: VideoSettings | undefined;
}

export class VideoSettings implements IVideoSettings {
    type!: VideoType;
    /** A URI for the video. */
    source!: string;
    /** The duration of the video */
    duration?: string;

    constructor(data?: IVideoSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.source = _data["source"];
            this.duration = _data["duration"];
        }
    }

    static fromJS(data: any): VideoSettings {
        data = typeof data === 'object' ? data : {};
        let result = new VideoSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["source"] = this.source;
        data["duration"] = this.duration;
        return data; 
    }
}

export interface IVideoSettings {
    type: VideoType;
    /** A URI for the video. */
    source: string;
    /** The duration of the video */
    duration?: string;
}

/** 0 = None 1 = Vimeo 2 = Youtube 3 = Azure 4 = Wistia */
export enum VideoType {
    None = 0,
    Vimeo = 1,
    Youtube = 2,
    Azure = 3,
    Wistia = 4,
}

export class ModuleContentSettingsOfVideoSettings implements IModuleContentSettingsOfVideoSettings {
    settings!: VideoSettings;
    files?: ModuleContentFileSettings[] | undefined;

    constructor(data?: IModuleContentSettingsOfVideoSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.settings = new VideoSettings();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.settings = _data["settings"] ? VideoSettings.fromJS(_data["settings"]) : new VideoSettings();
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(ModuleContentFileSettings.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ModuleContentSettingsOfVideoSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleContentSettingsOfVideoSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IModuleContentSettingsOfVideoSettings {
    settings: VideoSettings;
    files?: ModuleContentFileSettings[] | undefined;
}

export class CreateModuleContentSettingsOfVideoSettings extends ModuleContentSettingsOfVideoSettings implements ICreateModuleContentSettingsOfVideoSettings {
    published?: boolean;

    constructor(data?: ICreateModuleContentSettingsOfVideoSettings) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.published = _data["published"];
        }
    }

    static fromJS(data: any): CreateModuleContentSettingsOfVideoSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateModuleContentSettingsOfVideoSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["published"] = this.published;
        super.toJSON(data);
        return data; 
    }
}

export interface ICreateModuleContentSettingsOfVideoSettings extends IModuleContentSettingsOfVideoSettings {
    published?: boolean;
}

export class UpdateModuleContentSettingsOfVideoSettings extends ModuleContentSettingsOfVideoSettings implements IUpdateModuleContentSettingsOfVideoSettings {
    version?: number;

    constructor(data?: IUpdateModuleContentSettingsOfVideoSettings) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateModuleContentSettingsOfVideoSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateModuleContentSettingsOfVideoSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        super.toJSON(data);
        return data; 
    }
}

export interface IUpdateModuleContentSettingsOfVideoSettings extends IModuleContentSettingsOfVideoSettings {
    version?: number;
}

export class ListOfModuleAttemptOfAssessmentResult implements IListOfModuleAttemptOfAssessmentResult {
    totalItemCount!: number;
    items!: ModuleAttemptOfAssessmentResult[];

    constructor(data?: IListOfModuleAttemptOfAssessmentResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ModuleAttemptOfAssessmentResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfModuleAttemptOfAssessmentResult {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfModuleAttemptOfAssessmentResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfModuleAttemptOfAssessmentResult {
    totalItemCount: number;
    items: ModuleAttemptOfAssessmentResult[];
}

export class ModuleAttemptOfAssessmentResult extends ModuleAttempt implements IModuleAttemptOfAssessmentResult {
    result?: AssessmentResult | undefined;

    constructor(data?: IModuleAttemptOfAssessmentResult) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.result = _data["result"] ? AssessmentResult.fromJS(_data["result"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ModuleAttemptOfAssessmentResult {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleAttemptOfAssessmentResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IModuleAttemptOfAssessmentResult extends IModuleAttempt {
    result?: AssessmentResult | undefined;
}

export class AssessmentResult implements IAssessmentResult {
    attempts?: AssessmentAttempt[] | undefined;

    constructor(data?: IAssessmentResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["attempts"])) {
                this.attempts = [] as any;
                for (let item of _data["attempts"])
                    this.attempts!.push(AssessmentAttempt.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AssessmentResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssessmentResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.attempts)) {
            data["attempts"] = [];
            for (let item of this.attempts)
                data["attempts"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAssessmentResult {
    attempts?: AssessmentAttempt[] | undefined;
}

export class AssessmentAttempt implements IAssessmentAttempt {
    id?: string | undefined;
    assessorId?: string | undefined;
    sections?: AssessmentSectionResult[] | undefined;
    performed?: Date;
    notes?: string | undefined;

    constructor(data?: IAssessmentAttempt) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.assessorId = _data["assessorId"];
            if (Array.isArray(_data["sections"])) {
                this.sections = [] as any;
                for (let item of _data["sections"])
                    this.sections!.push(AssessmentSectionResult.fromJS(item));
            }
            this.performed = _data["performed"] ? new Date(_data["performed"].toString()) : <any>undefined;
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): AssessmentAttempt {
        data = typeof data === 'object' ? data : {};
        let result = new AssessmentAttempt();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["assessorId"] = this.assessorId;
        if (Array.isArray(this.sections)) {
            data["sections"] = [];
            for (let item of this.sections)
                data["sections"].push(item.toJSON());
        }
        data["performed"] = this.performed ? this.performed.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        return data; 
    }
}

export interface IAssessmentAttempt {
    id?: string | undefined;
    assessorId?: string | undefined;
    sections?: AssessmentSectionResult[] | undefined;
    performed?: Date;
    notes?: string | undefined;
}

export class AssessmentSectionResult implements IAssessmentSectionResult {
    index?: number;
    selectedCriteria?: number[] | undefined;

    constructor(data?: IAssessmentSectionResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.index = _data["index"];
            if (Array.isArray(_data["selectedCriteria"])) {
                this.selectedCriteria = [] as any;
                for (let item of _data["selectedCriteria"])
                    this.selectedCriteria!.push(item);
            }
        }
    }

    static fromJS(data: any): AssessmentSectionResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssessmentSectionResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["index"] = this.index;
        if (Array.isArray(this.selectedCriteria)) {
            data["selectedCriteria"] = [];
            for (let item of this.selectedCriteria)
                data["selectedCriteria"].push(item);
        }
        return data; 
    }
}

export interface IAssessmentSectionResult {
    index?: number;
    selectedCriteria?: number[] | undefined;
}

export class CreateModuleAttemptSettingsOfAssessmentResult implements ICreateModuleAttemptSettingsOfAssessmentResult {
    /** Id of the actor of ActorType being assessed */
    actorId!: string;
    moduleContentId!: string;
    result!: AssessmentResult;

    constructor(data?: ICreateModuleAttemptSettingsOfAssessmentResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new AssessmentResult();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.actorId = _data["actorId"];
            this.moduleContentId = _data["moduleContentId"];
            this.result = _data["result"] ? AssessmentResult.fromJS(_data["result"]) : new AssessmentResult();
        }
    }

    static fromJS(data: any): CreateModuleAttemptSettingsOfAssessmentResult {
        data = typeof data === 'object' ? data : {};
        let result = new CreateModuleAttemptSettingsOfAssessmentResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actorId"] = this.actorId;
        data["moduleContentId"] = this.moduleContentId;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICreateModuleAttemptSettingsOfAssessmentResult {
    /** Id of the actor of ActorType being assessed */
    actorId: string;
    moduleContentId: string;
    result: AssessmentResult;
}

export class UpdateModuleAttemptSettingsOfAssessmentResult implements IUpdateModuleAttemptSettingsOfAssessmentResult {
    result!: AssessmentResult;
    version?: number;

    constructor(data?: IUpdateModuleAttemptSettingsOfAssessmentResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new AssessmentResult();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? AssessmentResult.fromJS(_data["result"]) : new AssessmentResult();
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateModuleAttemptSettingsOfAssessmentResult {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateModuleAttemptSettingsOfAssessmentResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["version"] = this.version;
        return data; 
    }
}

export interface IUpdateModuleAttemptSettingsOfAssessmentResult {
    result: AssessmentResult;
    version?: number;
}

export class ListOfModuleContentOfAssessmentSettings implements IListOfModuleContentOfAssessmentSettings {
    totalItemCount!: number;
    items!: ModuleContentOfAssessmentSettings[];

    constructor(data?: IListOfModuleContentOfAssessmentSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ModuleContentOfAssessmentSettings.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfModuleContentOfAssessmentSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfModuleContentOfAssessmentSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfModuleContentOfAssessmentSettings {
    totalItemCount: number;
    items: ModuleContentOfAssessmentSettings[];
}

export class ModuleContentOfAssessmentSettings extends ModuleContent implements IModuleContentOfAssessmentSettings {
    settings?: AssessmentSettings | undefined;

    constructor(data?: IModuleContentOfAssessmentSettings) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.settings = _data["settings"] ? AssessmentSettings.fromJS(_data["settings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ModuleContentOfAssessmentSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleContentOfAssessmentSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IModuleContentOfAssessmentSettings extends IModuleContent {
    settings?: AssessmentSettings | undefined;
}

export class AssessmentSettings implements IAssessmentSettings {
    /** The number of times the assessment must be passed for the module to be considered passed. */
    requiredPasses!: number;
    /** The number of times the assessment must be passed, after the initial pass, for the module to be considered passed. */
    subsequentRequiredPasses?: number | undefined;
    /** The percentage required to pass the assessment. */
    passScore!: number;
    sections!: AssessmentSection[];

    constructor(data?: IAssessmentSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.sections = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requiredPasses = _data["requiredPasses"];
            this.subsequentRequiredPasses = _data["subsequentRequiredPasses"];
            this.passScore = _data["passScore"];
            if (Array.isArray(_data["sections"])) {
                this.sections = [] as any;
                for (let item of _data["sections"])
                    this.sections!.push(AssessmentSection.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AssessmentSettings {
        data = typeof data === 'object' ? data : {};
        let result = new AssessmentSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requiredPasses"] = this.requiredPasses;
        data["subsequentRequiredPasses"] = this.subsequentRequiredPasses;
        data["passScore"] = this.passScore;
        if (Array.isArray(this.sections)) {
            data["sections"] = [];
            for (let item of this.sections)
                data["sections"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAssessmentSettings {
    /** The number of times the assessment must be passed for the module to be considered passed. */
    requiredPasses: number;
    /** The number of times the assessment must be passed, after the initial pass, for the module to be considered passed. */
    subsequentRequiredPasses?: number | undefined;
    /** The percentage required to pass the assessment. */
    passScore: number;
    sections: AssessmentSection[];
}

export class AssessmentSection implements IAssessmentSection {
    title?: string | undefined;
    criteria!: Criterion[];

    constructor(data?: IAssessmentSection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.criteria = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            if (Array.isArray(_data["criteria"])) {
                this.criteria = [] as any;
                for (let item of _data["criteria"])
                    this.criteria!.push(Criterion.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AssessmentSection {
        data = typeof data === 'object' ? data : {};
        let result = new AssessmentSection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        if (Array.isArray(this.criteria)) {
            data["criteria"] = [];
            for (let item of this.criteria)
                data["criteria"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAssessmentSection {
    title?: string | undefined;
    criteria: Criterion[];
}

export class Criterion implements ICriterion {
    body!: string;

    constructor(data?: ICriterion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.body = _data["body"];
        }
    }

    static fromJS(data: any): Criterion {
        data = typeof data === 'object' ? data : {};
        let result = new Criterion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["body"] = this.body;
        return data; 
    }
}

export interface ICriterion {
    body: string;
}

export class ModuleContentSettingsOfAssessmentSettings implements IModuleContentSettingsOfAssessmentSettings {
    settings!: AssessmentSettings;
    files?: ModuleContentFileSettings[] | undefined;

    constructor(data?: IModuleContentSettingsOfAssessmentSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.settings = new AssessmentSettings();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.settings = _data["settings"] ? AssessmentSettings.fromJS(_data["settings"]) : new AssessmentSettings();
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(ModuleContentFileSettings.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ModuleContentSettingsOfAssessmentSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleContentSettingsOfAssessmentSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IModuleContentSettingsOfAssessmentSettings {
    settings: AssessmentSettings;
    files?: ModuleContentFileSettings[] | undefined;
}

export class CreateModuleContentSettingsOfAssessmentSettings extends ModuleContentSettingsOfAssessmentSettings implements ICreateModuleContentSettingsOfAssessmentSettings {
    published?: boolean;

    constructor(data?: ICreateModuleContentSettingsOfAssessmentSettings) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.published = _data["published"];
        }
    }

    static fromJS(data: any): CreateModuleContentSettingsOfAssessmentSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateModuleContentSettingsOfAssessmentSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["published"] = this.published;
        super.toJSON(data);
        return data; 
    }
}

export interface ICreateModuleContentSettingsOfAssessmentSettings extends IModuleContentSettingsOfAssessmentSettings {
    published?: boolean;
}

export class UpdateModuleContentSettingsOfAssessmentSettings extends ModuleContentSettingsOfAssessmentSettings implements IUpdateModuleContentSettingsOfAssessmentSettings {
    version?: number;

    constructor(data?: IUpdateModuleContentSettingsOfAssessmentSettings) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateModuleContentSettingsOfAssessmentSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateModuleContentSettingsOfAssessmentSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        super.toJSON(data);
        return data; 
    }
}

export interface IUpdateModuleContentSettingsOfAssessmentSettings extends IModuleContentSettingsOfAssessmentSettings {
    version?: number;
}

export class ListOfAssessmentSubAttempt implements IListOfAssessmentSubAttempt {
    totalItemCount!: number;
    items!: AssessmentSubAttempt[];

    constructor(data?: IListOfAssessmentSubAttempt) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AssessmentSubAttempt.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfAssessmentSubAttempt {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfAssessmentSubAttempt();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfAssessmentSubAttempt {
    totalItemCount: number;
    items: AssessmentSubAttempt[];
}

export class AssessmentSubAttempt implements IAssessmentSubAttempt {
    id?: string | undefined;
    attemptId?: string | undefined;
    actorId?: string | undefined;
    actorName?: string | undefined;
    actorType?: ActorType;
    assessorId?: string | undefined;
    assessorName?: string | undefined;
    sections?: AssessmentSectionResult[] | undefined;
    created?: Date;
    modified?: Date;
    performed?: Date;
    notes?: string | undefined;
    assessmentId?: string | undefined;
    assessmentName?: string | undefined;
    assessmentContentId?: string | undefined;
    passScore?: number;
    score?: number;
    passed?: boolean;
    publisherId?: string | undefined;
    classIds?: string[] | undefined;
    trainingSessionId?: string | undefined;
    trainingSessionModuleAttemptId?: string | undefined;

    constructor(data?: IAssessmentSubAttempt) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.attemptId = _data["attemptId"];
            this.actorId = _data["actorId"];
            this.actorName = _data["actorName"];
            this.actorType = _data["actorType"];
            this.assessorId = _data["assessorId"];
            this.assessorName = _data["assessorName"];
            if (Array.isArray(_data["sections"])) {
                this.sections = [] as any;
                for (let item of _data["sections"])
                    this.sections!.push(AssessmentSectionResult.fromJS(item));
            }
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
            this.performed = _data["performed"] ? new Date(_data["performed"].toString()) : <any>undefined;
            this.notes = _data["notes"];
            this.assessmentId = _data["assessmentId"];
            this.assessmentName = _data["assessmentName"];
            this.assessmentContentId = _data["assessmentContentId"];
            this.passScore = _data["passScore"];
            this.score = _data["score"];
            this.passed = _data["passed"];
            this.publisherId = _data["publisherId"];
            if (Array.isArray(_data["classIds"])) {
                this.classIds = [] as any;
                for (let item of _data["classIds"])
                    this.classIds!.push(item);
            }
            this.trainingSessionId = _data["trainingSessionId"];
            this.trainingSessionModuleAttemptId = _data["trainingSessionModuleAttemptId"];
        }
    }

    static fromJS(data: any): AssessmentSubAttempt {
        data = typeof data === 'object' ? data : {};
        let result = new AssessmentSubAttempt();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["attemptId"] = this.attemptId;
        data["actorId"] = this.actorId;
        data["actorName"] = this.actorName;
        data["actorType"] = this.actorType;
        data["assessorId"] = this.assessorId;
        data["assessorName"] = this.assessorName;
        if (Array.isArray(this.sections)) {
            data["sections"] = [];
            for (let item of this.sections)
                data["sections"].push(item.toJSON());
        }
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        data["performed"] = this.performed ? this.performed.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        data["assessmentId"] = this.assessmentId;
        data["assessmentName"] = this.assessmentName;
        data["assessmentContentId"] = this.assessmentContentId;
        data["passScore"] = this.passScore;
        data["score"] = this.score;
        data["passed"] = this.passed;
        data["publisherId"] = this.publisherId;
        if (Array.isArray(this.classIds)) {
            data["classIds"] = [];
            for (let item of this.classIds)
                data["classIds"].push(item);
        }
        data["trainingSessionId"] = this.trainingSessionId;
        data["trainingSessionModuleAttemptId"] = this.trainingSessionModuleAttemptId;
        return data; 
    }
}

export interface IAssessmentSubAttempt {
    id?: string | undefined;
    attemptId?: string | undefined;
    actorId?: string | undefined;
    actorName?: string | undefined;
    actorType?: ActorType;
    assessorId?: string | undefined;
    assessorName?: string | undefined;
    sections?: AssessmentSectionResult[] | undefined;
    created?: Date;
    modified?: Date;
    performed?: Date;
    notes?: string | undefined;
    assessmentId?: string | undefined;
    assessmentName?: string | undefined;
    assessmentContentId?: string | undefined;
    passScore?: number;
    score?: number;
    passed?: boolean;
    publisherId?: string | undefined;
    classIds?: string[] | undefined;
    trainingSessionId?: string | undefined;
    trainingSessionModuleAttemptId?: string | undefined;
}

export class CreateAssessmentSubAttemptSettings implements ICreateAssessmentSubAttemptSettings {
    /** Id of the actor of ActorType being assessed */
    actorId!: string;
    assessorId!: string;
    moduleId!: string;
    moduleContentId!: string;
    sections!: AssessmentSectionResult[];
    performed!: Date;
    notes?: string | undefined;

    constructor(data?: ICreateAssessmentSubAttemptSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.sections = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.actorId = _data["actorId"];
            this.assessorId = _data["assessorId"];
            this.moduleId = _data["moduleId"];
            this.moduleContentId = _data["moduleContentId"];
            if (Array.isArray(_data["sections"])) {
                this.sections = [] as any;
                for (let item of _data["sections"])
                    this.sections!.push(AssessmentSectionResult.fromJS(item));
            }
            this.performed = _data["performed"] ? new Date(_data["performed"].toString()) : <any>undefined;
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): CreateAssessmentSubAttemptSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAssessmentSubAttemptSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actorId"] = this.actorId;
        data["assessorId"] = this.assessorId;
        data["moduleId"] = this.moduleId;
        data["moduleContentId"] = this.moduleContentId;
        if (Array.isArray(this.sections)) {
            data["sections"] = [];
            for (let item of this.sections)
                data["sections"].push(item.toJSON());
        }
        data["performed"] = this.performed ? this.performed.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        return data; 
    }
}

export interface ICreateAssessmentSubAttemptSettings {
    /** Id of the actor of ActorType being assessed */
    actorId: string;
    assessorId: string;
    moduleId: string;
    moduleContentId: string;
    sections: AssessmentSectionResult[];
    performed: Date;
    notes?: string | undefined;
}

export class UpdateAssessmentSubAttemptSettings implements IUpdateAssessmentSubAttemptSettings {
    assessorId!: string;
    sections!: AssessmentSectionResult[];
    performed!: Date;
    notes?: string | undefined;
    version?: number;

    constructor(data?: IUpdateAssessmentSubAttemptSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.sections = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.assessorId = _data["assessorId"];
            if (Array.isArray(_data["sections"])) {
                this.sections = [] as any;
                for (let item of _data["sections"])
                    this.sections!.push(AssessmentSectionResult.fromJS(item));
            }
            this.performed = _data["performed"] ? new Date(_data["performed"].toString()) : <any>undefined;
            this.notes = _data["notes"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateAssessmentSubAttemptSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAssessmentSubAttemptSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assessorId"] = this.assessorId;
        if (Array.isArray(this.sections)) {
            data["sections"] = [];
            for (let item of this.sections)
                data["sections"].push(item.toJSON());
        }
        data["performed"] = this.performed ? this.performed.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        data["version"] = this.version;
        return data; 
    }
}

export interface IUpdateAssessmentSubAttemptSettings {
    assessorId: string;
    sections: AssessmentSectionResult[];
    performed: Date;
    notes?: string | undefined;
    version?: number;
}

export class AuthenticationSettings implements IAuthenticationSettings {
    method?: AuthenticationMethod;
    email!: string;
    /** This will be the password if using password to login, or the one-time passcode if using one-time passcode
to login. */
    password?: string | undefined;
    /** Optional 2FA code. */
    twoFactorAuthenticationCode?: string | undefined;

    constructor(data?: IAuthenticationSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.method = AuthenticationMethod.Password;
            this.password = "";
        }
    }

    init(_data?: any) {
        if (_data) {
            this.method = _data["method"] !== undefined ? _data["method"] : AuthenticationMethod.Password;
            this.email = _data["email"];
            this.password = _data["password"] !== undefined ? _data["password"] : "";
            this.twoFactorAuthenticationCode = _data["twoFactorAuthenticationCode"];
        }
    }

    static fromJS(data: any): AuthenticationSettings {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticationSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["method"] = this.method;
        data["email"] = this.email;
        data["password"] = this.password;
        data["twoFactorAuthenticationCode"] = this.twoFactorAuthenticationCode;
        return data; 
    }
}

export interface IAuthenticationSettings {
    method?: AuthenticationMethod;
    email: string;
    /** This will be the password if using password to login, or the one-time passcode if using one-time passcode
to login. */
    password?: string | undefined;
    /** Optional 2FA code. */
    twoFactorAuthenticationCode?: string | undefined;
}

/** 0 = Password 1 = OneTimePasscode */
export enum AuthenticationMethod {
    Password = 0,
    OneTimePasscode = 1,
}

export class ChallengeToken extends Token implements IChallengeToken {
    success?: boolean;
    twoFactorAuthenticationChallenge?: TwoFactorAuthenticationType;
    rateLimit?: string;

    constructor(data?: IChallengeToken) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.success = _data["success"];
            this.twoFactorAuthenticationChallenge = _data["twoFactorAuthenticationChallenge"];
            this.rateLimit = _data["rateLimit"];
        }
    }

    static fromJS(data: any): ChallengeToken {
        data = typeof data === 'object' ? data : {};
        let result = new ChallengeToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["twoFactorAuthenticationChallenge"] = this.twoFactorAuthenticationChallenge;
        data["rateLimit"] = this.rateLimit;
        super.toJSON(data);
        return data; 
    }
}

export interface IChallengeToken extends IToken {
    success?: boolean;
    twoFactorAuthenticationChallenge?: TwoFactorAuthenticationType;
    rateLimit?: string;
}

/** 0 = None 1 = Sms 2 = Email */
export enum TwoFactorAuthenticationType {
    None = 0,
    Sms = 1,
    Email = 2,
}

export class Identity implements IIdentity {
    id?: string | undefined;
    type?: IdentityType;
    name?: string | undefined;
    email?: string | undefined;
    description?: string | undefined;
    imageUri?: string | undefined;
    groups?: IdentityGroup[] | undefined;
    impersonatorId?: string | undefined;

    constructor(data?: IIdentity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.description = _data["description"];
            this.imageUri = _data["imageUri"];
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(IdentityGroup.fromJS(item));
            }
            this.impersonatorId = _data["impersonatorId"];
        }
    }

    static fromJS(data: any): Identity {
        data = typeof data === 'object' ? data : {};
        let result = new Identity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["name"] = this.name;
        data["email"] = this.email;
        data["description"] = this.description;
        data["imageUri"] = this.imageUri;
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item.toJSON());
        }
        data["impersonatorId"] = this.impersonatorId;
        return data; 
    }
}

export interface IIdentity {
    id?: string | undefined;
    type?: IdentityType;
    name?: string | undefined;
    email?: string | undefined;
    description?: string | undefined;
    imageUri?: string | undefined;
    groups?: IdentityGroup[] | undefined;
    impersonatorId?: string | undefined;
}

export class IdentityGroup implements IIdentityGroup {
    groupId?: string | undefined;
    groupType?: string | undefined;
    parentGroups?: GroupIdAndType[] | undefined;
    displayId?: string | undefined;
    labelIds?: string[] | undefined;
    roles?: string[] | undefined;

    constructor(data?: IIdentityGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupId = _data["groupId"];
            this.groupType = _data["groupType"];
            if (Array.isArray(_data["parentGroups"])) {
                this.parentGroups = [] as any;
                for (let item of _data["parentGroups"])
                    this.parentGroups!.push(GroupIdAndType.fromJS(item));
            }
            this.displayId = _data["displayId"];
            if (Array.isArray(_data["labelIds"])) {
                this.labelIds = [] as any;
                for (let item of _data["labelIds"])
                    this.labelIds!.push(item);
            }
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): IdentityGroup {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        data["groupType"] = this.groupType;
        if (Array.isArray(this.parentGroups)) {
            data["parentGroups"] = [];
            for (let item of this.parentGroups)
                data["parentGroups"].push(item.toJSON());
        }
        data["displayId"] = this.displayId;
        if (Array.isArray(this.labelIds)) {
            data["labelIds"] = [];
            for (let item of this.labelIds)
                data["labelIds"].push(item);
        }
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data; 
    }
}

export interface IIdentityGroup {
    groupId?: string | undefined;
    groupType?: string | undefined;
    parentGroups?: GroupIdAndType[] | undefined;
    displayId?: string | undefined;
    labelIds?: string[] | undefined;
    roles?: string[] | undefined;
}

export class GroupIdAndType implements IGroupIdAndType {
    type?: string | undefined;
    id?: string | undefined;

    constructor(data?: IGroupIdAndType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GroupIdAndType {
        data = typeof data === 'object' ? data : {};
        let result = new GroupIdAndType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["id"] = this.id;
        return data; 
    }
}

export interface IGroupIdAndType {
    type?: string | undefined;
    id?: string | undefined;
}

export class CommunicationPreferences implements ICommunicationPreferences {
    userId?: string | undefined;
    emails?: EmailPreference[] | undefined;
    version?: number;

    constructor(data?: ICommunicationPreferences) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            if (Array.isArray(_data["emails"])) {
                this.emails = [] as any;
                for (let item of _data["emails"])
                    this.emails!.push(EmailPreference.fromJS(item));
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): CommunicationPreferences {
        data = typeof data === 'object' ? data : {};
        let result = new CommunicationPreferences();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        if (Array.isArray(this.emails)) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item.toJSON());
        }
        data["version"] = this.version;
        return data; 
    }
}

export interface ICommunicationPreferences {
    userId?: string | undefined;
    emails?: EmailPreference[] | undefined;
    version?: number;
}

export class EmailPreference2 implements IEmailPreference2 {
    type?: string | undefined;
    ignore?: boolean;

    constructor(data?: IEmailPreference2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.ignore = _data["ignore"];
        }
    }

    static fromJS(data: any): EmailPreference2 {
        data = typeof data === 'object' ? data : {};
        let result = new EmailPreference2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["ignore"] = this.ignore;
        return data; 
    }
}

export interface IEmailPreference2 {
    type?: string | undefined;
    ignore?: boolean;
}

export class EmailPreference extends EmailPreference2 implements IEmailPreference {
    category?: string | undefined;
    reason?: string | undefined;

    constructor(data?: IEmailPreference) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.category = _data["category"];
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): EmailPreference {
        data = typeof data === 'object' ? data : {};
        let result = new EmailPreference();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        data["reason"] = this.reason;
        super.toJSON(data);
        return data; 
    }
}

export interface IEmailPreference extends IEmailPreference2 {
    category?: string | undefined;
    reason?: string | undefined;
}

export class UpdateCommunicationPreferencesSettings implements IUpdateCommunicationPreferencesSettings {
    emails?: EmailPreference2[] | undefined;
    version?: number;

    constructor(data?: IUpdateCommunicationPreferencesSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["emails"])) {
                this.emails = [] as any;
                for (let item of _data["emails"])
                    this.emails!.push(EmailPreference2.fromJS(item));
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateCommunicationPreferencesSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCommunicationPreferencesSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.emails)) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item.toJSON());
        }
        data["version"] = this.version;
        return data; 
    }
}

export interface IUpdateCommunicationPreferencesSettings {
    emails?: EmailPreference2[] | undefined;
    version?: number;
}

export class UnsubscribeToken implements IUnsubscribeToken {
    userId?: string | undefined;
    emailType?: string | undefined;

    constructor(data?: IUnsubscribeToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.emailType = _data["emailType"];
        }
    }

    static fromJS(data: any): UnsubscribeToken {
        data = typeof data === 'object' ? data : {};
        let result = new UnsubscribeToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["emailType"] = this.emailType;
        return data; 
    }
}

export interface IUnsubscribeToken {
    userId?: string | undefined;
    emailType?: string | undefined;
}

export class EmailSettings implements IEmailSettings {
    email!: string;

    constructor(data?: IEmailSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): EmailSettings {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data; 
    }
}

export interface IEmailSettings {
    email: string;
}

export class ListOfGroupComment implements IListOfGroupComment {
    totalItemCount!: number;
    items!: GroupComment[];

    constructor(data?: IListOfGroupComment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GroupComment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfGroupComment {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfGroupComment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfGroupComment {
    totalItemCount: number;
    items: GroupComment[];
}

export class GroupComment extends Comment implements IGroupComment {
    groupName?: string | undefined;

    constructor(data?: IGroupComment) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.groupName = _data["groupName"];
        }
    }

    static fromJS(data: any): GroupComment {
        data = typeof data === 'object' ? data : {};
        let result = new GroupComment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupName"] = this.groupName;
        super.toJSON(data);
        return data; 
    }
}

export interface IGroupComment extends IComment {
    groupName?: string | undefined;
}

export class Group implements IGroup {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    type?: string | undefined;
    organisationId?: string | undefined;
    teamId?: string | undefined;

    constructor(data?: IGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.type = _data["type"];
            this.organisationId = _data["organisationId"];
            this.teamId = _data["teamId"];
        }
    }

    static fromJS(data: any): Group {
        data = typeof data === 'object' ? data : {};
        let result = new Group();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["type"] = this.type;
        data["organisationId"] = this.organisationId;
        data["teamId"] = this.teamId;
        return data; 
    }
}

export interface IGroup {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    type?: string | undefined;
    organisationId?: string | undefined;
    teamId?: string | undefined;
}

export class ListOfGroupFile implements IListOfGroupFile {
    totalItemCount!: number;
    items!: GroupFile[];

    constructor(data?: IListOfGroupFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GroupFile.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfGroupFile {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfGroupFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfGroupFile {
    totalItemCount: number;
    items: GroupFile[];
}

export class GroupFile extends File implements IGroupFile {
    groupName?: string | undefined;

    constructor(data?: IGroupFile) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.groupName = _data["groupName"];
        }
    }

    static fromJS(data: any): GroupFile {
        data = typeof data === 'object' ? data : {};
        let result = new GroupFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupName"] = this.groupName;
        super.toJSON(data);
        return data; 
    }
}

export interface IGroupFile extends IFile {
    groupName?: string | undefined;
}

export class ListOfJobType implements IListOfJobType {
    totalItemCount!: number;
    items!: JobType[];

    constructor(data?: IListOfJobType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(JobType.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfJobType {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfJobType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfJobType {
    totalItemCount: number;
    items: JobType[];
}

export class JobType implements IJobType {
    id?: string | undefined;
    name?: string | undefined;
    category?: string | undefined;
    version?: number;

    constructor(data?: IJobType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.category = _data["category"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): JobType {
        data = typeof data === 'object' ? data : {};
        let result = new JobType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["category"] = this.category;
        data["version"] = this.version;
        return data; 
    }
}

export interface IJobType {
    id?: string | undefined;
    name?: string | undefined;
    category?: string | undefined;
    version?: number;
}

export class CreateJobTypeSettings implements ICreateJobTypeSettings {
    name!: string;
    category?: string | undefined;

    constructor(data?: ICreateJobTypeSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.category = _data["category"];
        }
    }

    static fromJS(data: any): CreateJobTypeSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateJobTypeSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["category"] = this.category;
        return data; 
    }
}

export interface ICreateJobTypeSettings {
    name: string;
    category?: string | undefined;
}

export class UpdateJobTypeSettings implements IUpdateJobTypeSettings {
    name!: string;
    category?: string | undefined;
    version?: number;

    constructor(data?: IUpdateJobTypeSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.category = _data["category"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateJobTypeSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateJobTypeSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["category"] = this.category;
        data["version"] = this.version;
        return data; 
    }
}

export interface IUpdateJobTypeSettings {
    name: string;
    category?: string | undefined;
    version?: number;
}

export class ListOfLabel implements IListOfLabel {
    totalItemCount!: number;
    items!: Label[];

    constructor(data?: IListOfLabel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Label.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfLabel {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfLabel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfLabel {
    totalItemCount: number;
    items: Label[];
}

export class Label implements ILabel {
    id?: string | undefined;
    version?: number;
    groupId?: string | undefined;
    groupType?: string | undefined;
    groupName?: string | undefined;
    name?: string | undefined;
    colour?: Colour;

    constructor(data?: ILabel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.version = _data["version"];
            this.groupId = _data["groupId"];
            this.groupType = _data["groupType"];
            this.groupName = _data["groupName"];
            this.name = _data["name"];
            this.colour = _data["colour"] ? Colour.fromJS(_data["colour"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Label {
        data = typeof data === 'object' ? data : {};
        let result = new Label();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["version"] = this.version;
        data["groupId"] = this.groupId;
        data["groupType"] = this.groupType;
        data["groupName"] = this.groupName;
        data["name"] = this.name;
        data["colour"] = this.colour ? this.colour.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ILabel {
    id?: string | undefined;
    version?: number;
    groupId?: string | undefined;
    groupType?: string | undefined;
    groupName?: string | undefined;
    name?: string | undefined;
    colour?: Colour;
}

export class Colour implements IColour {
    red?: number;
    green?: number;
    blue?: number;
    alpha?: number;

    constructor(data?: IColour) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.red = _data["red"];
            this.green = _data["green"];
            this.blue = _data["blue"];
            this.alpha = _data["alpha"];
        }
    }

    static fromJS(data: any): Colour {
        data = typeof data === 'object' ? data : {};
        let result = new Colour();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["red"] = this.red;
        data["green"] = this.green;
        data["blue"] = this.blue;
        data["alpha"] = this.alpha;
        return data; 
    }
}

export interface IColour {
    red?: number;
    green?: number;
    blue?: number;
    alpha?: number;
}

export class CreateLabelSettings implements ICreateLabelSettings {
    groupId!: string;
    name!: string;
    colour?: Colour;

    constructor(data?: ICreateLabelSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupId = _data["groupId"];
            this.name = _data["name"];
            this.colour = _data["colour"] ? Colour.fromJS(_data["colour"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateLabelSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLabelSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        data["name"] = this.name;
        data["colour"] = this.colour ? this.colour.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICreateLabelSettings {
    groupId: string;
    name: string;
    colour?: Colour;
}

export class UpdateLabelSettings implements IUpdateLabelSettings {
    name!: string;
    colour?: Colour;
    version?: number;

    constructor(data?: IUpdateLabelSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.colour = _data["colour"] ? Colour.fromJS(_data["colour"]) : <any>undefined;
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateLabelSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLabelSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["colour"] = this.colour ? this.colour.toJSON() : <any>undefined;
        data["version"] = this.version;
        return data; 
    }
}

export interface IUpdateLabelSettings {
    name: string;
    colour?: Colour;
    version?: number;
}

export class ListOfMember implements IListOfMember {
    totalItemCount!: number;
    items!: Member[];

    constructor(data?: IListOfMember) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Member.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfMember {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfMember();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfMember {
    totalItemCount: number;
    items: Member[];
}

export class Member implements IMember {
    id?: string | undefined;
    groupId?: string | undefined;
    groupType?: string | undefined;
    groupName?: string | undefined;
    parentGroups?: GroupIdAndType[] | undefined;
    templateId?: string | undefined;
    templateParentIds?: string[] | undefined;
    userId?: string | undefined;
    userName?: string | undefined;
    userImageUri?: string | undefined;
    userEmail?: string | undefined;
    userJobTypeId?: string | undefined;
    userJobTypeName?: string | undefined;
    userJobTypeCategory?: string | undefined;
    userQualifications?: string | undefined;
    userActivated?: boolean;
    userLastActive?: Date | undefined;
    displayId?: string | undefined;
    status?: MemberStatus;
    roles?: string[] | undefined;
    labelIds?: string[] | undefined;
    version?: number;
    created?: Date;
    modified?: Date;
    joined?: Date;

    constructor(data?: IMember) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.groupId = _data["groupId"];
            this.groupType = _data["groupType"];
            this.groupName = _data["groupName"];
            if (Array.isArray(_data["parentGroups"])) {
                this.parentGroups = [] as any;
                for (let item of _data["parentGroups"])
                    this.parentGroups!.push(GroupIdAndType.fromJS(item));
            }
            this.templateId = _data["templateId"];
            if (Array.isArray(_data["templateParentIds"])) {
                this.templateParentIds = [] as any;
                for (let item of _data["templateParentIds"])
                    this.templateParentIds!.push(item);
            }
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.userImageUri = _data["userImageUri"];
            this.userEmail = _data["userEmail"];
            this.userJobTypeId = _data["userJobTypeId"];
            this.userJobTypeName = _data["userJobTypeName"];
            this.userJobTypeCategory = _data["userJobTypeCategory"];
            this.userQualifications = _data["userQualifications"];
            this.userActivated = _data["userActivated"];
            this.userLastActive = _data["userLastActive"] ? new Date(_data["userLastActive"].toString()) : <any>undefined;
            this.displayId = _data["displayId"];
            this.status = _data["status"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
            if (Array.isArray(_data["labelIds"])) {
                this.labelIds = [] as any;
                for (let item of _data["labelIds"])
                    this.labelIds!.push(item);
            }
            this.version = _data["version"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
            this.joined = _data["joined"] ? new Date(_data["joined"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Member {
        data = typeof data === 'object' ? data : {};
        let result = new Member();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["groupId"] = this.groupId;
        data["groupType"] = this.groupType;
        data["groupName"] = this.groupName;
        if (Array.isArray(this.parentGroups)) {
            data["parentGroups"] = [];
            for (let item of this.parentGroups)
                data["parentGroups"].push(item.toJSON());
        }
        data["templateId"] = this.templateId;
        if (Array.isArray(this.templateParentIds)) {
            data["templateParentIds"] = [];
            for (let item of this.templateParentIds)
                data["templateParentIds"].push(item);
        }
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["userImageUri"] = this.userImageUri;
        data["userEmail"] = this.userEmail;
        data["userJobTypeId"] = this.userJobTypeId;
        data["userJobTypeName"] = this.userJobTypeName;
        data["userJobTypeCategory"] = this.userJobTypeCategory;
        data["userQualifications"] = this.userQualifications;
        data["userActivated"] = this.userActivated;
        data["userLastActive"] = this.userLastActive ? this.userLastActive.toISOString() : <any>undefined;
        data["displayId"] = this.displayId;
        data["status"] = this.status;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        if (Array.isArray(this.labelIds)) {
            data["labelIds"] = [];
            for (let item of this.labelIds)
                data["labelIds"].push(item);
        }
        data["version"] = this.version;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        data["joined"] = this.joined ? this.joined.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IMember {
    id?: string | undefined;
    groupId?: string | undefined;
    groupType?: string | undefined;
    groupName?: string | undefined;
    parentGroups?: GroupIdAndType[] | undefined;
    templateId?: string | undefined;
    templateParentIds?: string[] | undefined;
    userId?: string | undefined;
    userName?: string | undefined;
    userImageUri?: string | undefined;
    userEmail?: string | undefined;
    userJobTypeId?: string | undefined;
    userJobTypeName?: string | undefined;
    userJobTypeCategory?: string | undefined;
    userQualifications?: string | undefined;
    userActivated?: boolean;
    userLastActive?: Date | undefined;
    displayId?: string | undefined;
    status?: MemberStatus;
    roles?: string[] | undefined;
    labelIds?: string[] | undefined;
    version?: number;
    created?: Date;
    modified?: Date;
    joined?: Date;
}

export class MemberHistory implements IMemberHistory {
    id?: string | undefined;
    userId?: string | undefined;
    status?: MemberStatus;
    roles?: string[] | undefined;

    constructor(data?: IMemberHistory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.status = _data["status"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): MemberHistory {
        data = typeof data === 'object' ? data : {};
        let result = new MemberHistory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["status"] = this.status;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data; 
    }
}

export interface IMemberHistory {
    id?: string | undefined;
    userId?: string | undefined;
    status?: MemberStatus;
    roles?: string[] | undefined;
}

export class AddGroupMemberSettings implements IAddGroupMemberSettings {
    displayId?: string | undefined;
    additionalRoles?: string[] | undefined;
    labelIds?: string[] | undefined;
    notify?: boolean;
    message?: string | undefined;

    constructor(data?: IAddGroupMemberSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayId = _data["displayId"];
            if (Array.isArray(_data["additionalRoles"])) {
                this.additionalRoles = [] as any;
                for (let item of _data["additionalRoles"])
                    this.additionalRoles!.push(item);
            }
            if (Array.isArray(_data["labelIds"])) {
                this.labelIds = [] as any;
                for (let item of _data["labelIds"])
                    this.labelIds!.push(item);
            }
            this.notify = _data["notify"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): AddGroupMemberSettings {
        data = typeof data === 'object' ? data : {};
        let result = new AddGroupMemberSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayId"] = this.displayId;
        if (Array.isArray(this.additionalRoles)) {
            data["additionalRoles"] = [];
            for (let item of this.additionalRoles)
                data["additionalRoles"].push(item);
        }
        if (Array.isArray(this.labelIds)) {
            data["labelIds"] = [];
            for (let item of this.labelIds)
                data["labelIds"].push(item);
        }
        data["notify"] = this.notify;
        data["message"] = this.message;
        return data; 
    }
}

export interface IAddGroupMemberSettings {
    displayId?: string | undefined;
    additionalRoles?: string[] | undefined;
    labelIds?: string[] | undefined;
    notify?: boolean;
    message?: string | undefined;
}

export class UpdateGroupMemberSettings implements IUpdateGroupMemberSettings {
    displayId?: string | undefined;
    additionalRoles?: string[] | undefined;
    labelIds?: string[] | undefined;

    constructor(data?: IUpdateGroupMemberSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayId = _data["displayId"];
            if (Array.isArray(_data["additionalRoles"])) {
                this.additionalRoles = [] as any;
                for (let item of _data["additionalRoles"])
                    this.additionalRoles!.push(item);
            }
            if (Array.isArray(_data["labelIds"])) {
                this.labelIds = [] as any;
                for (let item of _data["labelIds"])
                    this.labelIds!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateGroupMemberSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGroupMemberSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayId"] = this.displayId;
        if (Array.isArray(this.additionalRoles)) {
            data["additionalRoles"] = [];
            for (let item of this.additionalRoles)
                data["additionalRoles"].push(item);
        }
        if (Array.isArray(this.labelIds)) {
            data["labelIds"] = [];
            for (let item of this.labelIds)
                data["labelIds"].push(item);
        }
        return data; 
    }
}

export interface IUpdateGroupMemberSettings {
    displayId?: string | undefined;
    additionalRoles?: string[] | undefined;
    labelIds?: string[] | undefined;
}

export class ListOfOrganisationAccessToken implements IListOfOrganisationAccessToken {
    totalItemCount!: number;
    items!: OrganisationAccessToken[];

    constructor(data?: IListOfOrganisationAccessToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrganisationAccessToken.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfOrganisationAccessToken {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfOrganisationAccessToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfOrganisationAccessToken {
    totalItemCount: number;
    items: OrganisationAccessToken[];
}

export class OrganisationAccessToken implements IOrganisationAccessToken {
    id?: string | undefined;
    name?: string | undefined;
    organisationId?: string | undefined;
    roles?: string[] | undefined;
    created?: Date;
    creatorId?: string | undefined;
    creatorName?: string | undefined;
    lastUsed?: Date | undefined;
    /** Only available at time of creation */
    token?: string | undefined;

    constructor(data?: IOrganisationAccessToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.organisationId = _data["organisationId"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.creatorId = _data["creatorId"];
            this.creatorName = _data["creatorName"];
            this.lastUsed = _data["lastUsed"] ? new Date(_data["lastUsed"].toString()) : <any>undefined;
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): OrganisationAccessToken {
        data = typeof data === 'object' ? data : {};
        let result = new OrganisationAccessToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["organisationId"] = this.organisationId;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["creatorId"] = this.creatorId;
        data["creatorName"] = this.creatorName;
        data["lastUsed"] = this.lastUsed ? this.lastUsed.toISOString() : <any>undefined;
        data["token"] = this.token;
        return data; 
    }
}

export interface IOrganisationAccessToken {
    id?: string | undefined;
    name?: string | undefined;
    organisationId?: string | undefined;
    roles?: string[] | undefined;
    created?: Date;
    creatorId?: string | undefined;
    creatorName?: string | undefined;
    lastUsed?: Date | undefined;
    /** Only available at time of creation */
    token?: string | undefined;
}

export class CreateOrganisationAccessTokenSettings implements ICreateOrganisationAccessTokenSettings {
    name!: string;
    organisationId!: string;
    roles!: string[];

    constructor(data?: ICreateOrganisationAccessTokenSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.roles = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.organisationId = _data["organisationId"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrganisationAccessTokenSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganisationAccessTokenSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["organisationId"] = this.organisationId;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data; 
    }
}

export interface ICreateOrganisationAccessTokenSettings {
    name: string;
    organisationId: string;
    roles: string[];
}

export class ListOfOrganisation implements IListOfOrganisation {
    totalItemCount!: number;
    items!: Organisation[];

    constructor(data?: IListOfOrganisation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Organisation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfOrganisation {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfOrganisation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfOrganisation {
    totalItemCount: number;
    items: Organisation[];
}

export class Organisation implements IOrganisation {
    id?: string | undefined;
    name?: string | undefined;
    shortName?: string | undefined;
    description?: string | undefined;
    contactEmail?: string | undefined;
    bannerUri?: string | undefined;
    logoUri?: string | undefined;
    location?: Location;
    privacy?: PrivacyLevel;
    website?: string | undefined;
    cultureCode?: string | undefined;
    timeZoneId?: string | undefined;
    portalUri?: string | undefined;
    colour?: Colour;
    registrationWhitelist?: string[] | undefined;
    publishingApproved?: boolean;
    shifts?: Shift[] | undefined;
    version?: number;

    constructor(data?: IOrganisation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.shortName = _data["shortName"];
            this.description = _data["description"];
            this.contactEmail = _data["contactEmail"];
            this.bannerUri = _data["bannerUri"];
            this.logoUri = _data["logoUri"];
            this.location = _data["location"] ? Location.fromJS(_data["location"]) : <any>undefined;
            this.privacy = _data["privacy"];
            this.website = _data["website"];
            this.cultureCode = _data["cultureCode"];
            this.timeZoneId = _data["timeZoneId"];
            this.portalUri = _data["portalUri"];
            this.colour = _data["colour"] ? Colour.fromJS(_data["colour"]) : <any>undefined;
            if (Array.isArray(_data["registrationWhitelist"])) {
                this.registrationWhitelist = [] as any;
                for (let item of _data["registrationWhitelist"])
                    this.registrationWhitelist!.push(item);
            }
            this.publishingApproved = _data["publishingApproved"];
            if (Array.isArray(_data["shifts"])) {
                this.shifts = [] as any;
                for (let item of _data["shifts"])
                    this.shifts!.push(Shift.fromJS(item));
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): Organisation {
        data = typeof data === 'object' ? data : {};
        let result = new Organisation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["shortName"] = this.shortName;
        data["description"] = this.description;
        data["contactEmail"] = this.contactEmail;
        data["bannerUri"] = this.bannerUri;
        data["logoUri"] = this.logoUri;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["privacy"] = this.privacy;
        data["website"] = this.website;
        data["cultureCode"] = this.cultureCode;
        data["timeZoneId"] = this.timeZoneId;
        data["portalUri"] = this.portalUri;
        data["colour"] = this.colour ? this.colour.toJSON() : <any>undefined;
        if (Array.isArray(this.registrationWhitelist)) {
            data["registrationWhitelist"] = [];
            for (let item of this.registrationWhitelist)
                data["registrationWhitelist"].push(item);
        }
        data["publishingApproved"] = this.publishingApproved;
        if (Array.isArray(this.shifts)) {
            data["shifts"] = [];
            for (let item of this.shifts)
                data["shifts"].push(item.toJSON());
        }
        data["version"] = this.version;
        return data; 
    }
}

export interface IOrganisation {
    id?: string | undefined;
    name?: string | undefined;
    shortName?: string | undefined;
    description?: string | undefined;
    contactEmail?: string | undefined;
    bannerUri?: string | undefined;
    logoUri?: string | undefined;
    location?: Location;
    privacy?: PrivacyLevel;
    website?: string | undefined;
    cultureCode?: string | undefined;
    timeZoneId?: string | undefined;
    portalUri?: string | undefined;
    colour?: Colour;
    registrationWhitelist?: string[] | undefined;
    publishingApproved?: boolean;
    shifts?: Shift[] | undefined;
    version?: number;
}

export class Shift implements IShift {
    start?: string;
    end?: string;

    constructor(data?: IShift) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.start = _data["start"];
            this.end = _data["end"];
        }
    }

    static fromJS(data: any): Shift {
        data = typeof data === 'object' ? data : {};
        let result = new Shift();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["start"] = this.start;
        data["end"] = this.end;
        return data; 
    }
}

export interface IShift {
    start?: string;
    end?: string;
}

export class CreateOrganisationSettings implements ICreateOrganisationSettings {
    name!: string;
    shortName?: string | undefined;
    description?: string | undefined;
    contactEmail?: string | undefined;
    bannerUri?: string | undefined;
    logoUri?: string | undefined;
    colour?: Colour;
    location?: LocationBuilder | undefined;
    website?: string | undefined;
    portalUri?: string | undefined;
    cultureCode?: string | undefined;
    timeZoneId?: string | undefined;
    privacy?: PrivacyLevel;
    registrationWhitelist?: string[] | undefined;
    shifts?: Shift[] | undefined;

    constructor(data?: ICreateOrganisationSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.shortName = _data["shortName"];
            this.description = _data["description"];
            this.contactEmail = _data["contactEmail"];
            this.bannerUri = _data["bannerUri"];
            this.logoUri = _data["logoUri"];
            this.colour = _data["colour"] ? Colour.fromJS(_data["colour"]) : <any>undefined;
            this.location = _data["location"] ? LocationBuilder.fromJS(_data["location"]) : <any>undefined;
            this.website = _data["website"];
            this.portalUri = _data["portalUri"];
            this.cultureCode = _data["cultureCode"];
            this.timeZoneId = _data["timeZoneId"];
            this.privacy = _data["privacy"];
            if (Array.isArray(_data["registrationWhitelist"])) {
                this.registrationWhitelist = [] as any;
                for (let item of _data["registrationWhitelist"])
                    this.registrationWhitelist!.push(item);
            }
            if (Array.isArray(_data["shifts"])) {
                this.shifts = [] as any;
                for (let item of _data["shifts"])
                    this.shifts!.push(Shift.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateOrganisationSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganisationSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["shortName"] = this.shortName;
        data["description"] = this.description;
        data["contactEmail"] = this.contactEmail;
        data["bannerUri"] = this.bannerUri;
        data["logoUri"] = this.logoUri;
        data["colour"] = this.colour ? this.colour.toJSON() : <any>undefined;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["website"] = this.website;
        data["portalUri"] = this.portalUri;
        data["cultureCode"] = this.cultureCode;
        data["timeZoneId"] = this.timeZoneId;
        data["privacy"] = this.privacy;
        if (Array.isArray(this.registrationWhitelist)) {
            data["registrationWhitelist"] = [];
            for (let item of this.registrationWhitelist)
                data["registrationWhitelist"].push(item);
        }
        if (Array.isArray(this.shifts)) {
            data["shifts"] = [];
            for (let item of this.shifts)
                data["shifts"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateOrganisationSettings {
    name: string;
    shortName?: string | undefined;
    description?: string | undefined;
    contactEmail?: string | undefined;
    bannerUri?: string | undefined;
    logoUri?: string | undefined;
    colour?: Colour;
    location?: LocationBuilder | undefined;
    website?: string | undefined;
    portalUri?: string | undefined;
    cultureCode?: string | undefined;
    timeZoneId?: string | undefined;
    privacy?: PrivacyLevel;
    registrationWhitelist?: string[] | undefined;
    shifts?: Shift[] | undefined;
}

export class UpdateOrganisationSettings implements IUpdateOrganisationSettings {
    name!: string;
    shortName?: string | undefined;
    description?: string | undefined;
    contactEmail?: string | undefined;
    bannerUri?: string | undefined;
    logoUri?: string | undefined;
    colour?: Colour;
    location?: LocationBuilder | undefined;
    website?: string | undefined;
    portalUri?: string | undefined;
    privacy?: PrivacyLevel;
    timeZoneId?: string | undefined;
    cultureCode?: string | undefined;
    registrationWhitelist?: string[] | undefined;
    shifts?: Shift[] | undefined;
    version?: number;

    constructor(data?: IUpdateOrganisationSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.shortName = _data["shortName"];
            this.description = _data["description"];
            this.contactEmail = _data["contactEmail"];
            this.bannerUri = _data["bannerUri"];
            this.logoUri = _data["logoUri"];
            this.colour = _data["colour"] ? Colour.fromJS(_data["colour"]) : <any>undefined;
            this.location = _data["location"] ? LocationBuilder.fromJS(_data["location"]) : <any>undefined;
            this.website = _data["website"];
            this.portalUri = _data["portalUri"];
            this.privacy = _data["privacy"];
            this.timeZoneId = _data["timeZoneId"];
            this.cultureCode = _data["cultureCode"];
            if (Array.isArray(_data["registrationWhitelist"])) {
                this.registrationWhitelist = [] as any;
                for (let item of _data["registrationWhitelist"])
                    this.registrationWhitelist!.push(item);
            }
            if (Array.isArray(_data["shifts"])) {
                this.shifts = [] as any;
                for (let item of _data["shifts"])
                    this.shifts!.push(Shift.fromJS(item));
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateOrganisationSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrganisationSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["shortName"] = this.shortName;
        data["description"] = this.description;
        data["contactEmail"] = this.contactEmail;
        data["bannerUri"] = this.bannerUri;
        data["logoUri"] = this.logoUri;
        data["colour"] = this.colour ? this.colour.toJSON() : <any>undefined;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["website"] = this.website;
        data["portalUri"] = this.portalUri;
        data["privacy"] = this.privacy;
        data["timeZoneId"] = this.timeZoneId;
        data["cultureCode"] = this.cultureCode;
        if (Array.isArray(this.registrationWhitelist)) {
            data["registrationWhitelist"] = [];
            for (let item of this.registrationWhitelist)
                data["registrationWhitelist"].push(item);
        }
        if (Array.isArray(this.shifts)) {
            data["shifts"] = [];
            for (let item of this.shifts)
                data["shifts"].push(item.toJSON());
        }
        data["version"] = this.version;
        return data; 
    }
}

export interface IUpdateOrganisationSettings {
    name: string;
    shortName?: string | undefined;
    description?: string | undefined;
    contactEmail?: string | undefined;
    bannerUri?: string | undefined;
    logoUri?: string | undefined;
    colour?: Colour;
    location?: LocationBuilder | undefined;
    website?: string | undefined;
    portalUri?: string | undefined;
    privacy?: PrivacyLevel;
    timeZoneId?: string | undefined;
    cultureCode?: string | undefined;
    registrationWhitelist?: string[] | undefined;
    shifts?: Shift[] | undefined;
    version?: number;
}

export class Password implements IPassword {
    version?: number;
    exists?: boolean;
    twoFactorAuthentication?: TwoFactorAuthenticationType;

    constructor(data?: IPassword) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.exists = _data["exists"];
            this.twoFactorAuthentication = _data["twoFactorAuthentication"];
        }
    }

    static fromJS(data: any): Password {
        data = typeof data === 'object' ? data : {};
        let result = new Password();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["exists"] = this.exists;
        data["twoFactorAuthentication"] = this.twoFactorAuthentication;
        return data; 
    }
}

export interface IPassword {
    version?: number;
    exists?: boolean;
    twoFactorAuthentication?: TwoFactorAuthenticationType;
}

export class UpdatePasswordSettings implements IUpdatePasswordSettings {
    password!: string;
    version?: number;

    constructor(data?: IUpdatePasswordSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.password = _data["password"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdatePasswordSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePasswordSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        data["version"] = this.version;
        return data; 
    }
}

export interface IUpdatePasswordSettings {
    password: string;
    version?: number;
}

export class UpdateTwoFactorAuthenticationSettings implements IUpdateTwoFactorAuthenticationSettings {
    type?: TwoFactorAuthenticationType;
    userVersion?: number;

    constructor(data?: IUpdateTwoFactorAuthenticationSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.userVersion = _data["userVersion"];
        }
    }

    static fromJS(data: any): UpdateTwoFactorAuthenticationSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTwoFactorAuthenticationSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["userVersion"] = this.userVersion;
        return data; 
    }
}

export interface IUpdateTwoFactorAuthenticationSettings {
    type?: TwoFactorAuthenticationType;
    userVersion?: number;
}

export class RequestResetPasswordSettings implements IRequestResetPasswordSettings {
    email!: string;

    constructor(data?: IRequestResetPasswordSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): RequestResetPasswordSettings {
        data = typeof data === 'object' ? data : {};
        let result = new RequestResetPasswordSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data; 
    }
}

export interface IRequestResetPasswordSettings {
    email: string;
}

export class ResetPasswordSettings implements IResetPasswordSettings {
    token!: string;
    password!: string;

    constructor(data?: IResetPasswordSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): ResetPasswordSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["password"] = this.password;
        return data; 
    }
}

export interface IResetPasswordSettings {
    token: string;
    password: string;
}

export class ListOfRole implements IListOfRole {
    totalItemCount!: number;
    items!: Role[];

    constructor(data?: IListOfRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Role.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfRole {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfRole {
    totalItemCount: number;
    items: Role[];
}

export class Role implements IRole {
    name?: string | undefined;
    groupType?: string | undefined;
    owner?: boolean;
    default?: boolean;
    fallback?: boolean;
    description?: string | undefined;

    constructor(data?: IRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.groupType = _data["groupType"];
            this.owner = _data["owner"];
            this.default = _data["default"];
            this.fallback = _data["fallback"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): Role {
        data = typeof data === 'object' ? data : {};
        let result = new Role();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["groupType"] = this.groupType;
        data["owner"] = this.owner;
        data["default"] = this.default;
        data["fallback"] = this.fallback;
        data["description"] = this.description;
        return data; 
    }
}

export interface IRole {
    name?: string | undefined;
    groupType?: string | undefined;
    owner?: boolean;
    default?: boolean;
    fallback?: boolean;
    description?: string | undefined;
}

export class ListOfTeam implements IListOfTeam {
    totalItemCount!: number;
    items!: Team[];

    constructor(data?: IListOfTeam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Team.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfTeam {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfTeam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfTeam {
    totalItemCount: number;
    items: Team[];
}

export class Team implements ITeam {
    id?: string | undefined;
    shortName?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    bannerUri?: string | undefined;
    privacy?: PrivacyLevel;
    tags?: string[] | undefined;
    organisationId?: string | undefined;
    organisationName?: string | undefined;
    organisationLogoUri?: string | undefined;
    organisationPrivacy?: PrivacyLevel;
    version?: number;

    constructor(data?: ITeam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.shortName = _data["shortName"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.bannerUri = _data["bannerUri"];
            this.privacy = _data["privacy"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            this.organisationId = _data["organisationId"];
            this.organisationName = _data["organisationName"];
            this.organisationLogoUri = _data["organisationLogoUri"];
            this.organisationPrivacy = _data["organisationPrivacy"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): Team {
        data = typeof data === 'object' ? data : {};
        let result = new Team();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["shortName"] = this.shortName;
        data["name"] = this.name;
        data["description"] = this.description;
        data["bannerUri"] = this.bannerUri;
        data["privacy"] = this.privacy;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["organisationId"] = this.organisationId;
        data["organisationName"] = this.organisationName;
        data["organisationLogoUri"] = this.organisationLogoUri;
        data["organisationPrivacy"] = this.organisationPrivacy;
        data["version"] = this.version;
        return data; 
    }
}

export interface ITeam {
    id?: string | undefined;
    shortName?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    bannerUri?: string | undefined;
    privacy?: PrivacyLevel;
    tags?: string[] | undefined;
    organisationId?: string | undefined;
    organisationName?: string | undefined;
    organisationLogoUri?: string | undefined;
    organisationPrivacy?: PrivacyLevel;
    version?: number;
}

export class CreateTeamSettings implements ICreateTeamSettings {
    organisationId!: string;
    name!: string;
    shortName?: string | undefined;
    description?: string | undefined;
    bannerUri?: string | undefined;
    privacy?: PrivacyLevel;
    tags?: string[] | undefined;

    constructor(data?: ICreateTeamSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organisationId = _data["organisationId"];
            this.name = _data["name"];
            this.shortName = _data["shortName"];
            this.description = _data["description"];
            this.bannerUri = _data["bannerUri"];
            this.privacy = _data["privacy"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateTeamSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTeamSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organisationId"] = this.organisationId;
        data["name"] = this.name;
        data["shortName"] = this.shortName;
        data["description"] = this.description;
        data["bannerUri"] = this.bannerUri;
        data["privacy"] = this.privacy;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data; 
    }
}

export interface ICreateTeamSettings {
    organisationId: string;
    name: string;
    shortName?: string | undefined;
    description?: string | undefined;
    bannerUri?: string | undefined;
    privacy?: PrivacyLevel;
    tags?: string[] | undefined;
}

export class UpdateTeamSettings implements IUpdateTeamSettings {
    name!: string;
    shortName?: string | undefined;
    description?: string | undefined;
    bannerUri?: string | undefined;
    privacy?: PrivacyLevel;
    tags?: string[] | undefined;
    version?: number;

    constructor(data?: IUpdateTeamSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.shortName = _data["shortName"];
            this.description = _data["description"];
            this.bannerUri = _data["bannerUri"];
            this.privacy = _data["privacy"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateTeamSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTeamSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["shortName"] = this.shortName;
        data["description"] = this.description;
        data["bannerUri"] = this.bannerUri;
        data["privacy"] = this.privacy;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["version"] = this.version;
        return data; 
    }
}

export interface IUpdateTeamSettings {
    name: string;
    shortName?: string | undefined;
    description?: string | undefined;
    bannerUri?: string | undefined;
    privacy?: PrivacyLevel;
    tags?: string[] | undefined;
    version?: number;
}

export class ListOfUserActivity implements IListOfUserActivity {
    totalItemCount!: number;
    items!: UserActivity[];

    constructor(data?: IListOfUserActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserActivity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfUserActivity {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfUserActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfUserActivity {
    totalItemCount: number;
    items: UserActivity[];
}

export class UserActivity implements IUserActivity {
    id?: string | undefined;
    trackId?: string | undefined;
    activityType?: UserActivityType;
    userId?: string | undefined;
    creatorId?: string | undefined;
    creatorType?: IdentityType;
    payload?: any | undefined;
    created?: Date;
    modified?: Date;

    constructor(data?: IUserActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.trackId = _data["trackId"];
            this.activityType = _data["activityType"];
            this.userId = _data["userId"];
            this.creatorId = _data["creatorId"];
            this.creatorType = _data["creatorType"];
            this.payload = _data["payload"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserActivity {
        data = typeof data === 'object' ? data : {};
        let result = new UserActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["trackId"] = this.trackId;
        data["activityType"] = this.activityType;
        data["userId"] = this.userId;
        data["creatorId"] = this.creatorId;
        data["creatorType"] = this.creatorType;
        data["payload"] = this.payload;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IUserActivity {
    id?: string | undefined;
    trackId?: string | undefined;
    activityType?: UserActivityType;
    userId?: string | undefined;
    creatorId?: string | undefined;
    creatorType?: IdentityType;
    payload?: any | undefined;
    created?: Date;
    modified?: Date;
}

export enum UserActivityType {
    Unknown = "Unknown",
    Joined = "Joined",
    Left = "Left",
    Banned = "Banned",
    RolesAdded = "RolesAdded",
    RolesRemoved = "RolesRemoved",
    ModuleAttempt = "ModuleAttempt",
    SurveyResponse = "SurveyResponse",
}

export class ListOfUser implements IListOfUser {
    totalItemCount!: number;
    items!: User[];

    constructor(data?: IListOfUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(User.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfUser {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListOfUser {
    totalItemCount: number;
    items: User[];
}

export class User implements IUser {
    id?: string | undefined;
    name?: string | undefined;
    alternativeNames?: string[] | undefined;
    imageUri?: string | undefined;
    description?: string | undefined;
    qualifications?: string | undefined;
    jobTypeId?: string | undefined;
    jobTypeName?: string | undefined;
    jobTypeCategory?: string | undefined;
    verified?: boolean;
    version?: number;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["alternativeNames"])) {
                this.alternativeNames = [] as any;
                for (let item of _data["alternativeNames"])
                    this.alternativeNames!.push(item);
            }
            this.imageUri = _data["imageUri"];
            this.description = _data["description"];
            this.qualifications = _data["qualifications"];
            this.jobTypeId = _data["jobTypeId"];
            this.jobTypeName = _data["jobTypeName"];
            this.jobTypeCategory = _data["jobTypeCategory"];
            this.verified = _data["verified"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.alternativeNames)) {
            data["alternativeNames"] = [];
            for (let item of this.alternativeNames)
                data["alternativeNames"].push(item);
        }
        data["imageUri"] = this.imageUri;
        data["description"] = this.description;
        data["qualifications"] = this.qualifications;
        data["jobTypeId"] = this.jobTypeId;
        data["jobTypeName"] = this.jobTypeName;
        data["jobTypeCategory"] = this.jobTypeCategory;
        data["verified"] = this.verified;
        data["version"] = this.version;
        return data; 
    }
}

export interface IUser {
    id?: string | undefined;
    name?: string | undefined;
    alternativeNames?: string[] | undefined;
    imageUri?: string | undefined;
    description?: string | undefined;
    qualifications?: string | undefined;
    jobTypeId?: string | undefined;
    jobTypeName?: string | undefined;
    jobTypeCategory?: string | undefined;
    verified?: boolean;
    version?: number;
}

export class CreateUserSettings implements ICreateUserSettings {
    name!: string;
    alternativeNames?: string[] | undefined;
    email!: string;
    password!: string;
    reCaptchaResponse?: string | undefined;
    redirect?: string | undefined;

    constructor(data?: ICreateUserSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["alternativeNames"])) {
                this.alternativeNames = [] as any;
                for (let item of _data["alternativeNames"])
                    this.alternativeNames!.push(item);
            }
            this.email = _data["email"];
            this.password = _data["password"];
            this.reCaptchaResponse = _data["reCaptchaResponse"];
            this.redirect = _data["redirect"];
        }
    }

    static fromJS(data: any): CreateUserSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.alternativeNames)) {
            data["alternativeNames"] = [];
            for (let item of this.alternativeNames)
                data["alternativeNames"].push(item);
        }
        data["email"] = this.email;
        data["password"] = this.password;
        data["reCaptchaResponse"] = this.reCaptchaResponse;
        data["redirect"] = this.redirect;
        return data; 
    }
}

export interface ICreateUserSettings {
    name: string;
    alternativeNames?: string[] | undefined;
    email: string;
    password: string;
    reCaptchaResponse?: string | undefined;
    redirect?: string | undefined;
}

export class OnboardUserSettings implements IOnboardUserSettings {
    name?: string | undefined;
    email!: string;
    groupId!: string;
    displayId?: string | undefined;
    jobTypeId?: string | undefined;
    additionalRoles?: string[] | undefined;
    labelIds?: string[] | undefined;
    notify?: boolean;
    message?: string | undefined;

    constructor(data?: IOnboardUserSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.email = _data["email"];
            this.groupId = _data["groupId"];
            this.displayId = _data["displayId"];
            this.jobTypeId = _data["jobTypeId"];
            if (Array.isArray(_data["additionalRoles"])) {
                this.additionalRoles = [] as any;
                for (let item of _data["additionalRoles"])
                    this.additionalRoles!.push(item);
            }
            if (Array.isArray(_data["labelIds"])) {
                this.labelIds = [] as any;
                for (let item of _data["labelIds"])
                    this.labelIds!.push(item);
            }
            this.notify = _data["notify"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): OnboardUserSettings {
        data = typeof data === 'object' ? data : {};
        let result = new OnboardUserSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["email"] = this.email;
        data["groupId"] = this.groupId;
        data["displayId"] = this.displayId;
        data["jobTypeId"] = this.jobTypeId;
        if (Array.isArray(this.additionalRoles)) {
            data["additionalRoles"] = [];
            for (let item of this.additionalRoles)
                data["additionalRoles"].push(item);
        }
        if (Array.isArray(this.labelIds)) {
            data["labelIds"] = [];
            for (let item of this.labelIds)
                data["labelIds"].push(item);
        }
        data["notify"] = this.notify;
        data["message"] = this.message;
        return data; 
    }
}

export interface IOnboardUserSettings {
    name?: string | undefined;
    email: string;
    groupId: string;
    displayId?: string | undefined;
    jobTypeId?: string | undefined;
    additionalRoles?: string[] | undefined;
    labelIds?: string[] | undefined;
    notify?: boolean;
    message?: string | undefined;
}

export class UpdateUserSettings implements IUpdateUserSettings {
    name!: string;
    alternativeNames?: string[];
    qualifications?: string | undefined;
    description?: string | undefined;
    jobTypeId?: string | undefined;
    imageUri?: string | undefined;
    version?: number;

    constructor(data?: IUpdateUserSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["alternativeNames"])) {
                this.alternativeNames = [] as any;
                for (let item of _data["alternativeNames"])
                    this.alternativeNames!.push(item);
            }
            this.qualifications = _data["qualifications"];
            this.description = _data["description"];
            this.jobTypeId = _data["jobTypeId"];
            this.imageUri = _data["imageUri"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateUserSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.alternativeNames)) {
            data["alternativeNames"] = [];
            for (let item of this.alternativeNames)
                data["alternativeNames"].push(item);
        }
        data["qualifications"] = this.qualifications;
        data["description"] = this.description;
        data["jobTypeId"] = this.jobTypeId;
        data["imageUri"] = this.imageUri;
        data["version"] = this.version;
        return data; 
    }
}

export interface IUpdateUserSettings {
    name: string;
    alternativeNames?: string[];
    qualifications?: string | undefined;
    description?: string | undefined;
    jobTypeId?: string | undefined;
    imageUri?: string | undefined;
    version?: number;
}

export class MergeUserSettings implements IMergeUserSettings {
    primaryUserId!: string;
    secondaryUserId!: string;

    constructor(data?: IMergeUserSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.primaryUserId = _data["primaryUserId"];
            this.secondaryUserId = _data["secondaryUserId"];
        }
    }

    static fromJS(data: any): MergeUserSettings {
        data = typeof data === 'object' ? data : {};
        let result = new MergeUserSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["primaryUserId"] = this.primaryUserId;
        data["secondaryUserId"] = this.secondaryUserId;
        return data; 
    }
}

export interface IMergeUserSettings {
    primaryUserId: string;
    secondaryUserId: string;
}

export class SendWelcomeEmailSettings implements ISendWelcomeEmailSettings {
    groupId?: string | undefined;
    message?: string | undefined;
    redirect?: string | undefined;

    constructor(data?: ISendWelcomeEmailSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupId = _data["groupId"];
            this.message = _data["message"];
            this.redirect = _data["redirect"];
        }
    }

    static fromJS(data: any): SendWelcomeEmailSettings {
        data = typeof data === 'object' ? data : {};
        let result = new SendWelcomeEmailSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        data["message"] = this.message;
        data["redirect"] = this.redirect;
        return data; 
    }
}

export interface ISendWelcomeEmailSettings {
    groupId?: string | undefined;
    message?: string | undefined;
    redirect?: string | undefined;
}

export class UserEmails implements IUserEmails {
    id?: string | undefined;
    emails?: UserEmail[] | undefined;
    primaryEmail?: string | undefined;
    version?: number;

    constructor(data?: IUserEmails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["emails"])) {
                this.emails = [] as any;
                for (let item of _data["emails"])
                    this.emails!.push(UserEmail.fromJS(item));
            }
            this.primaryEmail = _data["primaryEmail"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UserEmails {
        data = typeof data === 'object' ? data : {};
        let result = new UserEmails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.emails)) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item.toJSON());
        }
        data["primaryEmail"] = this.primaryEmail;
        data["version"] = this.version;
        return data; 
    }
}

export interface IUserEmails {
    id?: string | undefined;
    emails?: UserEmail[] | undefined;
    primaryEmail?: string | undefined;
    version?: number;
}

export class UserEmail implements IUserEmail {
    email?: string | undefined;
    verified?: boolean;

    constructor(data?: IUserEmail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.verified = _data["verified"];
        }
    }

    static fromJS(data: any): UserEmail {
        data = typeof data === 'object' ? data : {};
        let result = new UserEmail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["verified"] = this.verified;
        return data; 
    }
}

export interface IUserEmail {
    email?: string | undefined;
    verified?: boolean;
}

export class UserEmailSettings implements IUserEmailSettings {
    email!: string;
    version?: number;

    constructor(data?: IUserEmailSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UserEmailSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UserEmailSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["version"] = this.version;
        return data; 
    }
}

export interface IUserEmailSettings {
    email: string;
    version?: number;
}

export class UserEmailVerificationToken extends Token implements IUserEmailVerificationToken {
    /** If is verifying the primary email. */
    primary?: boolean;
    /** If the email has been already been verified. */
    regression?: boolean;

    constructor(data?: IUserEmailVerificationToken) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.primary = _data["primary"];
            this.regression = _data["regression"];
        }
    }

    static fromJS(data: any): UserEmailVerificationToken {
        data = typeof data === 'object' ? data : {};
        let result = new UserEmailVerificationToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["primary"] = this.primary;
        data["regression"] = this.regression;
        super.toJSON(data);
        return data; 
    }
}

export interface IUserEmailVerificationToken extends IToken {
    /** If is verifying the primary email. */
    primary?: boolean;
    /** If the email has been already been verified. */
    regression?: boolean;
}

export class UserPhoneNumber implements IUserPhoneNumber {
    id?: string | undefined;
    number?: string | undefined;
    verified?: boolean;
    version?: number;

    constructor(data?: IUserPhoneNumber) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.number = _data["number"];
            this.verified = _data["verified"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UserPhoneNumber {
        data = typeof data === 'object' ? data : {};
        let result = new UserPhoneNumber();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["number"] = this.number;
        data["verified"] = this.verified;
        data["version"] = this.version;
        return data; 
    }
}

export interface IUserPhoneNumber {
    id?: string | undefined;
    number?: string | undefined;
    verified?: boolean;
    version?: number;
}

export class UpdateUserPhoneNumberSettings implements IUpdateUserPhoneNumberSettings {
    userVersion?: number;
    phoneNumber?: string | undefined;

    constructor(data?: IUpdateUserPhoneNumberSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userVersion = _data["userVersion"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): UpdateUserPhoneNumberSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserPhoneNumberSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userVersion"] = this.userVersion;
        data["phoneNumber"] = this.phoneNumber;
        return data; 
    }
}

export interface IUpdateUserPhoneNumberSettings {
    userVersion?: number;
    phoneNumber?: string | undefined;
}

export class VerificationRequestResult implements IVerificationRequestResult {
    sent?: boolean;
    waitSeconds?: number;

    constructor(data?: IVerificationRequestResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sent = _data["sent"];
            this.waitSeconds = _data["waitSeconds"];
        }
    }

    static fromJS(data: any): VerificationRequestResult {
        data = typeof data === 'object' ? data : {};
        let result = new VerificationRequestResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sent"] = this.sent;
        data["waitSeconds"] = this.waitSeconds;
        return data; 
    }
}

export interface IVerificationRequestResult {
    sent?: boolean;
    waitSeconds?: number;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}