//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class EmailClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param groupId (optional) 
     * @param statuses (optional) 
     * @param includeContents (optional) 
     */
    getAll(search: string | null | undefined, skip: number | undefined, take: number | undefined, groupId: string | null | undefined, statuses: EmailStatus[] | null | undefined, includeContents: boolean | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfEmail> {
        let url_ = this.baseUrl + "/v1/Email?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (groupId !== undefined && groupId !== null)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        if (statuses !== undefined && statuses !== null)
            statuses && statuses.forEach(item => { url_ += "statuses=" + encodeURIComponent("" + item) + "&"; });
        if (includeContents === null)
            throw new Error("The parameter 'includeContents' cannot be null.");
        else if (includeContents !== undefined)
            url_ += "includeContents=" + encodeURIComponent("" + includeContents) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfEmail> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfEmail.fromJS(resultData200);
            return Promise.resolve<ListOfEmail>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfEmail>(null as any);
    }

    /**
     * This is a webhook called by SendGrid
     */
    update( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Email";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param statuses (optional) 
     * @param includeContents (optional) 
     */
    getAllByUser(userId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, statuses: EmailStatus[] | null | undefined, includeContents: boolean | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfEmail> {
        let url_ = this.baseUrl + "/v1/Email/User/{userId}?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (statuses !== undefined && statuses !== null)
            statuses && statuses.forEach(item => { url_ += "statuses=" + encodeURIComponent("" + item) + "&"; });
        if (includeContents === null)
            throw new Error("The parameter 'includeContents' cannot be null.");
        else if (includeContents !== undefined)
            url_ += "includeContents=" + encodeURIComponent("" + includeContents) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllByUser(_response);
        });
    }

    protected processGetAllByUser(response: AxiosResponse): Promise<ListOfEmail> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfEmail.fromJS(resultData200);
            return Promise.resolve<ListOfEmail>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfEmail>(null as any);
    }

    get(emailId: string, cancelToken?: CancelToken | undefined): Promise<Email> {
        let url_ = this.baseUrl + "/v1/Email/{emailId}";
        if (emailId === undefined || emailId === null)
            throw new Error("The parameter 'emailId' must be defined.");
        url_ = url_.replace("{emailId}", encodeURIComponent("" + emailId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Email> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Email.fromJS(resultData200);
            return Promise.resolve<Email>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Email>(null as any);
    }
}

export class GroupAttendanceClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param status (optional) 
     */
    getAll(groupId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, status: AttendanceStatus | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfUserAttendance> {
        let url_ = this.baseUrl + "/v1/Group/{groupId}/Attendance?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (status !== undefined && status !== null)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfUserAttendance> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfUserAttendance.fromJS(resultData200);
            return Promise.resolve<ListOfUserAttendance>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfUserAttendance>(null as any);
    }

    get(groupId: string, userId: string, cancelToken?: CancelToken | undefined): Promise<UserAttendance> {
        let url_ = this.baseUrl + "/v1/Group/{groupId}/Attendance/{userId}";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<UserAttendance> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserAttendance.fromJS(resultData200);
            return Promise.resolve<UserAttendance>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserAttendance>(null as any);
    }

    update(groupId: string, userId: string, settings: UpdateAttendanceSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Group/{groupId}/Attendance/{userId}";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class MeetingClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param parentId (optional) 
     * @param from (optional) 
     * @param to (optional) 
     */
    getAll(search: string | null | undefined, skip: number | undefined, take: number | undefined, parentId: string | null | undefined, from: Date | null | undefined, to: Date | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfMeeting> {
        let url_ = this.baseUrl + "/v1/Meeting?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (parentId !== undefined && parentId !== null)
            url_ += "parentId=" + encodeURIComponent("" + parentId) + "&";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfMeeting> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfMeeting.fromJS(resultData200);
            return Promise.resolve<ListOfMeeting>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfMeeting>(null as any);
    }

    create(settings: CreateMeetingSettings, cancelToken?: CancelToken | undefined): Promise<Meeting> {
        let url_ = this.baseUrl + "/v1/Meeting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Meeting> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Meeting.fromJS(resultData200);
            return Promise.resolve<Meeting>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Meeting>(null as any);
    }

    get(meetingId: string, cancelToken?: CancelToken | undefined): Promise<Meeting> {
        let url_ = this.baseUrl + "/v1/Meeting/{meetingId}";
        if (meetingId === undefined || meetingId === null)
            throw new Error("The parameter 'meetingId' must be defined.");
        url_ = url_.replace("{meetingId}", encodeURIComponent("" + meetingId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Meeting> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Meeting.fromJS(resultData200);
            return Promise.resolve<Meeting>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Meeting>(null as any);
    }

    update(meetingId: string, settings: UpdateMeetingSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Meeting/{meetingId}";
        if (meetingId === undefined || meetingId === null)
            throw new Error("The parameter 'meetingId' must be defined.");
        url_ = url_.replace("{meetingId}", encodeURIComponent("" + meetingId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    delete(meetingId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Meeting/{meetingId}";
        if (meetingId === undefined || meetingId === null)
            throw new Error("The parameter 'meetingId' must be defined.");
        url_ = url_.replace("{meetingId}", encodeURIComponent("" + meetingId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    getAllFiles(meetingId: string, cancelToken?: CancelToken | undefined): Promise<ListOfFile> {
        let url_ = this.baseUrl + "/v1/Meeting/{meetingId}/File";
        if (meetingId === undefined || meetingId === null)
            throw new Error("The parameter 'meetingId' must be defined.");
        url_ = url_.replace("{meetingId}", encodeURIComponent("" + meetingId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllFiles(_response);
        });
    }

    protected processGetAllFiles(response: AxiosResponse): Promise<ListOfFile> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfFile.fromJS(resultData200);
            return Promise.resolve<ListOfFile>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfFile>(null as any);
    }

    createFile(meetingId: string, settings: CreateFileSettings, cancelToken?: CancelToken | undefined): Promise<File> {
        let url_ = this.baseUrl + "/v1/Meeting/{meetingId}/File";
        if (meetingId === undefined || meetingId === null)
            throw new Error("The parameter 'meetingId' must be defined.");
        url_ = url_.replace("{meetingId}", encodeURIComponent("" + meetingId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateFile(_response);
        });
    }

    protected processCreateFile(response: AxiosResponse): Promise<File> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = File.fromJS(resultData200);
            return Promise.resolve<File>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<File>(null as any);
    }

    getFile(meetingId: string, fileId: string, cancelToken?: CancelToken | undefined): Promise<File> {
        let url_ = this.baseUrl + "/v1/Meeting/{meetingId}/File/{fileId}";
        if (meetingId === undefined || meetingId === null)
            throw new Error("The parameter 'meetingId' must be defined.");
        url_ = url_.replace("{meetingId}", encodeURIComponent("" + meetingId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetFile(_response);
        });
    }

    protected processGetFile(response: AxiosResponse): Promise<File> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = File.fromJS(resultData200);
            return Promise.resolve<File>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<File>(null as any);
    }

    updateFile(meetingId: string, fileId: string, settings: UpdateFileSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Meeting/{meetingId}/File/{fileId}";
        if (meetingId === undefined || meetingId === null)
            throw new Error("The parameter 'meetingId' must be defined.");
        url_ = url_.replace("{meetingId}", encodeURIComponent("" + meetingId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateFile(_response);
        });
    }

    protected processUpdateFile(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    deleteFile(meetingId: string, fileId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Meeting/{meetingId}/File/{fileId}";
        if (meetingId === undefined || meetingId === null)
            throw new Error("The parameter 'meetingId' must be defined.");
        url_ = url_.replace("{meetingId}", encodeURIComponent("" + meetingId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteFile(_response);
        });
    }

    protected processDeleteFile(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    downloadFile(meetingId: string, fileId: string, cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/Meeting/{meetingId}/File/{fileId}/Download";
        if (meetingId === undefined || meetingId === null)
            throw new Error("The parameter 'meetingId' must be defined.");
        url_ = url_.replace("{meetingId}", encodeURIComponent("" + meetingId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadFile(_response);
        });
    }

    protected processDownloadFile(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class UserAttendanceClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param status (optional) 
     */
    getAll(userId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, status: AttendanceStatus | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfGroupAttendance> {
        let url_ = this.baseUrl + "/v1/User/{userId}/Attendance?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (status !== undefined && status !== null)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfGroupAttendance> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfGroupAttendance.fromJS(resultData200);
            return Promise.resolve<ListOfGroupAttendance>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfGroupAttendance>(null as any);
    }

    get(userId: string, groupId: string, cancelToken?: CancelToken | undefined): Promise<GroupAttendance> {
        let url_ = this.baseUrl + "/v1/User/{userId}/Attendance/{groupId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<GroupAttendance> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GroupAttendance.fromJS(resultData200);
            return Promise.resolve<GroupAttendance>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GroupAttendance>(null as any);
    }

    update(userId: string, groupId: string, settings: UpdateAttendanceSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/User/{userId}/Attendance/{groupId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class BackupClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAll(skip: number | undefined, take: number | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfBackup> {
        let url_ = this.baseUrl + "/v1/Backup?";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfBackup> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfBackup.fromJS(resultData200);
            return Promise.resolve<ListOfBackup>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfBackup>(null as any);
    }

    create( cancelToken?: CancelToken | undefined): Promise<Backup> {
        let url_ = this.baseUrl + "/v1/Backup";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Backup> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Backup.fromJS(resultData200);
            return Promise.resolve<Backup>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Backup>(null as any);
    }

    get(id: string, cancelToken?: CancelToken | undefined): Promise<Backup> {
        let url_ = this.baseUrl + "/v1/Backup/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Backup> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Backup.fromJS(resultData200);
            return Promise.resolve<Backup>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Backup>(null as any);
    }

    delete(id: string, searchDeep: boolean | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Backup/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (searchDeep === null)
            throw new Error("The parameter 'searchDeep' cannot be null.");
        else if (searchDeep !== undefined)
            url_ += "searchDeep=" + encodeURIComponent("" + searchDeep) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ExternalApplicationClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAll(search: string | null | undefined, skip: number | undefined, take: number | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfExternalApplication> {
        let url_ = this.baseUrl + "/v1/ExternalApplication?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfExternalApplication> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfExternalApplication.fromJS(resultData200);
            return Promise.resolve<ListOfExternalApplication>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfExternalApplication>(null as any);
    }

    create(settings: CreateExternalApplicationSettings, cancelToken?: CancelToken | undefined): Promise<ExternalApplication> {
        let url_ = this.baseUrl + "/v1/ExternalApplication";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ExternalApplication> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ExternalApplication.fromJS(resultData200);
            return Promise.resolve<ExternalApplication>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExternalApplication>(null as any);
    }

    get(applicationId: string, cancelToken?: CancelToken | undefined): Promise<ExternalApplication> {
        let url_ = this.baseUrl + "/v1/ExternalApplication/{applicationId}";
        if (applicationId === undefined || applicationId === null)
            throw new Error("The parameter 'applicationId' must be defined.");
        url_ = url_.replace("{applicationId}", encodeURIComponent("" + applicationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ExternalApplication> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ExternalApplication.fromJS(resultData200);
            return Promise.resolve<ExternalApplication>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExternalApplication>(null as any);
    }

    update(applicationId: string, settings: UpdateExternalApplicationSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/ExternalApplication/{applicationId}";
        if (applicationId === undefined || applicationId === null)
            throw new Error("The parameter 'applicationId' must be defined.");
        url_ = url_.replace("{applicationId}", encodeURIComponent("" + applicationId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    delete(applicationId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/ExternalApplication/{applicationId}";
        if (applicationId === undefined || applicationId === null)
            throw new Error("The parameter 'applicationId' must be defined.");
        url_ = url_.replace("{applicationId}", encodeURIComponent("" + applicationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ImageClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * Resizes the given image to the specified size.
     * @param uri (optional) Uri of the image to resize.
     * @param size (optional) The default width and height of the result image in pixels.
     * @param width (optional) A custom width to override the default size.
     * @param height (optional) A custom height to override the default size.
     * @return Uri of the resized image.
     */
    get(uri: string | null | undefined, size: number | null | undefined, width: number | null | undefined, height: number | null | undefined, cancelToken?: CancelToken | undefined): Promise<ResizedImage> {
        let url_ = this.baseUrl + "/v1/Image?";
        if (uri !== undefined && uri !== null)
            url_ += "uri=" + encodeURIComponent("" + uri) + "&";
        if (size !== undefined && size !== null)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (width !== undefined && width !== null)
            url_ += "width=" + encodeURIComponent("" + width) + "&";
        if (height !== undefined && height !== null)
            url_ += "height=" + encodeURIComponent("" + height) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ResizedImage> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ResizedImage.fromJS(resultData200);
            return Promise.resolve<ResizedImage>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResizedImage>(null as any);
    }
}

export class LogClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param logLevel (optional) 
     */
    getAll(search: string | null | undefined, skip: number | undefined, take: number | undefined, logLevel: number | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfLog> {
        let url_ = this.baseUrl + "/v1/Log?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (logLevel === null)
            throw new Error("The parameter 'logLevel' cannot be null.");
        else if (logLevel !== undefined)
            url_ += "logLevel=" + encodeURIComponent("" + logLevel) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfLog> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfLog.fromJS(resultData200);
            return Promise.resolve<ListOfLog>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfLog>(null as any);
    }

    get(logId: string, cancelToken?: CancelToken | undefined): Promise<Log> {
        let url_ = this.baseUrl + "/v1/Log/{logId}";
        if (logId === undefined || logId === null)
            throw new Error("The parameter 'logId' must be defined.");
        url_ = url_.replace("{logId}", encodeURIComponent("" + logId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Log> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Log.fromJS(resultData200);
            return Promise.resolve<Log>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Log>(null as any);
    }
}

export class MarkdownClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    preview(settings: MarkdownPreviewSettings, cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/Markdown/Preview";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPreview(_response);
        });
    }

    protected processPreview(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class PlatformClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    get( cancelToken?: CancelToken | undefined): Promise<Platform> {
        let url_ = this.baseUrl + "/v1/Platform";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Platform> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Platform.fromJS(resultData200);
            return Promise.resolve<Platform>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Platform>(null as any);
    }

    terms( cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/v1/Platform/Terms";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTerms(_response);
        });
    }

    protected processTerms(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    defaultSettings(environment: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/v1/Platform/DefaultSettings?";
        if (environment !== undefined && environment !== null)
            url_ += "environment=" + encodeURIComponent("" + environment) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDefaultSettings(_response);
        });
    }

    protected processDefaultSettings(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    status( cancelToken?: CancelToken | undefined): Promise<PlatformStatus> {
        let url_ = this.baseUrl + "/v1/Platform/Status";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStatus(_response);
        });
    }

    protected processStatus(response: AxiosResponse): Promise<PlatformStatus> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PlatformStatus.fromJS(resultData200);
            return Promise.resolve<PlatformStatus>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlatformStatus>(null as any);
    }
}

export class ProjectionClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    getAll( cancelToken?: CancelToken | undefined): Promise<ListOfProjectionBuild> {
        let url_ = this.baseUrl + "/v1/Projection";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfProjectionBuild> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfProjectionBuild.fromJS(resultData200);
            return Promise.resolve<ListOfProjectionBuild>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfProjectionBuild>(null as any);
    }

    get(projectionName: string, cancelToken?: CancelToken | undefined): Promise<ProjectionBuild> {
        let url_ = this.baseUrl + "/v1/Projection/{projectionName}";
        if (projectionName === undefined || projectionName === null)
            throw new Error("The parameter 'projectionName' must be defined.");
        url_ = url_.replace("{projectionName}", encodeURIComponent("" + projectionName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ProjectionBuild> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProjectionBuild.fromJS(resultData200);
            return Promise.resolve<ProjectionBuild>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProjectionBuild>(null as any);
    }
}

export class NotificationClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param type (optional) 
     * @param seen (optional) 
     * @param read (optional) 
     * @param from (optional) 
     * @param to (optional) 
     */
    getAll(skip: number | undefined, take: number | undefined, type: string | null | undefined, seen: boolean | null | undefined, read: boolean | null | undefined, from: Date | null | undefined, to: Date | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfNotification> {
        let url_ = this.baseUrl + "/v1/Notification?";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (seen !== undefined && seen !== null)
            url_ += "seen=" + encodeURIComponent("" + seen) + "&";
        if (read !== undefined && read !== null)
            url_ += "read=" + encodeURIComponent("" + read) + "&";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfNotification> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfNotification.fromJS(resultData200);
            return Promise.resolve<ListOfNotification>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfNotification>(null as any);
    }

    get(notificationId: string, cancelToken?: CancelToken | undefined): Promise<Notification> {
        let url_ = this.baseUrl + "/v1/Notification/{notificationId}";
        if (notificationId === undefined || notificationId === null)
            throw new Error("The parameter 'notificationId' must be defined.");
        url_ = url_.replace("{notificationId}", encodeURIComponent("" + notificationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Notification> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Notification.fromJS(resultData200);
            return Promise.resolve<Notification>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Notification>(null as any);
    }

    update(notificationId: string, settings: UpdateNotificationSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Notification/{notificationId}";
        if (notificationId === undefined || notificationId === null)
            throw new Error("The parameter 'notificationId' must be defined.");
        url_ = url_.replace("{notificationId}", encodeURIComponent("" + notificationId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    delete(notificationId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Notification/{notificationId}";
        if (notificationId === undefined || notificationId === null)
            throw new Error("The parameter 'notificationId' must be defined.");
        url_ = url_.replace("{notificationId}", encodeURIComponent("" + notificationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    markAllAsSeen( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Notification/MarkAllAsSeen";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMarkAllAsSeen(_response);
        });
    }

    protected processMarkAllAsSeen(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    markAllAsRead( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Notification/MarkAllAsRead";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMarkAllAsRead(_response);
        });
    }

    protected processMarkAllAsRead(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ScheduledEmailClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param groupId (optional) 
     */
    getAll(skip: number | undefined, take: number | undefined, groupId: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfScheduledEmail> {
        let url_ = this.baseUrl + "/v1/ScheduledEmail?";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (groupId !== undefined && groupId !== null)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfScheduledEmail> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfScheduledEmail.fromJS(resultData200);
            return Promise.resolve<ListOfScheduledEmail>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfScheduledEmail>(null as any);
    }

    /**
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAllForRecipient(recipientId: string, skip: number | undefined, take: number | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfScheduledEmail> {
        let url_ = this.baseUrl + "/v1/ScheduledEmail/Recipient/{recipientId}?";
        if (recipientId === undefined || recipientId === null)
            throw new Error("The parameter 'recipientId' must be defined.");
        url_ = url_.replace("{recipientId}", encodeURIComponent("" + recipientId));
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForRecipient(_response);
        });
    }

    protected processGetAllForRecipient(response: AxiosResponse): Promise<ListOfScheduledEmail> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfScheduledEmail.fromJS(resultData200);
            return Promise.resolve<ListOfScheduledEmail>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfScheduledEmail>(null as any);
    }

    get(scheduleId: string, cancelToken?: CancelToken | undefined): Promise<ScheduledEmail> {
        let url_ = this.baseUrl + "/v1/ScheduledEmail/{scheduleId}";
        if (scheduleId === undefined || scheduleId === null)
            throw new Error("The parameter 'scheduleId' must be defined.");
        url_ = url_.replace("{scheduleId}", encodeURIComponent("" + scheduleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ScheduledEmail> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ScheduledEmail.fromJS(resultData200);
            return Promise.resolve<ScheduledEmail>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ScheduledEmail>(null as any);
    }

    create(settings: CreateScheduledEmailSettings, cancelToken?: CancelToken | undefined): Promise<ScheduledEmail> {
        let url_ = this.baseUrl + "/v1/ScheduledEmail/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ScheduledEmail> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ScheduledEmail.fromJS(resultData200);
            return Promise.resolve<ScheduledEmail>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ScheduledEmail>(null as any);
    }

    update(scheduleId: string, settings: UpdateScheduledEmailSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/ScheduledEmail/{scheduleId}/Update";
        if (scheduleId === undefined || scheduleId === null)
            throw new Error("The parameter 'scheduleId' must be defined.");
        url_ = url_.replace("{scheduleId}", encodeURIComponent("" + scheduleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    delete(scheduleId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/ScheduledEmail/{scheduleId}/Delete";
        if (scheduleId === undefined || scheduleId === null)
            throw new Error("The parameter 'scheduleId' must be defined.");
        url_ = url_.replace("{scheduleId}", encodeURIComponent("" + scheduleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    leave(scheduleId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/ScheduledEmail/{scheduleId}/Leave";
        if (scheduleId === undefined || scheduleId === null)
            throw new Error("The parameter 'scheduleId' must be defined.");
        url_ = url_.replace("{scheduleId}", encodeURIComponent("" + scheduleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLeave(_response);
        });
    }

    protected processLeave(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ObservationContentClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param published (optional) 
     */
    getAll(definitionId: string, skip: number | undefined, take: number | undefined, published: boolean | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfObservationContent> {
        let url_ = this.baseUrl + "/v1/ObservationDefinition/{definitionId}/Content?";
        if (definitionId === undefined || definitionId === null)
            throw new Error("The parameter 'definitionId' must be defined.");
        url_ = url_.replace("{definitionId}", encodeURIComponent("" + definitionId));
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (published !== undefined && published !== null)
            url_ += "published=" + encodeURIComponent("" + published) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfObservationContent> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfObservationContent.fromJS(resultData200);
            return Promise.resolve<ListOfObservationContent>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfObservationContent>(null as any);
    }

    get(contentId: string, cancelToken?: CancelToken | undefined): Promise<ObservationContent> {
        let url_ = this.baseUrl + "/v1/ObservationContent/{contentId}";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ObservationContent> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ObservationContent.fromJS(resultData200);
            return Promise.resolve<ObservationContent>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ObservationContent>(null as any);
    }

    update(contentId: string, settings: UpdateObservationContentSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/ObservationContent/{contentId}";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    delete(contentId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/ObservationContent/{contentId}";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    create(settings: CreateObservationContentSettings, cancelToken?: CancelToken | undefined): Promise<ObservationContent> {
        let url_ = this.baseUrl + "/v1/ObservationContent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ObservationContent> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ObservationContent.fromJS(resultData200);
            return Promise.resolve<ObservationContent>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ObservationContent>(null as any);
    }

    publish(contentId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/ObservationContent/{contentId}/Publish";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPublish(_response);
        });
    }

    protected processPublish(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ObservationClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    getAllForArea(options: ObservationAreaOptions, cancelToken?: CancelToken | undefined): Promise<ListOfLocatableObservation> {
        let url_ = this.baseUrl + "/v1/Observation/GetAllForArea";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(options);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForArea(_response);
        });
    }

    protected processGetAllForArea(response: AxiosResponse): Promise<ListOfLocatableObservation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfLocatableObservation.fromJS(resultData200);
            return Promise.resolve<ListOfLocatableObservation>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfLocatableObservation>(null as any);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param definitionId (optional) 
     * @param from (optional) 
     * @param to (optional) 
     * @param anonymousUser (optional) 
     */
    getAllForGroup(groupId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, definitionId: string | null | undefined, from: Date | null | undefined, to: Date | null | undefined, anonymousUser: boolean | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfObservation> {
        let url_ = this.baseUrl + "/v1/Observation/Group/{groupId}?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (definitionId !== undefined && definitionId !== null)
            url_ += "definitionId=" + encodeURIComponent("" + definitionId) + "&";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        if (anonymousUser !== undefined && anonymousUser !== null)
            url_ += "anonymousUser=" + encodeURIComponent("" + anonymousUser) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForGroup(_response);
        });
    }

    protected processGetAllForGroup(response: AxiosResponse): Promise<ListOfObservation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfObservation.fromJS(resultData200);
            return Promise.resolve<ListOfObservation>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfObservation>(null as any);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param definitionId (optional) 
     * @param contentId (optional) 
     * @param groupId (optional) 
     * @param from (optional) 
     * @param to (optional) 
     */
    getAllForPublisher(publisherId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, definitionId: string | null | undefined, contentId: string | null | undefined, groupId: string | null | undefined, from: Date | null | undefined, to: Date | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfObservation> {
        let url_ = this.baseUrl + "/v1/Observation/Publisher/{publisherId}?";
        if (publisherId === undefined || publisherId === null)
            throw new Error("The parameter 'publisherId' must be defined.");
        url_ = url_.replace("{publisherId}", encodeURIComponent("" + publisherId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (definitionId !== undefined && definitionId !== null)
            url_ += "definitionId=" + encodeURIComponent("" + definitionId) + "&";
        if (contentId !== undefined && contentId !== null)
            url_ += "contentId=" + encodeURIComponent("" + contentId) + "&";
        if (groupId !== undefined && groupId !== null)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForPublisher(_response);
        });
    }

    protected processGetAllForPublisher(response: AxiosResponse): Promise<ListOfObservation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfObservation.fromJS(resultData200);
            return Promise.resolve<ListOfObservation>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfObservation>(null as any);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param from (optional) 
     * @param to (optional) 
     */
    getAllForUser(userId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, from: Date | null | undefined, to: Date | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfObservation> {
        let url_ = this.baseUrl + "/v1/Observation/User/{userId}?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForUser(_response);
        });
    }

    protected processGetAllForUser(response: AxiosResponse): Promise<ListOfObservation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfObservation.fromJS(resultData200);
            return Promise.resolve<ListOfObservation>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfObservation>(null as any);
    }

    get(observationId: string, cancelToken?: CancelToken | undefined): Promise<Observation> {
        let url_ = this.baseUrl + "/v1/Observation/{observationId}";
        if (observationId === undefined || observationId === null)
            throw new Error("The parameter 'observationId' must be defined.");
        url_ = url_.replace("{observationId}", encodeURIComponent("" + observationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Observation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Observation.fromJS(resultData200);
            return Promise.resolve<Observation>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Observation>(null as any);
    }

    update(observationId: string, settings: UpdateObservationSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Observation/{observationId}";
        if (observationId === undefined || observationId === null)
            throw new Error("The parameter 'observationId' must be defined.");
        url_ = url_.replace("{observationId}", encodeURIComponent("" + observationId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    delete(observationId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Observation/{observationId}";
        if (observationId === undefined || observationId === null)
            throw new Error("The parameter 'observationId' must be defined.");
        url_ = url_.replace("{observationId}", encodeURIComponent("" + observationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    create(settings: CreateObservationSettings, cancelToken?: CancelToken | undefined): Promise<Observation> {
        let url_ = this.baseUrl + "/v1/Observation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Observation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Observation.fromJS(resultData200);
            return Promise.resolve<Observation>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Observation>(null as any);
    }

    /**
     * @deprecated
     */
    predict(observationContentId: string, settings: PredictObservationSettings, cancelToken?: CancelToken | undefined): Promise<CreateObservationSettings> {
        let url_ = this.baseUrl + "/v1/Observation/{observationContentId}/Predict";
        if (observationContentId === undefined || observationContentId === null)
            throw new Error("The parameter 'observationContentId' must be defined.");
        url_ = url_.replace("{observationContentId}", encodeURIComponent("" + observationContentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPredict(_response);
        });
    }

    protected processPredict(response: AxiosResponse): Promise<CreateObservationSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CreateObservationSettings.fromJS(resultData200);
            return Promise.resolve<CreateObservationSettings>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateObservationSettings>(null as any);
    }

    downloadFile(observationId: string, fileId: string, cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/Observation/{observationId}/File/{fileId}";
        if (observationId === undefined || observationId === null)
            throw new Error("The parameter 'observationId' must be defined.");
        url_ = url_.replace("{observationId}", encodeURIComponent("" + observationId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadFile(_response);
        });
    }

    protected processDownloadFile(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class ObservationDefinitionClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param programId (optional) - null/empty to show all
    - program ID to filter to specific program
    - "none" to filter to items not in any program
     */
    getAllForPublisher(publisherId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, programId: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfObservationDefinition> {
        let url_ = this.baseUrl + "/v1/ObservationDefinition/Publisher/{publisherId}?";
        if (publisherId === undefined || publisherId === null)
            throw new Error("The parameter 'publisherId' must be defined.");
        url_ = url_.replace("{publisherId}", encodeURIComponent("" + publisherId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (programId !== undefined && programId !== null)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForPublisher(_response);
        });
    }

    protected processGetAllForPublisher(response: AxiosResponse): Promise<ListOfObservationDefinition> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfObservationDefinition.fromJS(resultData200);
            return Promise.resolve<ListOfObservationDefinition>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfObservationDefinition>(null as any);
    }

    create(settings: CreateObservationDefinitionSettings, cancelToken?: CancelToken | undefined): Promise<ObservationDefinition> {
        let url_ = this.baseUrl + "/v1/ObservationDefinition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ObservationDefinition> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ObservationDefinition.fromJS(resultData200);
            return Promise.resolve<ObservationDefinition>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ObservationDefinition>(null as any);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param consumerId (optional) 
     * @param publisherId (optional) 
     * @param programId (optional) - null/empty to show all
    - program ID to filter to specific program
    - "none" to filter to items not in any program
     * @param itemId (optional) 
     * @param activated (optional) 
     */
    getAllByActivation(search: string | null | undefined, skip: number | undefined, take: number | undefined, consumerId: string | null | undefined, publisherId: string | null | undefined, programId: string | null | undefined, itemId: string | null | undefined, activated: boolean | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfObservationDefinition> {
        let url_ = this.baseUrl + "/v1/ObservationDefinition?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (consumerId !== undefined && consumerId !== null)
            url_ += "consumerId=" + encodeURIComponent("" + consumerId) + "&";
        if (publisherId !== undefined && publisherId !== null)
            url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&";
        if (programId !== undefined && programId !== null)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        if (itemId !== undefined && itemId !== null)
            url_ += "itemId=" + encodeURIComponent("" + itemId) + "&";
        if (activated !== undefined && activated !== null)
            url_ += "activated=" + encodeURIComponent("" + activated) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllByActivation(_response);
        });
    }

    protected processGetAllByActivation(response: AxiosResponse): Promise<ListOfObservationDefinition> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfObservationDefinition.fromJS(resultData200);
            return Promise.resolve<ListOfObservationDefinition>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfObservationDefinition>(null as any);
    }

    update(observationDefinitionId: string, settings: UpdateObservationDefinitionSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/ObservationDefinition/{observationDefinitionId}";
        if (observationDefinitionId === undefined || observationDefinitionId === null)
            throw new Error("The parameter 'observationDefinitionId' must be defined.");
        url_ = url_.replace("{observationDefinitionId}", encodeURIComponent("" + observationDefinitionId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    delete(observationDefinitionId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/ObservationDefinition/{observationDefinitionId}";
        if (observationDefinitionId === undefined || observationDefinitionId === null)
            throw new Error("The parameter 'observationDefinitionId' must be defined.");
        url_ = url_.replace("{observationDefinitionId}", encodeURIComponent("" + observationDefinitionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param publisherId (optional) 
     * @param programId (optional) - null/empty to show all
    - program ID to filter to specific program
    - "none" to filter to items not in any program
     * @param countryCode (optional) 
     */
    getAllPublished(search: string | null | undefined, skip: number | undefined, take: number | undefined, publisherId: string | null | undefined, programId: string | null | undefined, countryCode: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfObservationDefinition> {
        let url_ = this.baseUrl + "/v1/ObservationDefinition/Published?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (publisherId !== undefined && publisherId !== null)
            url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&";
        if (programId !== undefined && programId !== null)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        if (countryCode !== undefined && countryCode !== null)
            url_ += "countryCode=" + encodeURIComponent("" + countryCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllPublished(_response);
        });
    }

    protected processGetAllPublished(response: AxiosResponse): Promise<ListOfObservationDefinition> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfObservationDefinition.fromJS(resultData200);
            return Promise.resolve<ListOfObservationDefinition>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfObservationDefinition>(null as any);
    }

    get(id: string, cancelToken?: CancelToken | undefined): Promise<ObservationDefinition> {
        let url_ = this.baseUrl + "/v1/ObservationDefinition/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ObservationDefinition> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ObservationDefinition.fromJS(resultData200);
            return Promise.resolve<ObservationDefinition>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ObservationDefinition>(null as any);
    }
}

export class ObservationFormClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAllForObservationContent(contentId: string, skip: number | undefined, take: number | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfObservationForm> {
        let url_ = this.baseUrl + "/v1/ObservationContent/{contentId}/Form?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForObservationContent(_response);
        });
    }

    protected processGetAllForObservationContent(response: AxiosResponse): Promise<ListOfObservationForm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfObservationForm.fromJS(resultData200);
            return Promise.resolve<ListOfObservationForm>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfObservationForm>(null as any);
    }

    get(observationFormId: string, cancelToken?: CancelToken | undefined): Promise<ObservationForm> {
        let url_ = this.baseUrl + "/v1/ObservationForm/{observationFormId}";
        if (observationFormId === undefined || observationFormId === null)
            throw new Error("The parameter 'observationFormId' must be defined.");
        url_ = url_.replace("{observationFormId}", encodeURIComponent("" + observationFormId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ObservationForm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ObservationForm.fromJS(resultData200);
            return Promise.resolve<ObservationForm>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ObservationForm>(null as any);
    }

    update(observationFormId: string, settings: UpdateObservationFormSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/ObservationForm/{observationFormId}";
        if (observationFormId === undefined || observationFormId === null)
            throw new Error("The parameter 'observationFormId' must be defined.");
        url_ = url_.replace("{observationFormId}", encodeURIComponent("" + observationFormId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    delete(observationFormId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/ObservationForm/{observationFormId}";
        if (observationFormId === undefined || observationFormId === null)
            throw new Error("The parameter 'observationFormId' must be defined.");
        url_ = url_.replace("{observationFormId}", encodeURIComponent("" + observationFormId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    create(settings: CreateObservationFormSettings, cancelToken?: CancelToken | undefined): Promise<ObservationForm> {
        let url_ = this.baseUrl + "/v1/ObservationForm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ObservationForm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ObservationForm.fromJS(resultData200);
            return Promise.resolve<ObservationForm>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ObservationForm>(null as any);
    }
}

export class ObservationMigrationClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * Change the ownership (publisher) of an given observation definition, all related data including 
    activations and observation will be transferred to the new publisher as well.
     */
    migrateObservationDefinition(observationDefinitionId: string, settings: MigrateObservationDefinitionSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/ObservationDefinition/{observationDefinitionId}/Migrate";
        if (observationDefinitionId === undefined || observationDefinitionId === null)
            throw new Error("The parameter 'observationDefinitionId' must be defined.");
        url_ = url_.replace("{observationDefinitionId}", encodeURIComponent("" + observationDefinitionId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMigrateObservationDefinition(_response);
        });
    }

    protected processMigrateObservationDefinition(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Create a duplicate copy of an observation definition under the same publisher.
            
    NOTE: this might run for a while if there are a lot of observations need to be migrated, when tested
    locally, 2400 observations took about 3 minutes to finish, as such, the command would be timeout but it
    will finish eventually, check the logs for progress.
     */
    duplicateObservationDefinition(observationDefinitionId: string, settings: DuplicateObservationDefinitionSettings, cancelToken?: CancelToken | undefined): Promise<ObservationDefinition> {
        let url_ = this.baseUrl + "/v1/ObservationDefinition/{observationDefinitionId}/Duplicate";
        if (observationDefinitionId === undefined || observationDefinitionId === null)
            throw new Error("The parameter 'observationDefinitionId' must be defined.");
        url_ = url_.replace("{observationDefinitionId}", encodeURIComponent("" + observationDefinitionId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDuplicateObservationDefinition(_response);
        });
    }

    protected processDuplicateObservationDefinition(response: AxiosResponse): Promise<ObservationDefinition> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ObservationDefinition.fromJS(resultData200);
            return Promise.resolve<ObservationDefinition>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ObservationDefinition>(null as any);
    }

    /**
     * @param definitionId (optional) 
     * @param groupId (optional) 
     * @deprecated
     */
    getObservationAnonymousUsers(definitionId: string | null | undefined, groupId: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/v1/Observation/AnonymousUser?";
        if (definitionId !== undefined && definitionId !== null)
            url_ += "definitionId=" + encodeURIComponent("" + definitionId) + "&";
        if (groupId !== undefined && groupId !== null)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetObservationAnonymousUsers(_response);
        });
    }

    protected processGetObservationAnonymousUsers(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<string[]>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(null as any);
    }

    /**
     * @deprecated
     */
    batchMergeObservationAnonymousUsers(settings: BatchMergeObservationAnonymousUsersSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Observation/AnonymousUser/BatchMerge";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBatchMergeObservationAnonymousUsers(_response);
        });
    }

    protected processBatchMergeObservationAnonymousUsers(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ObservationSettingsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param definitionId (optional) 
     * @param organisationId (optional) 
     */
    getAll(skip: number | undefined, take: number | undefined, definitionId: string | null | undefined, organisationId: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfObservationSettings> {
        let url_ = this.baseUrl + "/v1/ObservationSettings?";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (definitionId !== undefined && definitionId !== null)
            url_ += "definitionId=" + encodeURIComponent("" + definitionId) + "&";
        if (organisationId !== undefined && organisationId !== null)
            url_ += "organisationId=" + encodeURIComponent("" + organisationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfObservationSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfObservationSettings.fromJS(resultData200);
            return Promise.resolve<ListOfObservationSettings>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfObservationSettings>(null as any);
    }

    create(settings: CreateObservationSettingsSettings, cancelToken?: CancelToken | undefined): Promise<ObservationSettings> {
        let url_ = this.baseUrl + "/v1/ObservationSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ObservationSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ObservationSettings.fromJS(resultData200);
            return Promise.resolve<ObservationSettings>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ObservationSettings>(null as any);
    }

    get(settingsId: string, cancelToken?: CancelToken | undefined): Promise<ObservationSettings> {
        let url_ = this.baseUrl + "/v1/ObservationSettings/{settingsId}";
        if (settingsId === undefined || settingsId === null)
            throw new Error("The parameter 'settingsId' must be defined.");
        url_ = url_.replace("{settingsId}", encodeURIComponent("" + settingsId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ObservationSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ObservationSettings.fromJS(resultData200);
            return Promise.resolve<ObservationSettings>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ObservationSettings>(null as any);
    }

    update(settingsId: string, settings: UpdateObservationSettingsSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/ObservationSettings/{settingsId}";
        if (settingsId === undefined || settingsId === null)
            throw new Error("The parameter 'settingsId' must be defined.");
        url_ = url_.replace("{settingsId}", encodeURIComponent("" + settingsId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    delete(settingsId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/ObservationSettings/{settingsId}";
        if (settingsId === undefined || settingsId === null)
            throw new Error("The parameter 'settingsId' must be defined.");
        url_ = url_.replace("{settingsId}", encodeURIComponent("" + settingsId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class CustomerClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    get(customerId: string, cancelToken?: CancelToken | undefined): Promise<Customer> {
        let url_ = this.baseUrl + "/v1/Customer/{customerId}";
        if (customerId === undefined || customerId === null)
            throw new Error("The parameter 'customerId' must be defined.");
        url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Customer> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Customer.fromJS(resultData200);
            return Promise.resolve<Customer>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Customer>(null as any);
    }

    getForUser(userId: string, cancelToken?: CancelToken | undefined): Promise<Customer> {
        let url_ = this.baseUrl + "/v1/Customer/User/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetForUser(_response);
        });
    }

    protected processGetForUser(response: AxiosResponse): Promise<Customer> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Customer.fromJS(resultData200);
            return Promise.resolve<Customer>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Customer>(null as any);
    }
}

export class MerchantClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    get(merchantId: string, cancelToken?: CancelToken | undefined): Promise<Merchant> {
        let url_ = this.baseUrl + "/v1/Merchant/{merchantId}";
        if (merchantId === undefined || merchantId === null)
            throw new Error("The parameter 'merchantId' must be defined.");
        url_ = url_.replace("{merchantId}", encodeURIComponent("" + merchantId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Merchant> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Merchant.fromJS(resultData200);
            return Promise.resolve<Merchant>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Merchant>(null as any);
    }

    getForOrganisation(organisationId: string, cancelToken?: CancelToken | undefined): Promise<Merchant> {
        let url_ = this.baseUrl + "/v1/Merchant/Organisation/{organisationId}";
        if (organisationId === undefined || organisationId === null)
            throw new Error("The parameter 'organisationId' must be defined.");
        url_ = url_.replace("{organisationId}", encodeURIComponent("" + organisationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetForOrganisation(_response);
        });
    }

    protected processGetForOrganisation(response: AxiosResponse): Promise<Merchant> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Merchant.fromJS(resultData200);
            return Promise.resolve<Merchant>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Merchant>(null as any);
    }

    createUrl(publisherId: string | null | undefined, redirectUrl: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/v1/Merchant/CreateUrl?";
        if (publisherId !== undefined && publisherId !== null)
            url_ += "PublisherId=" + encodeURIComponent("" + publisherId) + "&";
        if (redirectUrl !== undefined && redirectUrl !== null)
            url_ += "RedirectUrl=" + encodeURIComponent("" + redirectUrl) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateUrl(_response);
        });
    }

    protected processCreateUrl(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    create(scope: string | null | undefined, state: string | null | undefined, code: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/Merchant?";
        if (scope !== undefined && scope !== null)
            url_ += "scope=" + encodeURIComponent("" + scope) + "&";
        if (state !== undefined && state !== null)
            url_ += "state=" + encodeURIComponent("" + state) + "&";
        if (code !== undefined && code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class PaymentClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    get(paymentId: string, cancelToken?: CancelToken | undefined): Promise<Payment> {
        let url_ = this.baseUrl + "/v1/Payment/{paymentId}";
        if (paymentId === undefined || paymentId === null)
            throw new Error("The parameter 'paymentId' must be defined.");
        url_ = url_.replace("{paymentId}", encodeURIComponent("" + paymentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Payment> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Payment.fromJS(resultData200);
            return Promise.resolve<Payment>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Payment>(null as any);
    }

    create(settings: CreatePaymentSettings, cancelToken?: CancelToken | undefined): Promise<Payment> {
        let url_ = this.baseUrl + "/v1/Payment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Payment> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Payment.fromJS(resultData200);
            return Promise.resolve<Payment>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Payment>(null as any);
    }
}

export class PaymentSettingsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    publicKey( cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/v1/PaymentSettings/PublicKey";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPublicKey(_response);
        });
    }

    protected processPublicKey(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    regions( cancelToken?: CancelToken | undefined): Promise<Region[]> {
        let url_ = this.baseUrl + "/v1/PaymentSettings/Regions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRegions(_response);
        });
    }

    protected processRegions(response: AxiosResponse): Promise<Region[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Region.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Region[]>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Region[]>(null as any);
    }

    countries( cancelToken?: CancelToken | undefined): Promise<Country[]> {
        let url_ = this.baseUrl + "/v1/PaymentSettings/Countries";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCountries(_response);
        });
    }

    protected processCountries(response: AxiosResponse): Promise<Country[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Country.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Country[]>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Country[]>(null as any);
    }

    currencies( cancelToken?: CancelToken | undefined): Promise<Currency[]> {
        let url_ = this.baseUrl + "/v1/PaymentSettings/Currencies";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCurrencies(_response);
        });
    }

    protected processCurrencies(response: AxiosResponse): Promise<Currency[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Currency.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Currency[]>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Currency[]>(null as any);
    }
}

export class ProductClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param publisherId (optional) 
     * @param countryCode (optional) 
     */
    getAll(search: string | null | undefined, skip: number | undefined, take: number | undefined, publisherId: string | null | undefined, countryCode: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<Product> {
        let url_ = this.baseUrl + "/v1/Product?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (publisherId !== undefined && publisherId !== null)
            url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&";
        if (countryCode !== undefined && countryCode !== null)
            url_ += "countryCode=" + encodeURIComponent("" + countryCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<Product> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Product.fromJS(resultData200);
            return Promise.resolve<Product>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Product>(null as any);
    }

    create(settings: CreateProductSettings, cancelToken?: CancelToken | undefined): Promise<Product> {
        let url_ = this.baseUrl + "/v1/Product";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Product> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Product.fromJS(resultData200);
            return Promise.resolve<Product>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Product>(null as any);
    }

    get(productId: string, cancelToken?: CancelToken | undefined): Promise<Product> {
        let url_ = this.baseUrl + "/v1/Product/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Product> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Product.fromJS(resultData200);
            return Promise.resolve<Product>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Product>(null as any);
    }

    update(productId: string, settings: UpdateProductSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Product/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    delete(productId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Product/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class PublisherClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAll(search: string | null | undefined, skip: number | undefined, take: number | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfPublisher> {
        let url_ = this.baseUrl + "/v1/Publisher?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfPublisher> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfPublisher.fromJS(resultData200);
            return Promise.resolve<ListOfPublisher>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfPublisher>(null as any);
    }

    get(publisherId: string, cancelToken?: CancelToken | undefined): Promise<Publisher> {
        let url_ = this.baseUrl + "/v1/Publisher/{publisherId}";
        if (publisherId === undefined || publisherId === null)
            throw new Error("The parameter 'publisherId' must be defined.");
        url_ = url_.replace("{publisherId}", encodeURIComponent("" + publisherId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Publisher> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Publisher.fromJS(resultData200);
            return Promise.resolve<Publisher>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Publisher>(null as any);
    }

    request(publisherId: string, settings: RequestPublisherSettings, cancelToken?: CancelToken | undefined): Promise<Publisher> {
        let url_ = this.baseUrl + "/v1/Publisher/{publisherId}/Request";
        if (publisherId === undefined || publisherId === null)
            throw new Error("The parameter 'publisherId' must be defined.");
        url_ = url_.replace("{publisherId}", encodeURIComponent("" + publisherId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRequest(_response);
        });
    }

    protected processRequest(response: AxiosResponse): Promise<Publisher> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Publisher.fromJS(resultData200);
            return Promise.resolve<Publisher>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Publisher>(null as any);
    }

    approve(publisherId: string, settings: ApprovePublisherSettings, cancelToken?: CancelToken | undefined): Promise<Publisher> {
        let url_ = this.baseUrl + "/v1/Publisher/{publisherId}/Approve";
        if (publisherId === undefined || publisherId === null)
            throw new Error("The parameter 'publisherId' must be defined.");
        url_ = url_.replace("{publisherId}", encodeURIComponent("" + publisherId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processApprove(_response);
        });
    }

    protected processApprove(response: AxiosResponse): Promise<Publisher> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Publisher.fromJS(resultData200);
            return Promise.resolve<Publisher>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Publisher>(null as any);
    }
}

export class StripeClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    event( cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/Stripe/Event";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEvent(_response);
        });
    }

    protected processEvent(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class TaskFileClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    getAll(taskId: string, cancelToken?: CancelToken | undefined): Promise<ListOfFile> {
        let url_ = this.baseUrl + "/v1/Task/{taskId}/File";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfFile> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfFile.fromJS(resultData200);
            return Promise.resolve<ListOfFile>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfFile>(null as any);
    }

    create(taskId: string, settings: CreateFileSettings, cancelToken?: CancelToken | undefined): Promise<File> {
        let url_ = this.baseUrl + "/v1/Task/{taskId}/File";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<File> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = File.fromJS(resultData200);
            return Promise.resolve<File>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<File>(null as any);
    }

    get(taskId: string, fileId: string, cancelToken?: CancelToken | undefined): Promise<File> {
        let url_ = this.baseUrl + "/v1/Task/{taskId}/File/{fileId}";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<File> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = File.fromJS(resultData200);
            return Promise.resolve<File>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<File>(null as any);
    }

    update(taskId: string, fileId: string, settings: UpdateFileSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Task/{taskId}/File/{fileId}";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    delete(taskId: string, fileId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Task/{taskId}/File/{fileId}";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    download(taskId: string, fileId: string, cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/Task/{taskId}/File/{fileId}/Download";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownload(_response);
        });
    }

    protected processDownload(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class ImplementationClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param publisherId (optional) 
     * @param consumerId (optional) 
     * @param teamId (optional) 
     */
    getAll(search: string | null | undefined, skip: number | undefined, take: number | undefined, publisherId: string | null | undefined, consumerId: string | null | undefined, teamId: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfImplementation> {
        let url_ = this.baseUrl + "/v1/Implementation?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (publisherId !== undefined && publisherId !== null)
            url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&";
        if (consumerId !== undefined && consumerId !== null)
            url_ += "consumerId=" + encodeURIComponent("" + consumerId) + "&";
        if (teamId !== undefined && teamId !== null)
            url_ += "teamId=" + encodeURIComponent("" + teamId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfImplementation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfImplementation.fromJS(resultData200);
            return Promise.resolve<ListOfImplementation>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfImplementation>(null as any);
    }

    create(settings: CreateImplementationSettings, cancelToken?: CancelToken | undefined): Promise<Implementation> {
        let url_ = this.baseUrl + "/v1/Implementation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Implementation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Implementation.fromJS(resultData200);
            return Promise.resolve<Implementation>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Implementation>(null as any);
    }

    get(implementationId: string, cancelToken?: CancelToken | undefined): Promise<Implementation> {
        let url_ = this.baseUrl + "/v1/Implementation/{implementationId}";
        if (implementationId === undefined || implementationId === null)
            throw new Error("The parameter 'implementationId' must be defined.");
        url_ = url_.replace("{implementationId}", encodeURIComponent("" + implementationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Implementation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Implementation.fromJS(resultData200);
            return Promise.resolve<Implementation>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Implementation>(null as any);
    }

    update(implementationId: string, settings: UpdateImplementationSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Implementation/{implementationId}";
        if (implementationId === undefined || implementationId === null)
            throw new Error("The parameter 'implementationId' must be defined.");
        url_ = url_.replace("{implementationId}", encodeURIComponent("" + implementationId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    delete(implementationId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Implementation/{implementationId}";
        if (implementationId === undefined || implementationId === null)
            throw new Error("The parameter 'implementationId' must be defined.");
        url_ = url_.replace("{implementationId}", encodeURIComponent("" + implementationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAllTasks(implementationId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfTask> {
        let url_ = this.baseUrl + "/v1/Implementation/{implementationId}/Task?";
        if (implementationId === undefined || implementationId === null)
            throw new Error("The parameter 'implementationId' must be defined.");
        url_ = url_.replace("{implementationId}", encodeURIComponent("" + implementationId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllTasks(_response);
        });
    }

    protected processGetAllTasks(response: AxiosResponse): Promise<ListOfTask> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfTask.fromJS(resultData200);
            return Promise.resolve<ListOfTask>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfTask>(null as any);
    }
}

export class ItemActivationClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param itemType (optional) 
     * @param programId (optional) - null/empty to show all
    - program ID to filter to specific program
    - "none" to filter to items not in any program
     * @param consumerId (optional) 
     * @param includeDeactivated (optional) 
     */
    getAllForPublisher(publisherId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, itemType: string | null | undefined, programId: string | null | undefined, consumerId: string | null | undefined, includeDeactivated: boolean | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfItemActivation> {
        let url_ = this.baseUrl + "/v1/ItemActivation/Publisher/{publisherId}?";
        if (publisherId === undefined || publisherId === null)
            throw new Error("The parameter 'publisherId' must be defined.");
        url_ = url_.replace("{publisherId}", encodeURIComponent("" + publisherId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (itemType !== undefined && itemType !== null)
            url_ += "itemType=" + encodeURIComponent("" + itemType) + "&";
        if (programId !== undefined && programId !== null)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        if (consumerId !== undefined && consumerId !== null)
            url_ += "consumerId=" + encodeURIComponent("" + consumerId) + "&";
        if (includeDeactivated !== undefined && includeDeactivated !== null)
            url_ += "includeDeactivated=" + encodeURIComponent("" + includeDeactivated) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForPublisher(_response);
        });
    }

    protected processGetAllForPublisher(response: AxiosResponse): Promise<ListOfItemActivation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfItemActivation.fromJS(resultData200);
            return Promise.resolve<ListOfItemActivation>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfItemActivation>(null as any);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param consumerId (optional) 
     * @param itemType (optional) 
     * @param itemId (optional) 
     * @param programId (optional) - null/empty to show all
    - program ID to filter to specific program
    - "none" to filter to items not in any program
     * @param publisherId (optional) 
     */
    getAllByActivation(search: string | null | undefined, skip: number | undefined, take: number | undefined, consumerId: string | null | undefined, itemType: string | null | undefined, itemId: string | null | undefined, programId: string | null | undefined, publisherId: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfItemActivation> {
        let url_ = this.baseUrl + "/v1/ItemActivation?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (consumerId !== undefined && consumerId !== null)
            url_ += "consumerId=" + encodeURIComponent("" + consumerId) + "&";
        if (itemType !== undefined && itemType !== null)
            url_ += "itemType=" + encodeURIComponent("" + itemType) + "&";
        if (itemId !== undefined && itemId !== null)
            url_ += "itemId=" + encodeURIComponent("" + itemId) + "&";
        if (programId !== undefined && programId !== null)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        if (publisherId !== undefined && publisherId !== null)
            url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllByActivation(_response);
        });
    }

    protected processGetAllByActivation(response: AxiosResponse): Promise<ListOfItemActivation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfItemActivation.fromJS(resultData200);
            return Promise.resolve<ListOfItemActivation>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfItemActivation>(null as any);
    }

    create(consumerId: string | null | undefined, itemId: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<ItemActivation> {
        let url_ = this.baseUrl + "/v1/ItemActivation?";
        if (consumerId !== undefined && consumerId !== null)
            url_ += "consumerId=" + encodeURIComponent("" + consumerId) + "&";
        if (itemId !== undefined && itemId !== null)
            url_ += "itemId=" + encodeURIComponent("" + itemId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ItemActivation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ItemActivation.fromJS(resultData200);
            return Promise.resolve<ItemActivation>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ItemActivation>(null as any);
    }

    get(itemActivationId: string, cancelToken?: CancelToken | undefined): Promise<ItemActivation> {
        let url_ = this.baseUrl + "/v1/ItemActivation/{itemActivationId}";
        if (itemActivationId === undefined || itemActivationId === null)
            throw new Error("The parameter 'itemActivationId' must be defined.");
        url_ = url_.replace("{itemActivationId}", encodeURIComponent("" + itemActivationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ItemActivation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ItemActivation.fromJS(resultData200);
            return Promise.resolve<ItemActivation>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ItemActivation>(null as any);
    }

    update(itemActivationId: string, activated: boolean | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/ItemActivation/{itemActivationId}?";
        if (itemActivationId === undefined || itemActivationId === null)
            throw new Error("The parameter 'itemActivationId' must be defined.");
        url_ = url_.replace("{itemActivationId}", encodeURIComponent("" + itemActivationId));
        if (activated === null)
            throw new Error("The parameter 'activated' cannot be null.");
        else if (activated !== undefined)
            url_ += "activated=" + encodeURIComponent("" + activated) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    get2(itemId: string, consumerId: string, cancelToken?: CancelToken | undefined): Promise<ItemActivation> {
        let url_ = this.baseUrl + "/v1/ItemActivation/Item/{itemId}/Consumer/{consumerId}";
        if (itemId === undefined || itemId === null)
            throw new Error("The parameter 'itemId' must be defined.");
        url_ = url_.replace("{itemId}", encodeURIComponent("" + itemId));
        if (consumerId === undefined || consumerId === null)
            throw new Error("The parameter 'consumerId' must be defined.");
        url_ = url_.replace("{consumerId}", encodeURIComponent("" + consumerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet2(_response);
        });
    }

    protected processGet2(response: AxiosResponse): Promise<ItemActivation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ItemActivation.fromJS(resultData200);
            return Promise.resolve<ItemActivation>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ItemActivation>(null as any);
    }
}

export class ProgramActivationClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param programId (optional) 
     * @param consumerId (optional) 
     */
    getAll(search: string | null | undefined, skip: number | undefined, take: number | undefined, programId: string | null | undefined, consumerId: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfProgramActivation> {
        let url_ = this.baseUrl + "/v1/ProgramActivation?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (programId !== undefined && programId !== null)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        if (consumerId !== undefined && consumerId !== null)
            url_ += "consumerId=" + encodeURIComponent("" + consumerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfProgramActivation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfProgramActivation.fromJS(resultData200);
            return Promise.resolve<ListOfProgramActivation>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfProgramActivation>(null as any);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param programId (optional) 
     */
    getAllForPublisher(publisherId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, programId: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfProgramActivation> {
        let url_ = this.baseUrl + "/v1/ProgramActivation/Publisher/{publisherId}?";
        if (publisherId === undefined || publisherId === null)
            throw new Error("The parameter 'publisherId' must be defined.");
        url_ = url_.replace("{publisherId}", encodeURIComponent("" + publisherId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (programId !== undefined && programId !== null)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForPublisher(_response);
        });
    }

    protected processGetAllForPublisher(response: AxiosResponse): Promise<ListOfProgramActivation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfProgramActivation.fromJS(resultData200);
            return Promise.resolve<ListOfProgramActivation>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfProgramActivation>(null as any);
    }

    get(id: string, cancelToken?: CancelToken | undefined): Promise<ProgramActivation> {
        let url_ = this.baseUrl + "/v1/ProgramActivation/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ProgramActivation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProgramActivation.fromJS(resultData200);
            return Promise.resolve<ProgramActivation>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProgramActivation>(null as any);
    }

    get2(programId: string, consumerId: string, cancelToken?: CancelToken | undefined): Promise<ProgramActivation> {
        let url_ = this.baseUrl + "/v1/ProgramActivation/Program/{programId}/Consumer/{consumerId}";
        if (programId === undefined || programId === null)
            throw new Error("The parameter 'programId' must be defined.");
        url_ = url_.replace("{programId}", encodeURIComponent("" + programId));
        if (consumerId === undefined || consumerId === null)
            throw new Error("The parameter 'consumerId' must be defined.");
        url_ = url_.replace("{consumerId}", encodeURIComponent("" + consumerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet2(_response);
        });
    }

    protected processGet2(response: AxiosResponse): Promise<ProgramActivation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProgramActivation.fromJS(resultData200);
            return Promise.resolve<ProgramActivation>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProgramActivation>(null as any);
    }

    createByPhase(settings: ActivateProgramPhaseSettings, cancelToken?: CancelToken | undefined): Promise<ProgramActivation> {
        let url_ = this.baseUrl + "/v1/ProgramActivation/ProgramPhase";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateByPhase(_response);
        });
    }

    protected processCreateByPhase(response: AxiosResponse): Promise<ProgramActivation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProgramActivation.fromJS(resultData200);
            return Promise.resolve<ProgramActivation>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProgramActivation>(null as any);
    }

    setCurrentPhase(programActivationId: string, programPhaseId: string, cancelToken?: CancelToken | undefined): Promise<ProgramActivation> {
        let url_ = this.baseUrl + "/v1/ProgramActivation/{programActivationId}/ProgramPhase/{programPhaseId}/SetCurrent";
        if (programActivationId === undefined || programActivationId === null)
            throw new Error("The parameter 'programActivationId' must be defined.");
        url_ = url_.replace("{programActivationId}", encodeURIComponent("" + programActivationId));
        if (programPhaseId === undefined || programPhaseId === null)
            throw new Error("The parameter 'programPhaseId' must be defined.");
        url_ = url_.replace("{programPhaseId}", encodeURIComponent("" + programPhaseId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSetCurrentPhase(_response);
        });
    }

    protected processSetCurrentPhase(response: AxiosResponse): Promise<ProgramActivation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProgramActivation.fromJS(resultData200);
            return Promise.resolve<ProgramActivation>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProgramActivation>(null as any);
    }

    deactivate(programActivationId: string, programPhaseId: string, cancelToken?: CancelToken | undefined): Promise<ProgramActivation> {
        let url_ = this.baseUrl + "/v1/ProgramActivation/{programActivationId}/ProgramPhase/{programPhaseId}/Deactivate";
        if (programActivationId === undefined || programActivationId === null)
            throw new Error("The parameter 'programActivationId' must be defined.");
        url_ = url_.replace("{programActivationId}", encodeURIComponent("" + programActivationId));
        if (programPhaseId === undefined || programPhaseId === null)
            throw new Error("The parameter 'programPhaseId' must be defined.");
        url_ = url_.replace("{programPhaseId}", encodeURIComponent("" + programPhaseId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeactivate(_response);
        });
    }

    protected processDeactivate(response: AxiosResponse): Promise<ProgramActivation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProgramActivation.fromJS(resultData200);
            return Promise.resolve<ProgramActivation>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProgramActivation>(null as any);
    }
}

export class ProgramClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAllForPublisher(publisherId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfProgram> {
        let url_ = this.baseUrl + "/v1/Program/Publisher/{publisherId}?";
        if (publisherId === undefined || publisherId === null)
            throw new Error("The parameter 'publisherId' must be defined.");
        url_ = url_.replace("{publisherId}", encodeURIComponent("" + publisherId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForPublisher(_response);
        });
    }

    protected processGetAllForPublisher(response: AxiosResponse): Promise<ListOfProgram> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfProgram.fromJS(resultData200);
            return Promise.resolve<ListOfProgram>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfProgram>(null as any);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param publisherId (optional) 
     * @param programId (optional) - null/empty to show all
    - program ID to filter to specific program
     * @param countryCode (optional) 
     */
    getAllPublished(search: string | null | undefined, skip: number | undefined, take: number | undefined, publisherId: string | null | undefined, programId: string | null | undefined, countryCode: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfProgram> {
        let url_ = this.baseUrl + "/v1/Program/Published?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (publisherId !== undefined && publisherId !== null)
            url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&";
        if (programId !== undefined && programId !== null)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        if (countryCode !== undefined && countryCode !== null)
            url_ += "countryCode=" + encodeURIComponent("" + countryCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllPublished(_response);
        });
    }

    protected processGetAllPublished(response: AxiosResponse): Promise<ListOfProgram> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfProgram.fromJS(resultData200);
            return Promise.resolve<ListOfProgram>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfProgram>(null as any);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param consumerId (optional) 
     * @param publisherId (optional) 
     * @param itemId (optional) 
     * @param activated (optional) 
     */
    getAllByActivation(search: string | null | undefined, skip: number | undefined, take: number | undefined, consumerId: string | null | undefined, publisherId: string | null | undefined, itemId: string | null | undefined, activated: boolean | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfProgram> {
        let url_ = this.baseUrl + "/v1/Program?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (consumerId !== undefined && consumerId !== null)
            url_ += "consumerId=" + encodeURIComponent("" + consumerId) + "&";
        if (publisherId !== undefined && publisherId !== null)
            url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&";
        if (itemId !== undefined && itemId !== null)
            url_ += "itemId=" + encodeURIComponent("" + itemId) + "&";
        if (activated !== undefined && activated !== null)
            url_ += "activated=" + encodeURIComponent("" + activated) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllByActivation(_response);
        });
    }

    protected processGetAllByActivation(response: AxiosResponse): Promise<ListOfProgram> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfProgram.fromJS(resultData200);
            return Promise.resolve<ListOfProgram>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfProgram>(null as any);
    }

    create(settings: CreateProgramSettings, cancelToken?: CancelToken | undefined): Promise<Program> {
        let url_ = this.baseUrl + "/v1/Program";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Program> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Program.fromJS(resultData200);
            return Promise.resolve<Program>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Program>(null as any);
    }

    get(id: string, cancelToken?: CancelToken | undefined): Promise<Program> {
        let url_ = this.baseUrl + "/v1/Program/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Program> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Program.fromJS(resultData200);
            return Promise.resolve<Program>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Program>(null as any);
    }

    update(programId: string, settings: UpdateProgramSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Program/{programId}";
        if (programId === undefined || programId === null)
            throw new Error("The parameter 'programId' must be defined.");
        url_ = url_.replace("{programId}", encodeURIComponent("" + programId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    delete(programId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Program/{programId}";
        if (programId === undefined || programId === null)
            throw new Error("The parameter 'programId' must be defined.");
        url_ = url_.replace("{programId}", encodeURIComponent("" + programId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ProgramPhaseClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    get(id: string, cancelToken?: CancelToken | undefined): Promise<ProgramPhase> {
        let url_ = this.baseUrl + "/v1/ProgramPhase/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ProgramPhase> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProgramPhase.fromJS(resultData200);
            return Promise.resolve<ProgramPhase>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProgramPhase>(null as any);
    }

    create(settings: CreateProgramPhaseSettings, cancelToken?: CancelToken | undefined): Promise<ProgramPhase> {
        let url_ = this.baseUrl + "/v1/ProgramPhase";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ProgramPhase> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProgramPhase.fromJS(resultData200);
            return Promise.resolve<ProgramPhase>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProgramPhase>(null as any);
    }

    update(programPhaseId: string, settings: UpdateProgramPhaseSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/ProgramPhase/{programPhaseId}";
        if (programPhaseId === undefined || programPhaseId === null)
            throw new Error("The parameter 'programPhaseId' must be defined.");
        url_ = url_.replace("{programPhaseId}", encodeURIComponent("" + programPhaseId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    delete(programPhaseId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/ProgramPhase/{programPhaseId}";
        if (programPhaseId === undefined || programPhaseId === null)
            throw new Error("The parameter 'programPhaseId' must be defined.");
        url_ = url_.replace("{programPhaseId}", encodeURIComponent("" + programPhaseId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class TaskCommentClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAll(taskId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfComment> {
        let url_ = this.baseUrl + "/v1/Task/{taskId}/Comment?";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfComment> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfComment.fromJS(resultData200);
            return Promise.resolve<ListOfComment>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfComment>(null as any);
    }

    create(taskId: string, settings: CreateCommentSettings, cancelToken?: CancelToken | undefined): Promise<Comment> {
        let url_ = this.baseUrl + "/v1/Task/{taskId}/Comment";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Comment> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Comment.fromJS(resultData200);
            return Promise.resolve<Comment>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Comment>(null as any);
    }

    get(taskId: string, commentId: string, cancelToken?: CancelToken | undefined): Promise<Comment> {
        let url_ = this.baseUrl + "/v1/Task/{taskId}/Comment/{commentId}";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Comment> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Comment.fromJS(resultData200);
            return Promise.resolve<Comment>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Comment>(null as any);
    }

    update(taskId: string, commentId: string, settings: UpdateCommentSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Task/{taskId}/Comment/{commentId}";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    delete(taskId: string, commentId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Task/{taskId}/Comment/{commentId}";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAllReplies(taskId: string, commentId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfComment> {
        let url_ = this.baseUrl + "/v1/Task/{taskId}/Comment/{commentId}/Reply?";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllReplies(_response);
        });
    }

    protected processGetAllReplies(response: AxiosResponse): Promise<ListOfComment> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfComment.fromJS(resultData200);
            return Promise.resolve<ListOfComment>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfComment>(null as any);
    }
}

export class TaskClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param implementationId (optional) 
     */
    getAll(search: string | null | undefined, skip: number | undefined, take: number | undefined, implementationId: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfTask> {
        let url_ = this.baseUrl + "/v1/Task?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (implementationId !== undefined && implementationId !== null)
            url_ += "implementationId=" + encodeURIComponent("" + implementationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfTask> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfTask.fromJS(resultData200);
            return Promise.resolve<ListOfTask>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfTask>(null as any);
    }

    create(settings: CreateTaskSettings, cancelToken?: CancelToken | undefined): Promise<Task> {
        let url_ = this.baseUrl + "/v1/Task";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Task> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Task.fromJS(resultData200);
            return Promise.resolve<Task>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Task>(null as any);
    }

    get(taskId: string, cancelToken?: CancelToken | undefined): Promise<Task> {
        let url_ = this.baseUrl + "/v1/Task/{taskId}";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Task> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Task.fromJS(resultData200);
            return Promise.resolve<Task>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Task>(null as any);
    }

    update(taskId: string, settings: UpdateTaskSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Task/{taskId}";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    delete(taskId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Task/{taskId}";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class SharingClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    getByAlias(aliasId: string, cancelToken?: CancelToken | undefined): Promise<Sharing> {
        let url_ = this.baseUrl + "/v1/Sharing/Alias/{aliasId}";
        if (aliasId === undefined || aliasId === null)
            throw new Error("The parameter 'aliasId' must be defined.");
        url_ = url_.replace("{aliasId}", encodeURIComponent("" + aliasId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetByAlias(_response);
        });
    }

    protected processGetByAlias(response: AxiosResponse): Promise<Sharing> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Sharing.fromJS(resultData200);
            return Promise.resolve<Sharing>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Sharing>(null as any);
    }

    delete(sharingId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Sharing/{sharingId}";
        if (sharingId === undefined || sharingId === null)
            throw new Error("The parameter 'sharingId' must be defined.");
        url_ = url_.replace("{sharingId}", encodeURIComponent("" + sharingId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAllGroupInvitationsForGroup(groupId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfSharing> {
        let url_ = this.baseUrl + "/v1/Sharing/GroupInvitation/Group/{groupId}?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllGroupInvitationsForGroup(_response);
        });
    }

    protected processGetAllGroupInvitationsForGroup(response: AxiosResponse): Promise<ListOfSharing> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfSharing.fromJS(resultData200);
            return Promise.resolve<ListOfSharing>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfSharing>(null as any);
    }

    createForGroupInvitation(settings: CreateGroupInvitationSharingSettings, cancelToken?: CancelToken | undefined): Promise<Sharing> {
        let url_ = this.baseUrl + "/v1/Sharing/GroupInvitation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateForGroupInvitation(_response);
        });
    }

    protected processCreateForGroupInvitation(response: AxiosResponse): Promise<Sharing> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Sharing.fromJS(resultData200);
            return Promise.resolve<Sharing>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Sharing>(null as any);
    }
}

export class TicketClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param userId (optional) 
     */
    getAll(search: string | null | undefined, skip: number | undefined, take: number | undefined, userId: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfTicket> {
        let url_ = this.baseUrl + "/v1/Ticket?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfTicket> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfTicket.fromJS(resultData200);
            return Promise.resolve<ListOfTicket>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfTicket>(null as any);
    }

    create(settings: CreateTicketSettings, cancelToken?: CancelToken | undefined): Promise<Ticket> {
        let url_ = this.baseUrl + "/v1/Ticket";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Ticket> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Ticket.fromJS(resultData200);
            return Promise.resolve<Ticket>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Ticket>(null as any);
    }

    get(ticketId: string, cancelToken?: CancelToken | undefined): Promise<Ticket> {
        let url_ = this.baseUrl + "/v1/Ticket/{ticketId}";
        if (ticketId === undefined || ticketId === null)
            throw new Error("The parameter 'ticketId' must be defined.");
        url_ = url_.replace("{ticketId}", encodeURIComponent("" + ticketId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Ticket> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Ticket.fromJS(resultData200);
            return Promise.resolve<Ticket>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Ticket>(null as any);
    }

    update(ticketId: string, settings: UpdateTicketSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Ticket/{ticketId}";
        if (ticketId === undefined || ticketId === null)
            throw new Error("The parameter 'ticketId' must be defined.");
        url_ = url_.replace("{ticketId}", encodeURIComponent("" + ticketId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class SurveyContentClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAll(surveyId: string, skip: number | undefined, take: number | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfSurveyContent> {
        let url_ = this.baseUrl + "/v1/Survey/{surveyId}/Content?";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfSurveyContent> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfSurveyContent.fromJS(resultData200);
            return Promise.resolve<ListOfSurveyContent>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfSurveyContent>(null as any);
    }

    create(surveyId: string, settings: CreateSurveyContentSettings, cancelToken?: CancelToken | undefined): Promise<SurveyContent> {
        let url_ = this.baseUrl + "/v1/Survey/{surveyId}/Content";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<SurveyContent> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SurveyContent.fromJS(resultData200);
            return Promise.resolve<SurveyContent>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SurveyContent>(null as any);
    }

    get(surveyId: string, contentId: string, cancelToken?: CancelToken | undefined): Promise<SurveyContent> {
        let url_ = this.baseUrl + "/v1/Survey/{surveyId}/Content/{contentId}";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<SurveyContent> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SurveyContent.fromJS(resultData200);
            return Promise.resolve<SurveyContent>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SurveyContent>(null as any);
    }

    update(surveyId: string, contentId: string, settings: UpdateSurveyContentSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Survey/{surveyId}/Content/{contentId}";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    delete(surveyId: string, contentId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Survey/{surveyId}/Content/{contentId}";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    publish(surveyId: string | null | undefined, contentId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/{contentId}/Publish?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        if (surveyId !== undefined && surveyId !== null)
            url_ += "surveyId=" + encodeURIComponent("" + surveyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPublish(_response);
        });
    }

    protected processPublish(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    questionTypes( cancelToken?: CancelToken | undefined): Promise<SurveyQuestionTypes> {
        let url_ = this.baseUrl + "/v1/SurveyContent/QuestionTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processQuestionTypes(_response);
        });
    }

    protected processQuestionTypes(response: AxiosResponse): Promise<SurveyQuestionTypes> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SurveyQuestionTypes.fromJS(resultData200);
            return Promise.resolve<SurveyQuestionTypes>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SurveyQuestionTypes>(null as any);
    }

    answerTypes( cancelToken?: CancelToken | undefined): Promise<SurveyAnswerTypes> {
        let url_ = this.baseUrl + "/v1/SurveyContent/AnswerTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAnswerTypes(_response);
        });
    }

    protected processAnswerTypes(response: AxiosResponse): Promise<SurveyAnswerTypes> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SurveyAnswerTypes.fromJS(resultData200);
            return Promise.resolve<SurveyAnswerTypes>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SurveyAnswerTypes>(null as any);
    }

    example( cancelToken?: CancelToken | undefined): Promise<SurveySettings> {
        let url_ = this.baseUrl + "/v1/SurveyContent/Example";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExample(_response);
        });
    }

    protected processExample(response: AxiosResponse): Promise<SurveySettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SurveySettings.fromJS(resultData200);
            return Promise.resolve<SurveySettings>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SurveySettings>(null as any);
    }

    schema( cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/SurveyContent/Schema";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSchema(_response);
        });
    }

    protected processSchema(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class SurveyClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAllForPublisher(publisherId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfSurvey> {
        let url_ = this.baseUrl + "/v1/Survey/Publisher/{publisherId}?";
        if (publisherId === undefined || publisherId === null)
            throw new Error("The parameter 'publisherId' must be defined.");
        url_ = url_.replace("{publisherId}", encodeURIComponent("" + publisherId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForPublisher(_response);
        });
    }

    protected processGetAllForPublisher(response: AxiosResponse): Promise<ListOfSurvey> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfSurvey.fromJS(resultData200);
            return Promise.resolve<ListOfSurvey>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfSurvey>(null as any);
    }

    create(settings: CreateSurveySettings, cancelToken?: CancelToken | undefined): Promise<Survey> {
        let url_ = this.baseUrl + "/v1/Survey";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Survey> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Survey.fromJS(resultData200);
            return Promise.resolve<Survey>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Survey>(null as any);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param consumerId (optional) 
     * @param publisherId (optional) 
     * @param programId (optional) - null/empty to show all
    - program ID to filter to specific program
    - "none" to filter to items not in any program
     * @param itemId (optional) 
     * @param activated (optional) 
     */
    getAllByActivation(search: string | null | undefined, skip: number | undefined, take: number | undefined, consumerId: string | null | undefined, publisherId: string | null | undefined, programId: string | null | undefined, itemId: string | null | undefined, activated: boolean | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfSurvey> {
        let url_ = this.baseUrl + "/v1/Survey?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (consumerId !== undefined && consumerId !== null)
            url_ += "consumerId=" + encodeURIComponent("" + consumerId) + "&";
        if (publisherId !== undefined && publisherId !== null)
            url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&";
        if (programId !== undefined && programId !== null)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        if (itemId !== undefined && itemId !== null)
            url_ += "itemId=" + encodeURIComponent("" + itemId) + "&";
        if (activated !== undefined && activated !== null)
            url_ += "activated=" + encodeURIComponent("" + activated) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllByActivation(_response);
        });
    }

    protected processGetAllByActivation(response: AxiosResponse): Promise<ListOfSurvey> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfSurvey.fromJS(resultData200);
            return Promise.resolve<ListOfSurvey>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfSurvey>(null as any);
    }

    get(id: string, cancelToken?: CancelToken | undefined): Promise<Survey> {
        let url_ = this.baseUrl + "/v1/Survey/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Survey> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Survey.fromJS(resultData200);
            return Promise.resolve<Survey>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Survey>(null as any);
    }

    update(surveyId: string, settings: UpdateSurveySettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Survey/{surveyId}";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    delete(surveyId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Survey/{surveyId}";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param publisherId (optional) 
     * @param programId (optional) - null/empty to show all
    - program ID to filter to specific program
    - "none" to filter to items not in any program
     * @param countryCode (optional) 
     */
    getAllPublished(search: string | null | undefined, skip: number | undefined, take: number | undefined, publisherId: string | null | undefined, programId: string | null | undefined, countryCode: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfSurvey> {
        let url_ = this.baseUrl + "/v1/Survey/Published?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (publisherId !== undefined && publisherId !== null)
            url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&";
        if (programId !== undefined && programId !== null)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        if (countryCode !== undefined && countryCode !== null)
            url_ += "countryCode=" + encodeURIComponent("" + countryCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllPublished(_response);
        });
    }

    protected processGetAllPublished(response: AxiosResponse): Promise<ListOfSurvey> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfSurvey.fromJS(resultData200);
            return Promise.resolve<ListOfSurvey>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfSurvey>(null as any);
    }
}

export class SurveyRequestClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param surveyId (optional) 
     */
    getAllForGroup(groupId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, surveyId: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfSurveyRequest> {
        let url_ = this.baseUrl + "/v1/SurveyRequest/Group/{groupId}?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (surveyId !== undefined && surveyId !== null)
            url_ += "surveyId=" + encodeURIComponent("" + surveyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForGroup(_response);
        });
    }

    protected processGetAllForGroup(response: AxiosResponse): Promise<ListOfSurveyRequest> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfSurveyRequest.fromJS(resultData200);
            return Promise.resolve<ListOfSurveyRequest>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfSurveyRequest>(null as any);
    }

    get(requestId: string, cancelToken?: CancelToken | undefined): Promise<SurveyRequest> {
        let url_ = this.baseUrl + "/v1/SurveyRequest/{requestId}";
        if (requestId === undefined || requestId === null)
            throw new Error("The parameter 'requestId' must be defined.");
        url_ = url_.replace("{requestId}", encodeURIComponent("" + requestId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<SurveyRequest> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SurveyRequest.fromJS(resultData200);
            return Promise.resolve<SurveyRequest>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SurveyRequest>(null as any);
    }

    delete(requestId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/SurveyRequest/{requestId}";
        if (requestId === undefined || requestId === null)
            throw new Error("The parameter 'requestId' must be defined.");
        url_ = url_.replace("{requestId}", encodeURIComponent("" + requestId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    getForToken(token: string, cancelToken?: CancelToken | undefined): Promise<Token> {
        let url_ = this.baseUrl + "/v1/SurveyRequest/Token/{token}";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetForToken(_response);
        });
    }

    protected processGetForToken(response: AxiosResponse): Promise<Token> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Token.fromJS(resultData200);
            return Promise.resolve<Token>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Token>(null as any);
    }

    create(settings: CreateSurveyRequestSettings, cancelToken?: CancelToken | undefined): Promise<SurveyRequest> {
        let url_ = this.baseUrl + "/v1/SurveyRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<SurveyRequest> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SurveyRequest.fromJS(resultData200);
            return Promise.resolve<SurveyRequest>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SurveyRequest>(null as any);
    }
}

export class SurveyResponseClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param groupId (optional) 
     * @param publisherId (optional) 
     * @param contentId (optional) 
     * @param jobTypeId (optional) 
     * @param submitted (optional) 
     */
    getAllForSurvey(surveyId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, groupId: string | null | undefined, publisherId: string | null | undefined, contentId: string | null | undefined, jobTypeId: string | null | undefined, submitted: boolean | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfSurveyResponse> {
        let url_ = this.baseUrl + "/v1/SurveyResponse/Survey/{surveyId}?";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (groupId !== undefined && groupId !== null)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        if (publisherId !== undefined && publisherId !== null)
            url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&";
        if (contentId !== undefined && contentId !== null)
            url_ += "contentId=" + encodeURIComponent("" + contentId) + "&";
        if (jobTypeId !== undefined && jobTypeId !== null)
            url_ += "jobTypeId=" + encodeURIComponent("" + jobTypeId) + "&";
        if (submitted !== undefined && submitted !== null)
            url_ += "submitted=" + encodeURIComponent("" + submitted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForSurvey(_response);
        });
    }

    protected processGetAllForSurvey(response: AxiosResponse): Promise<ListOfSurveyResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfSurveyResponse.fromJS(resultData200);
            return Promise.resolve<ListOfSurveyResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfSurveyResponse>(null as any);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param surveyId (optional) 
     * @param submitted (optional) 
     */
    getAllForRespondent(respondentId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, surveyId: string | null | undefined, submitted: boolean | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfSurveyResponse> {
        let url_ = this.baseUrl + "/v1/SurveyResponse/Respondent/{respondentId}?";
        if (respondentId === undefined || respondentId === null)
            throw new Error("The parameter 'respondentId' must be defined.");
        url_ = url_.replace("{respondentId}", encodeURIComponent("" + respondentId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (surveyId !== undefined && surveyId !== null)
            url_ += "surveyId=" + encodeURIComponent("" + surveyId) + "&";
        if (submitted !== undefined && submitted !== null)
            url_ += "submitted=" + encodeURIComponent("" + submitted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForRespondent(_response);
        });
    }

    protected processGetAllForRespondent(response: AxiosResponse): Promise<ListOfSurveyResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfSurveyResponse.fromJS(resultData200);
            return Promise.resolve<ListOfSurveyResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfSurveyResponse>(null as any);
    }

    get(responseId: string, cancelToken?: CancelToken | undefined): Promise<SurveyResponse> {
        let url_ = this.baseUrl + "/v1/SurveyResponse/{responseId}";
        if (responseId === undefined || responseId === null)
            throw new Error("The parameter 'responseId' must be defined.");
        url_ = url_.replace("{responseId}", encodeURIComponent("" + responseId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<SurveyResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SurveyResponse.fromJS(resultData200);
            return Promise.resolve<SurveyResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SurveyResponse>(null as any);
    }

    update(responseId: string, settings: UpdateSurveyResponseSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/SurveyResponse/{responseId}";
        if (responseId === undefined || responseId === null)
            throw new Error("The parameter 'responseId' must be defined.");
        url_ = url_.replace("{responseId}", encodeURIComponent("" + responseId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    delete(surveyId: string | null | undefined, responseId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/SurveyResponse/{responseId}?";
        if (responseId === undefined || responseId === null)
            throw new Error("The parameter 'responseId' must be defined.");
        url_ = url_.replace("{responseId}", encodeURIComponent("" + responseId));
        if (surveyId !== undefined && surveyId !== null)
            url_ += "surveyId=" + encodeURIComponent("" + surveyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    create(settings: CreateSurveyResponseSettings, cancelToken?: CancelToken | undefined): Promise<SurveyResponse> {
        let url_ = this.baseUrl + "/v1/SurveyResponse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<SurveyResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SurveyResponse.fromJS(resultData200);
            return Promise.resolve<SurveyResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SurveyResponse>(null as any);
    }
}

export class ActorClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    get(actorId: string, cancelToken?: CancelToken | undefined): Promise<Actor> {
        let url_ = this.baseUrl + "/v1/Actor/{actorId}";
        if (actorId === undefined || actorId === null)
            throw new Error("The parameter 'actorId' must be defined.");
        url_ = url_.replace("{actorId}", encodeURIComponent("" + actorId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Actor> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Actor.fromJS(resultData200);
            return Promise.resolve<Actor>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Actor>(null as any);
    }
}

export class BookAttemptClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param moduleId (optional) 
     */
    getAllForActor(actorId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, moduleId: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfModuleAttemptOfBookResult> {
        let url_ = this.baseUrl + "/v1/BookAttempt/Actor/{actorId}?";
        if (actorId === undefined || actorId === null)
            throw new Error("The parameter 'actorId' must be defined.");
        url_ = url_.replace("{actorId}", encodeURIComponent("" + actorId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (moduleId !== undefined && moduleId !== null)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForActor(_response);
        });
    }

    protected processGetAllForActor(response: AxiosResponse): Promise<ListOfModuleAttemptOfBookResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfModuleAttemptOfBookResult.fromJS(resultData200);
            return Promise.resolve<ListOfModuleAttemptOfBookResult>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfModuleAttemptOfBookResult>(null as any);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param moduleId (optional) 
     * @param actorType (optional) 
     * @param from (optional) 
     * @param to (optional) 
     */
    getAllForGroup(groupId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, moduleId: string | null | undefined, actorType: ActorType | null | undefined, from: Date | null | undefined, to: Date | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfModuleAttemptOfBookResult> {
        let url_ = this.baseUrl + "/v1/BookAttempt/Group/{groupId}?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (moduleId !== undefined && moduleId !== null)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&";
        if (actorType !== undefined && actorType !== null)
            url_ += "actorType=" + encodeURIComponent("" + actorType) + "&";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForGroup(_response);
        });
    }

    protected processGetAllForGroup(response: AxiosResponse): Promise<ListOfModuleAttemptOfBookResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfModuleAttemptOfBookResult.fromJS(resultData200);
            return Promise.resolve<ListOfModuleAttemptOfBookResult>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfModuleAttemptOfBookResult>(null as any);
    }

    get(moduleAttemptId: string, cancelToken?: CancelToken | undefined): Promise<ModuleAttemptOfBookResult> {
        let url_ = this.baseUrl + "/v1/BookAttempt/{moduleAttemptId}";
        if (moduleAttemptId === undefined || moduleAttemptId === null)
            throw new Error("The parameter 'moduleAttemptId' must be defined.");
        url_ = url_.replace("{moduleAttemptId}", encodeURIComponent("" + moduleAttemptId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ModuleAttemptOfBookResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleAttemptOfBookResult.fromJS(resultData200);
            return Promise.resolve<ModuleAttemptOfBookResult>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleAttemptOfBookResult>(null as any);
    }

    update(moduleAttemptId: string, settings: UpdateModuleAttemptSettingsOfBookResult, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/BookAttempt/{moduleAttemptId}";
        if (moduleAttemptId === undefined || moduleAttemptId === null)
            throw new Error("The parameter 'moduleAttemptId' must be defined.");
        url_ = url_.replace("{moduleAttemptId}", encodeURIComponent("" + moduleAttemptId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    delete(moduleAttemptId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/BookAttempt/{moduleAttemptId}";
        if (moduleAttemptId === undefined || moduleAttemptId === null)
            throw new Error("The parameter 'moduleAttemptId' must be defined.");
        url_ = url_.replace("{moduleAttemptId}", encodeURIComponent("" + moduleAttemptId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    create(settings: CreateModuleAttemptSettingsOfBookResult, cancelToken?: CancelToken | undefined): Promise<ModuleAttemptOfBookResult> {
        let url_ = this.baseUrl + "/v1/BookAttempt";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ModuleAttemptOfBookResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleAttemptOfBookResult.fromJS(resultData200);
            return Promise.resolve<ModuleAttemptOfBookResult>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleAttemptOfBookResult>(null as any);
    }

    examplePass(moduleId: string, contentId: string, cancelToken?: CancelToken | undefined): Promise<BookResult> {
        let url_ = this.baseUrl + "/v1/BookAttempt/{moduleId}/Content/{contentId}/ExamplePass";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExamplePass(_response);
        });
    }

    protected processExamplePass(response: AxiosResponse): Promise<BookResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BookResult.fromJS(resultData200);
            return Promise.resolve<BookResult>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BookResult>(null as any);
    }
}

export class BookContentClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAll(moduleId: string, skip: number | undefined, take: number | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfModuleContentOfBookSettings> {
        let url_ = this.baseUrl + "/v1/BookContent/{moduleId}/Content?";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfModuleContentOfBookSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfModuleContentOfBookSettings.fromJS(resultData200);
            return Promise.resolve<ListOfModuleContentOfBookSettings>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfModuleContentOfBookSettings>(null as any);
    }

    create(moduleId: string, settings: CreateModuleContentSettingsOfBookSettings, cancelToken?: CancelToken | undefined): Promise<ModuleContentOfBookSettings> {
        let url_ = this.baseUrl + "/v1/BookContent/{moduleId}/Content";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ModuleContentOfBookSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleContentOfBookSettings.fromJS(resultData200);
            return Promise.resolve<ModuleContentOfBookSettings>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleContentOfBookSettings>(null as any);
    }

    get(moduleId: string, contentId: string, cancelToken?: CancelToken | undefined): Promise<ModuleContentOfBookSettings> {
        let url_ = this.baseUrl + "/v1/BookContent/{moduleId}/Content/{contentId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ModuleContentOfBookSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleContentOfBookSettings.fromJS(resultData200);
            return Promise.resolve<ModuleContentOfBookSettings>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleContentOfBookSettings>(null as any);
    }

    update(moduleId: string, contentId: string, settings: UpdateModuleContentSettingsOfBookSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/BookContent/{moduleId}/Content/{contentId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    delete(moduleId: string, contentId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/BookContent/{moduleId}/Content/{contentId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    createFromZip(moduleId: string, file: FileParameter | null | undefined, cancelToken?: CancelToken | undefined): Promise<ModuleContentOfBookSettings> {
        let url_ = this.baseUrl + "/v1/BookContent/{moduleId}/Content/FromZip";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateFromZip(_response);
        });
    }

    protected processCreateFromZip(response: AxiosResponse): Promise<ModuleContentOfBookSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleContentOfBookSettings.fromJS(resultData200);
            return Promise.resolve<ModuleContentOfBookSettings>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleContentOfBookSettings>(null as any);
    }

    updateFromZip(moduleId: string, contentId: string, file: FileParameter | null | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/BookContent/{moduleId}/Content/{contentId}/FromZip";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateFromZip(_response);
        });
    }

    protected processUpdateFromZip(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    publish(moduleId: string, contentId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/BookContent/{moduleId}/Content/{contentId}/Publish";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPublish(_response);
        });
    }

    protected processPublish(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    downloadFile(moduleId: string, contentId: string, fileId: string, cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/BookContent/{moduleId}/Content/{contentId}/File/{fileId}/Download";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadFile(_response);
        });
    }

    protected processDownloadFile(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    export(moduleId: string, contentId: string, cancelToken?: CancelToken | undefined): Promise<CreateModuleContentSettingsOfBookSettings> {
        let url_ = this.baseUrl + "/v1/BookContent/{moduleId}/Content/{contentId}/Export";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExport(_response);
        });
    }

    protected processExport(response: AxiosResponse): Promise<CreateModuleContentSettingsOfBookSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CreateModuleContentSettingsOfBookSettings.fromJS(resultData200);
            return Promise.resolve<CreateModuleContentSettingsOfBookSettings>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateModuleContentSettingsOfBookSettings>(null as any);
    }

    example( cancelToken?: CancelToken | undefined): Promise<BookSettings> {
        let url_ = this.baseUrl + "/v1/BookContent/Example";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExample(_response);
        });
    }

    protected processExample(response: AxiosResponse): Promise<BookSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BookSettings.fromJS(resultData200);
            return Promise.resolve<BookSettings>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BookSettings>(null as any);
    }

    schema( cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/BookContent/Schema";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSchema(_response);
        });
    }

    protected processSchema(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class CertificateClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param publisherId (optional) 
     */
    getAll(search: string | null | undefined, skip: number | undefined, take: number | undefined, publisherId: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfCertificate> {
        let url_ = this.baseUrl + "/v1/Certificate?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (publisherId !== undefined && publisherId !== null)
            url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfCertificate> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfCertificate.fromJS(resultData200);
            return Promise.resolve<ListOfCertificate>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfCertificate>(null as any);
    }

    create(settings: CreateCertificateSettings, cancelToken?: CancelToken | undefined): Promise<Certificate> {
        let url_ = this.baseUrl + "/v1/Certificate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Certificate> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Certificate.fromJS(resultData200);
            return Promise.resolve<Certificate>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Certificate>(null as any);
    }

    get(certificateId: string, cancelToken?: CancelToken | undefined): Promise<Certificate> {
        let url_ = this.baseUrl + "/v1/Certificate/{certificateId}";
        if (certificateId === undefined || certificateId === null)
            throw new Error("The parameter 'certificateId' must be defined.");
        url_ = url_.replace("{certificateId}", encodeURIComponent("" + certificateId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Certificate> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Certificate.fromJS(resultData200);
            return Promise.resolve<Certificate>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Certificate>(null as any);
    }

    update(certificateId: string, settings: UpdateCertificateSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Certificate/{certificateId}";
        if (certificateId === undefined || certificateId === null)
            throw new Error("The parameter 'certificateId' must be defined.");
        url_ = url_.replace("{certificateId}", encodeURIComponent("" + certificateId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    delete(certificateId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Certificate/{certificateId}";
        if (certificateId === undefined || certificateId === null)
            throw new Error("The parameter 'certificateId' must be defined.");
        url_ = url_.replace("{certificateId}", encodeURIComponent("" + certificateId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class CertificationClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAllForTrainee(traineeId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfCertification> {
        let url_ = this.baseUrl + "/v1/Certification/Trainee/{traineeId}?";
        if (traineeId === undefined || traineeId === null)
            throw new Error("The parameter 'traineeId' must be defined.");
        url_ = url_.replace("{traineeId}", encodeURIComponent("" + traineeId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForTrainee(_response);
        });
    }

    protected processGetAllForTrainee(response: AxiosResponse): Promise<ListOfCertification> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfCertification.fromJS(resultData200);
            return Promise.resolve<ListOfCertification>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfCertification>(null as any);
    }

    /**
     * Gets the certifications for a trainee at the given time.
     * @param traineeId The user id of the trainee.
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param at (optional) The UTC time at which to get certificates. If not specified, the current time is used.
     */
    getAllHistoryForTrainee(traineeId: string, skip: number | undefined, take: number | undefined, at: Date | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfCertificationFact> {
        let url_ = this.baseUrl + "/v1/Certification/Trainee/{traineeId}/History?";
        if (traineeId === undefined || traineeId === null)
            throw new Error("The parameter 'traineeId' must be defined.");
        url_ = url_.replace("{traineeId}", encodeURIComponent("" + traineeId));
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (at !== undefined && at !== null)
            url_ += "at=" + encodeURIComponent(at ? "" + at.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllHistoryForTrainee(_response);
        });
    }

    protected processGetAllHistoryForTrainee(response: AxiosResponse): Promise<ListOfCertificationFact> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfCertificationFact.fromJS(resultData200);
            return Promise.resolve<ListOfCertificationFact>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfCertificationFact>(null as any);
    }

    /**
     * Gets the list of users with a certificate in a group at a specified time, optionally filtered by their status and roles in the group.
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param certificateId (optional) 
     * @param memberStatus (optional) 
     * @param role (optional) 
     * @param at (optional) The UTC time at which to get certificates. If not specified, the current time is used.
     */
    getAllHistoryForGroup(groupId: string, skip: number | undefined, take: number | undefined, certificateId: string | null | undefined, memberStatus: MemberStatus | null | undefined, role: string | null | undefined, at: Date | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfCertificationFact> {
        let url_ = this.baseUrl + "/v1/Certification/Group/{groupId}/History?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (certificateId !== undefined && certificateId !== null)
            url_ += "certificateId=" + encodeURIComponent("" + certificateId) + "&";
        if (memberStatus !== undefined && memberStatus !== null)
            url_ += "memberStatus=" + encodeURIComponent("" + memberStatus) + "&";
        if (role !== undefined && role !== null)
            url_ += "role=" + encodeURIComponent("" + role) + "&";
        if (at !== undefined && at !== null)
            url_ += "at=" + encodeURIComponent(at ? "" + at.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllHistoryForGroup(_response);
        });
    }

    protected processGetAllHistoryForGroup(response: AxiosResponse): Promise<ListOfCertificationFact> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfCertificationFact.fromJS(resultData200);
            return Promise.resolve<ListOfCertificationFact>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfCertificationFact>(null as any);
    }

    get(certificationId: string, cancelToken?: CancelToken | undefined): Promise<Certification> {
        let url_ = this.baseUrl + "/v1/Certification/{certificationId}";
        if (certificationId === undefined || certificationId === null)
            throw new Error("The parameter 'certificationId' must be defined.");
        url_ = url_.replace("{certificationId}", encodeURIComponent("" + certificationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Certification> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Certification.fromJS(resultData200);
            return Promise.resolve<Certification>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Certification>(null as any);
    }

    export(certificationId: string, cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/Certification/{certificationId}/Export";
        if (certificationId === undefined || certificationId === null)
            throw new Error("The parameter 'certificationId' must be defined.");
        url_ = url_.replace("{certificationId}", encodeURIComponent("" + certificationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExport(_response);
        });
    }

    protected processExport(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    download(token: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/Certification/Download?";
        if (token !== undefined && token !== null)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownload(_response);
        });
    }

    protected processDownload(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class ClassClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * Get a list of all classes
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param organisationId (optional) Optional organisation id filter
     * @param teamId (optional) Optional team id filter
     * @param publisherId (optional) Optional publisher id filter
     * @param courseId (optional) Optional course id filter
     * @param programId (optional) - null/empty to show all
    - program ID to filter to specific program
    - "none" to filter to items not in any program
     * @param activated (optional) Optional filter by class activation state
     */
    getAll(search: string | null | undefined, skip: number | undefined, take: number | undefined, organisationId: string | null | undefined, teamId: string | null | undefined, publisherId: string | null | undefined, courseId: string | null | undefined, programId: string | null | undefined, activated: boolean | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfClass> {
        let url_ = this.baseUrl + "/v1/Class?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (organisationId !== undefined && organisationId !== null)
            url_ += "organisationId=" + encodeURIComponent("" + organisationId) + "&";
        if (teamId !== undefined && teamId !== null)
            url_ += "teamId=" + encodeURIComponent("" + teamId) + "&";
        if (publisherId !== undefined && publisherId !== null)
            url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&";
        if (courseId !== undefined && courseId !== null)
            url_ += "courseId=" + encodeURIComponent("" + courseId) + "&";
        if (programId !== undefined && programId !== null)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        if (activated !== undefined && activated !== null)
            url_ += "activated=" + encodeURIComponent("" + activated) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfClass> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfClass.fromJS(resultData200);
            return Promise.resolve<ListOfClass>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfClass>(null as any);
    }

    create(settings: CreateClassSettings, cancelToken?: CancelToken | undefined): Promise<Class> {
        let url_ = this.baseUrl + "/v1/Class";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Class> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Class.fromJS(resultData200);
            return Promise.resolve<Class>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Class>(null as any);
    }

    get(classId: string, cancelToken?: CancelToken | undefined): Promise<Class> {
        let url_ = this.baseUrl + "/v1/Class/{classId}";
        if (classId === undefined || classId === null)
            throw new Error("The parameter 'classId' must be defined.");
        url_ = url_.replace("{classId}", encodeURIComponent("" + classId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Class> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Class.fromJS(resultData200);
            return Promise.resolve<Class>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Class>(null as any);
    }

    update(classId: string, settings: UpdateClassSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Class/{classId}";
        if (classId === undefined || classId === null)
            throw new Error("The parameter 'classId' must be defined.");
        url_ = url_.replace("{classId}", encodeURIComponent("" + classId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    delete(classId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Class/{classId}";
        if (classId === undefined || classId === null)
            throw new Error("The parameter 'classId' must be defined.");
        url_ = url_.replace("{classId}", encodeURIComponent("" + classId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Send assessment requested notification to trainers
     */
    notifyAssessors(classId: string, settings: NotifyAssessorsSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Class/{classId}/NotifyAssessors";
        if (classId === undefined || classId === null)
            throw new Error("The parameter 'classId' must be defined.");
        url_ = url_.replace("{classId}", encodeURIComponent("" + classId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processNotifyAssessors(_response);
        });
    }

    protected processNotifyAssessors(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class CourseClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param programId (optional) - null/empty to show all
    - program ID to filter to specific program
    - "none" to filter to items not in any program
     */
    getAllForPublisher(publisherId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, programId: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfCourse> {
        let url_ = this.baseUrl + "/v1/Course/Publisher/{publisherId}?";
        if (publisherId === undefined || publisherId === null)
            throw new Error("The parameter 'publisherId' must be defined.");
        url_ = url_.replace("{publisherId}", encodeURIComponent("" + publisherId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (programId !== undefined && programId !== null)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForPublisher(_response);
        });
    }

    protected processGetAllForPublisher(response: AxiosResponse): Promise<ListOfCourse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfCourse.fromJS(resultData200);
            return Promise.resolve<ListOfCourse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfCourse>(null as any);
    }

    create(settings: CreateCourseSettings, cancelToken?: CancelToken | undefined): Promise<Course> {
        let url_ = this.baseUrl + "/v1/Course";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Course> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Course.fromJS(resultData200);
            return Promise.resolve<Course>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Course>(null as any);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param consumerId (optional) 
     * @param publisherId (optional) 
     * @param programId (optional) - null/empty to show all
    - program ID to filter to specific program
    - "none" to filter to items not in any program
     * @param itemId (optional) 
     * @param activated (optional) 
     */
    getAllByActivation(search: string | null | undefined, skip: number | undefined, take: number | undefined, consumerId: string | null | undefined, publisherId: string | null | undefined, programId: string | null | undefined, itemId: string | null | undefined, activated: boolean | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfCourse> {
        let url_ = this.baseUrl + "/v1/Course?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (consumerId !== undefined && consumerId !== null)
            url_ += "consumerId=" + encodeURIComponent("" + consumerId) + "&";
        if (publisherId !== undefined && publisherId !== null)
            url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&";
        if (programId !== undefined && programId !== null)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        if (itemId !== undefined && itemId !== null)
            url_ += "itemId=" + encodeURIComponent("" + itemId) + "&";
        if (activated !== undefined && activated !== null)
            url_ += "activated=" + encodeURIComponent("" + activated) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllByActivation(_response);
        });
    }

    protected processGetAllByActivation(response: AxiosResponse): Promise<ListOfCourse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfCourse.fromJS(resultData200);
            return Promise.resolve<ListOfCourse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfCourse>(null as any);
    }

    update(courseId: string, settings: UpdateCourseSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Course/{courseId}";
        if (courseId === undefined || courseId === null)
            throw new Error("The parameter 'courseId' must be defined.");
        url_ = url_.replace("{courseId}", encodeURIComponent("" + courseId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    delete(courseId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Course/{courseId}";
        if (courseId === undefined || courseId === null)
            throw new Error("The parameter 'courseId' must be defined.");
        url_ = url_.replace("{courseId}", encodeURIComponent("" + courseId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param publisherId (optional) 
     * @param programId (optional) - null/empty to show all
    - program ID to filter to specific program
    - "none" to filter to items not in any program
     * @param countryCode (optional) 
     */
    getAllPublished(search: string | null | undefined, skip: number | undefined, take: number | undefined, publisherId: string | null | undefined, programId: string | null | undefined, countryCode: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfCourse> {
        let url_ = this.baseUrl + "/v1/Course/Published?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (publisherId !== undefined && publisherId !== null)
            url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&";
        if (programId !== undefined && programId !== null)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        if (countryCode !== undefined && countryCode !== null)
            url_ += "countryCode=" + encodeURIComponent("" + countryCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllPublished(_response);
        });
    }

    protected processGetAllPublished(response: AxiosResponse): Promise<ListOfCourse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfCourse.fromJS(resultData200);
            return Promise.resolve<ListOfCourse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfCourse>(null as any);
    }

    get(id: string, cancelToken?: CancelToken | undefined): Promise<Course> {
        let url_ = this.baseUrl + "/v1/Course/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Course> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Course.fromJS(resultData200);
            return Promise.resolve<Course>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Course>(null as any);
    }
}

export class EnrolmentClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param activated (optional) 
     * @param programId (optional) - null/empty to show all
    - program ID to filter to specific program
    - "none" to filter to items not in any program
     */
    getAllForTrainee(traineeId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, activated: boolean | null | undefined, programId: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfEnrolment> {
        let url_ = this.baseUrl + "/v1/Enrolment/Trainee/{traineeId}?";
        if (traineeId === undefined || traineeId === null)
            throw new Error("The parameter 'traineeId' must be defined.");
        url_ = url_.replace("{traineeId}", encodeURIComponent("" + traineeId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (activated !== undefined && activated !== null)
            url_ += "activated=" + encodeURIComponent("" + activated) + "&";
        if (programId !== undefined && programId !== null)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForTrainee(_response);
        });
    }

    protected processGetAllForTrainee(response: AxiosResponse): Promise<ListOfEnrolment> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfEnrolment.fromJS(resultData200);
            return Promise.resolve<ListOfEnrolment>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfEnrolment>(null as any);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAllForClass(classId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfEnrolment> {
        let url_ = this.baseUrl + "/v1/Enrolment/Class/{classId}?";
        if (classId === undefined || classId === null)
            throw new Error("The parameter 'classId' must be defined.");
        url_ = url_.replace("{classId}", encodeURIComponent("" + classId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForClass(_response);
        });
    }

    protected processGetAllForClass(response: AxiosResponse): Promise<ListOfEnrolment> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfEnrolment.fromJS(resultData200);
            return Promise.resolve<ListOfEnrolment>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfEnrolment>(null as any);
    }

    get(enrolmentId: string, cancelToken?: CancelToken | undefined): Promise<Enrolment> {
        let url_ = this.baseUrl + "/v1/Enrolment/{enrolmentId}";
        if (enrolmentId === undefined || enrolmentId === null)
            throw new Error("The parameter 'enrolmentId' must be defined.");
        url_ = url_.replace("{enrolmentId}", encodeURIComponent("" + enrolmentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Enrolment> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Enrolment.fromJS(resultData200);
            return Promise.resolve<Enrolment>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Enrolment>(null as any);
    }
}

export class ModuleAttemptClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param moduleId (optional) 
     */
    getAllForActor(actorId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, moduleId: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfModuleAttempt> {
        let url_ = this.baseUrl + "/v1/ModuleAttempt/Actor/{actorId}?";
        if (actorId === undefined || actorId === null)
            throw new Error("The parameter 'actorId' must be defined.");
        url_ = url_.replace("{actorId}", encodeURIComponent("" + actorId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (moduleId !== undefined && moduleId !== null)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForActor(_response);
        });
    }

    protected processGetAllForActor(response: AxiosResponse): Promise<ListOfModuleAttempt> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfModuleAttempt.fromJS(resultData200);
            return Promise.resolve<ListOfModuleAttempt>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfModuleAttempt>(null as any);
    }

    /**
     * Gets all module attempts within the given group.
     * @param groupId The group to get module attempts from
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param moduleId (optional) Filter the results by module id
     * @param actorType (optional) Filter the results by actor type i.e. User, TrainingSession or Team. If left null, all actor types will be searched for.
     * @param from (optional) Start time of the module attempts
     * @param to (optional) End time of the module attempts
     */
    getAllForGroup(groupId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, moduleId: string | null | undefined, actorType: ActorType | null | undefined, from: Date | null | undefined, to: Date | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfModuleAttempt> {
        let url_ = this.baseUrl + "/v1/ModuleAttempt/Group/{groupId}?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (moduleId !== undefined && moduleId !== null)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&";
        if (actorType !== undefined && actorType !== null)
            url_ += "actorType=" + encodeURIComponent("" + actorType) + "&";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForGroup(_response);
        });
    }

    protected processGetAllForGroup(response: AxiosResponse): Promise<ListOfModuleAttempt> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfModuleAttempt.fromJS(resultData200);
            return Promise.resolve<ListOfModuleAttempt>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfModuleAttempt>(null as any);
    }

    get(moduleAttemptId: string, cancelToken?: CancelToken | undefined): Promise<ModuleAttempt> {
        let url_ = this.baseUrl + "/v1/ModuleAttempt/{moduleAttemptId}";
        if (moduleAttemptId === undefined || moduleAttemptId === null)
            throw new Error("The parameter 'moduleAttemptId' must be defined.");
        url_ = url_.replace("{moduleAttemptId}", encodeURIComponent("" + moduleAttemptId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ModuleAttempt> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleAttempt.fromJS(resultData200);
            return Promise.resolve<ModuleAttempt>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleAttempt>(null as any);
    }

    delete(moduleAttemptId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/ModuleAttempt/{moduleAttemptId}";
        if (moduleAttemptId === undefined || moduleAttemptId === null)
            throw new Error("The parameter 'moduleAttemptId' must be defined.");
        url_ = url_.replace("{moduleAttemptId}", encodeURIComponent("" + moduleAttemptId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ModuleClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param publisherId (optional) 
     * @param type (optional) 
     */
    getAll(search: string | null | undefined, skip: number | undefined, take: number | undefined, publisherId: string | null | undefined, type: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfModule> {
        let url_ = this.baseUrl + "/v1/Module?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (publisherId !== undefined && publisherId !== null)
            url_ += "publisherId=" + encodeURIComponent("" + publisherId) + "&";
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfModule> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfModule.fromJS(resultData200);
            return Promise.resolve<ListOfModule>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfModule>(null as any);
    }

    /**
     * Creates a module using the given data
     * @param settings The data used to create the module
     */
    create(settings: CreateModuleSettings, cancelToken?: CancelToken | undefined): Promise<Module> {
        let url_ = this.baseUrl + "/v1/Module";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Module> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Module.fromJS(resultData200);
            return Promise.resolve<Module>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Module>(null as any);
    }

    get(moduleId: string, cancelToken?: CancelToken | undefined): Promise<Module> {
        let url_ = this.baseUrl + "/v1/Module/{moduleId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Module> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Module.fromJS(resultData200);
            return Promise.resolve<Module>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Module>(null as any);
    }

    update(moduleId: string, settings: UpdateModuleSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Module/{moduleId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    delete(moduleId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Module/{moduleId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    getAllFiles(moduleId: string, cancelToken?: CancelToken | undefined): Promise<ListOfFile> {
        let url_ = this.baseUrl + "/v1/Module/{moduleId}/File";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllFiles(_response);
        });
    }

    protected processGetAllFiles(response: AxiosResponse): Promise<ListOfFile> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfFile.fromJS(resultData200);
            return Promise.resolve<ListOfFile>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfFile>(null as any);
    }

    /**
     * Creates a file and attaches it to the module
     * @param moduleId Id of the module to attach the file to
     * @param settings Data used to create the file
     * @return Information about the created file
     */
    createFile(moduleId: string, settings: CreateFileSettings, cancelToken?: CancelToken | undefined): Promise<File> {
        let url_ = this.baseUrl + "/v1/Module/{moduleId}/File";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateFile(_response);
        });
    }

    protected processCreateFile(response: AxiosResponse): Promise<File> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = File.fromJS(resultData200);
            return Promise.resolve<File>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<File>(null as any);
    }

    getFile(moduleId: string, fileId: string, cancelToken?: CancelToken | undefined): Promise<File> {
        let url_ = this.baseUrl + "/v1/Module/{moduleId}/File/{fileId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetFile(_response);
        });
    }

    protected processGetFile(response: AxiosResponse): Promise<File> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = File.fromJS(resultData200);
            return Promise.resolve<File>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<File>(null as any);
    }

    updateFile(moduleId: string, fileId: string, settings: UpdateFileSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Module/{moduleId}/File/{fileId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateFile(_response);
        });
    }

    protected processUpdateFile(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    deleteFile(moduleId: string, fileId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Module/{moduleId}/File/{fileId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteFile(_response);
        });
    }

    protected processDeleteFile(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    downloadFile(moduleId: string, fileId: string, cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/Module/{moduleId}/File/{fileId}/Download";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadFile(_response);
        });
    }

    protected processDownloadFile(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class ModuleNpsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    getAllForPublisher(publisherId: string, search: string | null | undefined, from: Date | null | undefined, to: Date | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfModuleNps> {
        let url_ = this.baseUrl + "/v1/ModuleNps/Publisher/{publisherId}?";
        if (publisherId === undefined || publisherId === null)
            throw new Error("The parameter 'publisherId' must be defined.");
        url_ = url_.replace("{publisherId}", encodeURIComponent("" + publisherId));
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForPublisher(_response);
        });
    }

    protected processGetAllForPublisher(response: AxiosResponse): Promise<ListOfModuleNps> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfModuleNps.fromJS(resultData200);
            return Promise.resolve<ListOfModuleNps>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfModuleNps>(null as any);
    }

    getAllForModule(moduleId: string, from: Date | null | undefined, to: Date | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfModuleNps> {
        let url_ = this.baseUrl + "/v1/ModuleNps/Module/{moduleId}?";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForModule(_response);
        });
    }

    protected processGetAllForModule(response: AxiosResponse): Promise<ListOfModuleNps> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfModuleNps.fromJS(resultData200);
            return Promise.resolve<ListOfModuleNps>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfModuleNps>(null as any);
    }

    get(npsId: string, cancelToken?: CancelToken | undefined): Promise<Nps> {
        let url_ = this.baseUrl + "/v1/ModuleNps/{npsId}";
        if (npsId === undefined || npsId === null)
            throw new Error("The parameter 'npsId' must be defined.");
        url_ = url_.replace("{npsId}", encodeURIComponent("" + npsId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Nps> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Nps.fromJS(resultData200);
            return Promise.resolve<Nps>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Nps>(null as any);
    }

    delete(npsId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/ModuleNps/{npsId}";
        if (npsId === undefined || npsId === null)
            throw new Error("The parameter 'npsId' must be defined.");
        url_ = url_.replace("{npsId}", encodeURIComponent("" + npsId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    create(settings: CreateNpsSettings, cancelToken?: CancelToken | undefined): Promise<Nps> {
        let url_ = this.baseUrl + "/v1/ModuleNps";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Nps> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Nps.fromJS(resultData200);
            return Promise.resolve<Nps>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Nps>(null as any);
    }
}

export class QuizAttemptClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param moduleId (optional) 
     */
    getAllForActor(actorId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, moduleId: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfModuleAttemptOfQuizResult> {
        let url_ = this.baseUrl + "/v1/QuizAttempt/Actor/{actorId}?";
        if (actorId === undefined || actorId === null)
            throw new Error("The parameter 'actorId' must be defined.");
        url_ = url_.replace("{actorId}", encodeURIComponent("" + actorId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (moduleId !== undefined && moduleId !== null)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForActor(_response);
        });
    }

    protected processGetAllForActor(response: AxiosResponse): Promise<ListOfModuleAttemptOfQuizResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfModuleAttemptOfQuizResult.fromJS(resultData200);
            return Promise.resolve<ListOfModuleAttemptOfQuizResult>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfModuleAttemptOfQuizResult>(null as any);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param moduleId (optional) 
     * @param actorType (optional) 
     * @param from (optional) 
     * @param to (optional) 
     */
    getAllForGroup(groupId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, moduleId: string | null | undefined, actorType: ActorType | null | undefined, from: Date | null | undefined, to: Date | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfModuleAttemptOfQuizResult> {
        let url_ = this.baseUrl + "/v1/QuizAttempt/Group/{groupId}?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (moduleId !== undefined && moduleId !== null)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&";
        if (actorType !== undefined && actorType !== null)
            url_ += "actorType=" + encodeURIComponent("" + actorType) + "&";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForGroup(_response);
        });
    }

    protected processGetAllForGroup(response: AxiosResponse): Promise<ListOfModuleAttemptOfQuizResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfModuleAttemptOfQuizResult.fromJS(resultData200);
            return Promise.resolve<ListOfModuleAttemptOfQuizResult>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfModuleAttemptOfQuizResult>(null as any);
    }

    get(moduleAttemptId: string, cancelToken?: CancelToken | undefined): Promise<ModuleAttemptOfQuizResult> {
        let url_ = this.baseUrl + "/v1/QuizAttempt/{moduleAttemptId}";
        if (moduleAttemptId === undefined || moduleAttemptId === null)
            throw new Error("The parameter 'moduleAttemptId' must be defined.");
        url_ = url_.replace("{moduleAttemptId}", encodeURIComponent("" + moduleAttemptId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ModuleAttemptOfQuizResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleAttemptOfQuizResult.fromJS(resultData200);
            return Promise.resolve<ModuleAttemptOfQuizResult>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleAttemptOfQuizResult>(null as any);
    }

    update(moduleAttemptId: string, settings: UpdateModuleAttemptSettingsOfQuizResult, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/QuizAttempt/{moduleAttemptId}";
        if (moduleAttemptId === undefined || moduleAttemptId === null)
            throw new Error("The parameter 'moduleAttemptId' must be defined.");
        url_ = url_.replace("{moduleAttemptId}", encodeURIComponent("" + moduleAttemptId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    delete(moduleAttemptId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/QuizAttempt/{moduleAttemptId}";
        if (moduleAttemptId === undefined || moduleAttemptId === null)
            throw new Error("The parameter 'moduleAttemptId' must be defined.");
        url_ = url_.replace("{moduleAttemptId}", encodeURIComponent("" + moduleAttemptId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    create(settings: CreateModuleAttemptSettingsOfQuizResult, cancelToken?: CancelToken | undefined): Promise<ModuleAttemptOfQuizResult> {
        let url_ = this.baseUrl + "/v1/QuizAttempt";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ModuleAttemptOfQuizResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleAttemptOfQuizResult.fromJS(resultData200);
            return Promise.resolve<ModuleAttemptOfQuizResult>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleAttemptOfQuizResult>(null as any);
    }

    examplePass(moduleId: string, contentId: string, cancelToken?: CancelToken | undefined): Promise<QuizResult> {
        let url_ = this.baseUrl + "/v1/QuizAttempt/{moduleId}/Content/{contentId}/ExamplePass";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExamplePass(_response);
        });
    }

    protected processExamplePass(response: AxiosResponse): Promise<QuizResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = QuizResult.fromJS(resultData200);
            return Promise.resolve<QuizResult>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<QuizResult>(null as any);
    }
}

export class QuizContentClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAll(moduleId: string, skip: number | undefined, take: number | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfModuleContentOfQuizSettings> {
        let url_ = this.baseUrl + "/v1/QuizContent/{moduleId}/Content?";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfModuleContentOfQuizSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfModuleContentOfQuizSettings.fromJS(resultData200);
            return Promise.resolve<ListOfModuleContentOfQuizSettings>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfModuleContentOfQuizSettings>(null as any);
    }

    create(moduleId: string, settings: CreateModuleContentSettingsOfQuizSettings, cancelToken?: CancelToken | undefined): Promise<ModuleContentOfQuizSettings> {
        let url_ = this.baseUrl + "/v1/QuizContent/{moduleId}/Content";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ModuleContentOfQuizSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleContentOfQuizSettings.fromJS(resultData200);
            return Promise.resolve<ModuleContentOfQuizSettings>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleContentOfQuizSettings>(null as any);
    }

    get(moduleId: string, contentId: string, cancelToken?: CancelToken | undefined): Promise<ModuleContentOfQuizSettings> {
        let url_ = this.baseUrl + "/v1/QuizContent/{moduleId}/Content/{contentId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ModuleContentOfQuizSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleContentOfQuizSettings.fromJS(resultData200);
            return Promise.resolve<ModuleContentOfQuizSettings>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleContentOfQuizSettings>(null as any);
    }

    update(moduleId: string, contentId: string, settings: UpdateModuleContentSettingsOfQuizSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/QuizContent/{moduleId}/Content/{contentId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    delete(moduleId: string, contentId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/QuizContent/{moduleId}/Content/{contentId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    createFromZip(moduleId: string, file: FileParameter | null | undefined, cancelToken?: CancelToken | undefined): Promise<ModuleContentOfQuizSettings> {
        let url_ = this.baseUrl + "/v1/QuizContent/{moduleId}/Content/FromZip";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateFromZip(_response);
        });
    }

    protected processCreateFromZip(response: AxiosResponse): Promise<ModuleContentOfQuizSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleContentOfQuizSettings.fromJS(resultData200);
            return Promise.resolve<ModuleContentOfQuizSettings>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleContentOfQuizSettings>(null as any);
    }

    updateFromZip(moduleId: string, contentId: string, file: FileParameter | null | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/QuizContent/{moduleId}/Content/{contentId}/FromZip";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateFromZip(_response);
        });
    }

    protected processUpdateFromZip(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    publish(moduleId: string, contentId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/QuizContent/{moduleId}/Content/{contentId}/Publish";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPublish(_response);
        });
    }

    protected processPublish(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    downloadFile(moduleId: string, contentId: string, fileId: string, cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/QuizContent/{moduleId}/Content/{contentId}/File/{fileId}/Download";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadFile(_response);
        });
    }

    protected processDownloadFile(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    export(moduleId: string, contentId: string, cancelToken?: CancelToken | undefined): Promise<CreateModuleContentSettingsOfQuizSettings> {
        let url_ = this.baseUrl + "/v1/QuizContent/{moduleId}/Content/{contentId}/Export";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExport(_response);
        });
    }

    protected processExport(response: AxiosResponse): Promise<CreateModuleContentSettingsOfQuizSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CreateModuleContentSettingsOfQuizSettings.fromJS(resultData200);
            return Promise.resolve<CreateModuleContentSettingsOfQuizSettings>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateModuleContentSettingsOfQuizSettings>(null as any);
    }

    example( cancelToken?: CancelToken | undefined): Promise<QuizSettings> {
        let url_ = this.baseUrl + "/v1/QuizContent/Example";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExample(_response);
        });
    }

    protected processExample(response: AxiosResponse): Promise<QuizSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = QuizSettings.fromJS(resultData200);
            return Promise.resolve<QuizSettings>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<QuizSettings>(null as any);
    }

    schema( cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/QuizContent/Schema";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSchema(_response);
        });
    }

    protected processSchema(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class RevisionAttemptClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param moduleId (optional) 
     */
    getAllForActor(actorId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, moduleId: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfModuleAttemptOfRevisionResult> {
        let url_ = this.baseUrl + "/v1/RevisionAttempt/Actor/{actorId}?";
        if (actorId === undefined || actorId === null)
            throw new Error("The parameter 'actorId' must be defined.");
        url_ = url_.replace("{actorId}", encodeURIComponent("" + actorId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (moduleId !== undefined && moduleId !== null)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForActor(_response);
        });
    }

    protected processGetAllForActor(response: AxiosResponse): Promise<ListOfModuleAttemptOfRevisionResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfModuleAttemptOfRevisionResult.fromJS(resultData200);
            return Promise.resolve<ListOfModuleAttemptOfRevisionResult>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfModuleAttemptOfRevisionResult>(null as any);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param moduleId (optional) 
     * @param actorType (optional) 
     * @param from (optional) 
     * @param to (optional) 
     */
    getAllForGroup(groupId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, moduleId: string | null | undefined, actorType: ActorType | null | undefined, from: Date | null | undefined, to: Date | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfModuleAttemptOfRevisionResult> {
        let url_ = this.baseUrl + "/v1/RevisionAttempt/Group/{groupId}?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (moduleId !== undefined && moduleId !== null)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&";
        if (actorType !== undefined && actorType !== null)
            url_ += "actorType=" + encodeURIComponent("" + actorType) + "&";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForGroup(_response);
        });
    }

    protected processGetAllForGroup(response: AxiosResponse): Promise<ListOfModuleAttemptOfRevisionResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfModuleAttemptOfRevisionResult.fromJS(resultData200);
            return Promise.resolve<ListOfModuleAttemptOfRevisionResult>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfModuleAttemptOfRevisionResult>(null as any);
    }

    get(moduleAttemptId: string, cancelToken?: CancelToken | undefined): Promise<ModuleAttemptOfRevisionResult> {
        let url_ = this.baseUrl + "/v1/RevisionAttempt/{moduleAttemptId}";
        if (moduleAttemptId === undefined || moduleAttemptId === null)
            throw new Error("The parameter 'moduleAttemptId' must be defined.");
        url_ = url_.replace("{moduleAttemptId}", encodeURIComponent("" + moduleAttemptId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ModuleAttemptOfRevisionResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleAttemptOfRevisionResult.fromJS(resultData200);
            return Promise.resolve<ModuleAttemptOfRevisionResult>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleAttemptOfRevisionResult>(null as any);
    }

    update(moduleAttemptId: string, settings: UpdateModuleAttemptSettingsOfRevisionResult, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/RevisionAttempt/{moduleAttemptId}";
        if (moduleAttemptId === undefined || moduleAttemptId === null)
            throw new Error("The parameter 'moduleAttemptId' must be defined.");
        url_ = url_.replace("{moduleAttemptId}", encodeURIComponent("" + moduleAttemptId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    delete(moduleAttemptId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/RevisionAttempt/{moduleAttemptId}";
        if (moduleAttemptId === undefined || moduleAttemptId === null)
            throw new Error("The parameter 'moduleAttemptId' must be defined.");
        url_ = url_.replace("{moduleAttemptId}", encodeURIComponent("" + moduleAttemptId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    create(settings: CreateModuleAttemptSettingsOfRevisionResult, cancelToken?: CancelToken | undefined): Promise<ModuleAttemptOfRevisionResult> {
        let url_ = this.baseUrl + "/v1/RevisionAttempt";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ModuleAttemptOfRevisionResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleAttemptOfRevisionResult.fromJS(resultData200);
            return Promise.resolve<ModuleAttemptOfRevisionResult>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleAttemptOfRevisionResult>(null as any);
    }

    examplePass(moduleId: string, contentId: string, cancelToken?: CancelToken | undefined): Promise<RevisionResult> {
        let url_ = this.baseUrl + "/v1/RevisionAttempt/{moduleId}/Content/{contentId}/ExamplePass";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExamplePass(_response);
        });
    }

    protected processExamplePass(response: AxiosResponse): Promise<RevisionResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RevisionResult.fromJS(resultData200);
            return Promise.resolve<RevisionResult>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RevisionResult>(null as any);
    }
}

export class RevisionContentClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAll(moduleId: string, skip: number | undefined, take: number | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfModuleContentOfRevisionSettings> {
        let url_ = this.baseUrl + "/v1/RevisionContent/{moduleId}/Content?";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfModuleContentOfRevisionSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfModuleContentOfRevisionSettings.fromJS(resultData200);
            return Promise.resolve<ListOfModuleContentOfRevisionSettings>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfModuleContentOfRevisionSettings>(null as any);
    }

    create(moduleId: string, settings: CreateModuleContentSettingsOfRevisionSettings, cancelToken?: CancelToken | undefined): Promise<ModuleContentOfRevisionSettings> {
        let url_ = this.baseUrl + "/v1/RevisionContent/{moduleId}/Content";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ModuleContentOfRevisionSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleContentOfRevisionSettings.fromJS(resultData200);
            return Promise.resolve<ModuleContentOfRevisionSettings>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleContentOfRevisionSettings>(null as any);
    }

    get(moduleId: string, contentId: string, cancelToken?: CancelToken | undefined): Promise<ModuleContentOfRevisionSettings> {
        let url_ = this.baseUrl + "/v1/RevisionContent/{moduleId}/Content/{contentId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ModuleContentOfRevisionSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleContentOfRevisionSettings.fromJS(resultData200);
            return Promise.resolve<ModuleContentOfRevisionSettings>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleContentOfRevisionSettings>(null as any);
    }

    update(moduleId: string, contentId: string, settings: UpdateModuleContentSettingsOfRevisionSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/RevisionContent/{moduleId}/Content/{contentId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    delete(moduleId: string, contentId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/RevisionContent/{moduleId}/Content/{contentId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    createFromZip(moduleId: string, file: FileParameter | null | undefined, cancelToken?: CancelToken | undefined): Promise<ModuleContentOfRevisionSettings> {
        let url_ = this.baseUrl + "/v1/RevisionContent/{moduleId}/Content/FromZip";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateFromZip(_response);
        });
    }

    protected processCreateFromZip(response: AxiosResponse): Promise<ModuleContentOfRevisionSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleContentOfRevisionSettings.fromJS(resultData200);
            return Promise.resolve<ModuleContentOfRevisionSettings>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleContentOfRevisionSettings>(null as any);
    }

    updateFromZip(moduleId: string, contentId: string, file: FileParameter | null | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/RevisionContent/{moduleId}/Content/{contentId}/FromZip";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateFromZip(_response);
        });
    }

    protected processUpdateFromZip(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    publish(moduleId: string, contentId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/RevisionContent/{moduleId}/Content/{contentId}/Publish";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPublish(_response);
        });
    }

    protected processPublish(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    downloadFile(moduleId: string, contentId: string, fileId: string, cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/RevisionContent/{moduleId}/Content/{contentId}/File/{fileId}/Download";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadFile(_response);
        });
    }

    protected processDownloadFile(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    export(moduleId: string, contentId: string, cancelToken?: CancelToken | undefined): Promise<CreateModuleContentSettingsOfRevisionSettings> {
        let url_ = this.baseUrl + "/v1/RevisionContent/{moduleId}/Content/{contentId}/Export";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExport(_response);
        });
    }

    protected processExport(response: AxiosResponse): Promise<CreateModuleContentSettingsOfRevisionSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CreateModuleContentSettingsOfRevisionSettings.fromJS(resultData200);
            return Promise.resolve<CreateModuleContentSettingsOfRevisionSettings>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateModuleContentSettingsOfRevisionSettings>(null as any);
    }

    example( cancelToken?: CancelToken | undefined): Promise<RevisionSettings> {
        let url_ = this.baseUrl + "/v1/RevisionContent/Example";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExample(_response);
        });
    }

    protected processExample(response: AxiosResponse): Promise<RevisionSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RevisionSettings.fromJS(resultData200);
            return Promise.resolve<RevisionSettings>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RevisionSettings>(null as any);
    }

    schema( cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/RevisionContent/Schema";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSchema(_response);
        });
    }

    protected processSchema(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class TrainingSessionClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param groupId (optional) 
     * @param from (optional) 
     * @param status (optional) 
     */
    getAll(search: string | null | undefined, skip: number | undefined, take: number | undefined, groupId: string | null | undefined, from: Date | null | undefined, status: TrainingSessionStatus | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfTrainingSession> {
        let url_ = this.baseUrl + "/v1/TrainingSession?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (groupId !== undefined && groupId !== null)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (status !== undefined && status !== null)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfTrainingSession> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfTrainingSession.fromJS(resultData200);
            return Promise.resolve<ListOfTrainingSession>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfTrainingSession>(null as any);
    }

    create(settings: CreateTrainingSessionSettings, cancelToken?: CancelToken | undefined): Promise<TrainingSession> {
        let url_ = this.baseUrl + "/v1/TrainingSession";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<TrainingSession> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TrainingSession.fromJS(resultData200);
            return Promise.resolve<TrainingSession>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TrainingSession>(null as any);
    }

    get(trainingSessionId: string, cancelToken?: CancelToken | undefined): Promise<TrainingSession> {
        let url_ = this.baseUrl + "/v1/TrainingSession/{trainingSessionId}";
        if (trainingSessionId === undefined || trainingSessionId === null)
            throw new Error("The parameter 'trainingSessionId' must be defined.");
        url_ = url_.replace("{trainingSessionId}", encodeURIComponent("" + trainingSessionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<TrainingSession> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TrainingSession.fromJS(resultData200);
            return Promise.resolve<TrainingSession>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TrainingSession>(null as any);
    }

    update(trainingSessionId: string, settings: UpdateTrainingSessionSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/TrainingSession/{trainingSessionId}";
        if (trainingSessionId === undefined || trainingSessionId === null)
            throw new Error("The parameter 'trainingSessionId' must be defined.");
        url_ = url_.replace("{trainingSessionId}", encodeURIComponent("" + trainingSessionId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    delete(trainingSessionId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/TrainingSession/{trainingSessionId}";
        if (trainingSessionId === undefined || trainingSessionId === null)
            throw new Error("The parameter 'trainingSessionId' must be defined.");
        url_ = url_.replace("{trainingSessionId}", encodeURIComponent("" + trainingSessionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class VideoAttemptClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param moduleId (optional) 
     */
    getAllForActor(actorId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, moduleId: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfModuleAttemptOfVideoResult> {
        let url_ = this.baseUrl + "/v1/VideoAttempt/Actor/{actorId}?";
        if (actorId === undefined || actorId === null)
            throw new Error("The parameter 'actorId' must be defined.");
        url_ = url_.replace("{actorId}", encodeURIComponent("" + actorId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (moduleId !== undefined && moduleId !== null)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForActor(_response);
        });
    }

    protected processGetAllForActor(response: AxiosResponse): Promise<ListOfModuleAttemptOfVideoResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfModuleAttemptOfVideoResult.fromJS(resultData200);
            return Promise.resolve<ListOfModuleAttemptOfVideoResult>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfModuleAttemptOfVideoResult>(null as any);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param moduleId (optional) 
     * @param actorType (optional) 
     * @param from (optional) 
     * @param to (optional) 
     */
    getAllForGroup(groupId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, moduleId: string | null | undefined, actorType: ActorType | null | undefined, from: Date | null | undefined, to: Date | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfModuleAttemptOfVideoResult> {
        let url_ = this.baseUrl + "/v1/VideoAttempt/Group/{groupId}?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (moduleId !== undefined && moduleId !== null)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&";
        if (actorType !== undefined && actorType !== null)
            url_ += "actorType=" + encodeURIComponent("" + actorType) + "&";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForGroup(_response);
        });
    }

    protected processGetAllForGroup(response: AxiosResponse): Promise<ListOfModuleAttemptOfVideoResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfModuleAttemptOfVideoResult.fromJS(resultData200);
            return Promise.resolve<ListOfModuleAttemptOfVideoResult>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfModuleAttemptOfVideoResult>(null as any);
    }

    get(moduleAttemptId: string, cancelToken?: CancelToken | undefined): Promise<ModuleAttemptOfVideoResult> {
        let url_ = this.baseUrl + "/v1/VideoAttempt/{moduleAttemptId}";
        if (moduleAttemptId === undefined || moduleAttemptId === null)
            throw new Error("The parameter 'moduleAttemptId' must be defined.");
        url_ = url_.replace("{moduleAttemptId}", encodeURIComponent("" + moduleAttemptId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ModuleAttemptOfVideoResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleAttemptOfVideoResult.fromJS(resultData200);
            return Promise.resolve<ModuleAttemptOfVideoResult>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleAttemptOfVideoResult>(null as any);
    }

    update(moduleAttemptId: string, settings: UpdateModuleAttemptSettingsOfVideoResult, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/VideoAttempt/{moduleAttemptId}";
        if (moduleAttemptId === undefined || moduleAttemptId === null)
            throw new Error("The parameter 'moduleAttemptId' must be defined.");
        url_ = url_.replace("{moduleAttemptId}", encodeURIComponent("" + moduleAttemptId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    delete(moduleAttemptId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/VideoAttempt/{moduleAttemptId}";
        if (moduleAttemptId === undefined || moduleAttemptId === null)
            throw new Error("The parameter 'moduleAttemptId' must be defined.");
        url_ = url_.replace("{moduleAttemptId}", encodeURIComponent("" + moduleAttemptId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    create(settings: CreateModuleAttemptSettingsOfVideoResult, cancelToken?: CancelToken | undefined): Promise<ModuleAttemptOfVideoResult> {
        let url_ = this.baseUrl + "/v1/VideoAttempt";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ModuleAttemptOfVideoResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleAttemptOfVideoResult.fromJS(resultData200);
            return Promise.resolve<ModuleAttemptOfVideoResult>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleAttemptOfVideoResult>(null as any);
    }

    examplePass(moduleId: string, contentId: string, cancelToken?: CancelToken | undefined): Promise<VideoResult> {
        let url_ = this.baseUrl + "/v1/VideoAttempt/{moduleId}/Content/{contentId}/ExamplePass";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExamplePass(_response);
        });
    }

    protected processExamplePass(response: AxiosResponse): Promise<VideoResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = VideoResult.fromJS(resultData200);
            return Promise.resolve<VideoResult>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<VideoResult>(null as any);
    }
}

export class VideoContentClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAll(moduleId: string, skip: number | undefined, take: number | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfModuleContentOfVideoSettings> {
        let url_ = this.baseUrl + "/v1/VideoContent/{moduleId}/Content?";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfModuleContentOfVideoSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfModuleContentOfVideoSettings.fromJS(resultData200);
            return Promise.resolve<ListOfModuleContentOfVideoSettings>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfModuleContentOfVideoSettings>(null as any);
    }

    create(moduleId: string, settings: CreateModuleContentSettingsOfVideoSettings, cancelToken?: CancelToken | undefined): Promise<ModuleContentOfVideoSettings> {
        let url_ = this.baseUrl + "/v1/VideoContent/{moduleId}/Content";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ModuleContentOfVideoSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleContentOfVideoSettings.fromJS(resultData200);
            return Promise.resolve<ModuleContentOfVideoSettings>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleContentOfVideoSettings>(null as any);
    }

    get(moduleId: string, contentId: string, cancelToken?: CancelToken | undefined): Promise<ModuleContentOfVideoSettings> {
        let url_ = this.baseUrl + "/v1/VideoContent/{moduleId}/Content/{contentId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ModuleContentOfVideoSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleContentOfVideoSettings.fromJS(resultData200);
            return Promise.resolve<ModuleContentOfVideoSettings>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleContentOfVideoSettings>(null as any);
    }

    update(moduleId: string, contentId: string, settings: UpdateModuleContentSettingsOfVideoSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/VideoContent/{moduleId}/Content/{contentId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    delete(moduleId: string, contentId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/VideoContent/{moduleId}/Content/{contentId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    createFromZip(moduleId: string, file: FileParameter | null | undefined, cancelToken?: CancelToken | undefined): Promise<ModuleContentOfVideoSettings> {
        let url_ = this.baseUrl + "/v1/VideoContent/{moduleId}/Content/FromZip";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateFromZip(_response);
        });
    }

    protected processCreateFromZip(response: AxiosResponse): Promise<ModuleContentOfVideoSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleContentOfVideoSettings.fromJS(resultData200);
            return Promise.resolve<ModuleContentOfVideoSettings>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleContentOfVideoSettings>(null as any);
    }

    updateFromZip(moduleId: string, contentId: string, file: FileParameter | null | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/VideoContent/{moduleId}/Content/{contentId}/FromZip";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateFromZip(_response);
        });
    }

    protected processUpdateFromZip(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    publish(moduleId: string, contentId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/VideoContent/{moduleId}/Content/{contentId}/Publish";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPublish(_response);
        });
    }

    protected processPublish(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    downloadFile(moduleId: string, contentId: string, fileId: string, cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/VideoContent/{moduleId}/Content/{contentId}/File/{fileId}/Download";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadFile(_response);
        });
    }

    protected processDownloadFile(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    export(moduleId: string, contentId: string, cancelToken?: CancelToken | undefined): Promise<CreateModuleContentSettingsOfVideoSettings> {
        let url_ = this.baseUrl + "/v1/VideoContent/{moduleId}/Content/{contentId}/Export";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExport(_response);
        });
    }

    protected processExport(response: AxiosResponse): Promise<CreateModuleContentSettingsOfVideoSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CreateModuleContentSettingsOfVideoSettings.fromJS(resultData200);
            return Promise.resolve<CreateModuleContentSettingsOfVideoSettings>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateModuleContentSettingsOfVideoSettings>(null as any);
    }

    example( cancelToken?: CancelToken | undefined): Promise<VideoSettings> {
        let url_ = this.baseUrl + "/v1/VideoContent/Example";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExample(_response);
        });
    }

    protected processExample(response: AxiosResponse): Promise<VideoSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = VideoSettings.fromJS(resultData200);
            return Promise.resolve<VideoSettings>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<VideoSettings>(null as any);
    }

    schema( cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/VideoContent/Schema";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSchema(_response);
        });
    }

    protected processSchema(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class AssessmentAttemptClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param moduleId (optional) 
     */
    getAllForActor(actorId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, moduleId: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfModuleAttemptOfAssessmentResult> {
        let url_ = this.baseUrl + "/v1/AssessmentAttempt/Actor/{actorId}?";
        if (actorId === undefined || actorId === null)
            throw new Error("The parameter 'actorId' must be defined.");
        url_ = url_.replace("{actorId}", encodeURIComponent("" + actorId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (moduleId !== undefined && moduleId !== null)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForActor(_response);
        });
    }

    protected processGetAllForActor(response: AxiosResponse): Promise<ListOfModuleAttemptOfAssessmentResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfModuleAttemptOfAssessmentResult.fromJS(resultData200);
            return Promise.resolve<ListOfModuleAttemptOfAssessmentResult>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfModuleAttemptOfAssessmentResult>(null as any);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param moduleId (optional) 
     * @param actorType (optional) 
     * @param from (optional) 
     * @param to (optional) 
     */
    getAllForGroup(groupId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, moduleId: string | null | undefined, actorType: ActorType | null | undefined, from: Date | null | undefined, to: Date | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfModuleAttemptOfAssessmentResult> {
        let url_ = this.baseUrl + "/v1/AssessmentAttempt/Group/{groupId}?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (moduleId !== undefined && moduleId !== null)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&";
        if (actorType !== undefined && actorType !== null)
            url_ += "actorType=" + encodeURIComponent("" + actorType) + "&";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForGroup(_response);
        });
    }

    protected processGetAllForGroup(response: AxiosResponse): Promise<ListOfModuleAttemptOfAssessmentResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfModuleAttemptOfAssessmentResult.fromJS(resultData200);
            return Promise.resolve<ListOfModuleAttemptOfAssessmentResult>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfModuleAttemptOfAssessmentResult>(null as any);
    }

    get(moduleAttemptId: string, cancelToken?: CancelToken | undefined): Promise<ModuleAttemptOfAssessmentResult> {
        let url_ = this.baseUrl + "/v1/AssessmentAttempt/{moduleAttemptId}";
        if (moduleAttemptId === undefined || moduleAttemptId === null)
            throw new Error("The parameter 'moduleAttemptId' must be defined.");
        url_ = url_.replace("{moduleAttemptId}", encodeURIComponent("" + moduleAttemptId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ModuleAttemptOfAssessmentResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleAttemptOfAssessmentResult.fromJS(resultData200);
            return Promise.resolve<ModuleAttemptOfAssessmentResult>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleAttemptOfAssessmentResult>(null as any);
    }

    update(moduleAttemptId: string, settings: UpdateModuleAttemptSettingsOfAssessmentResult, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/AssessmentAttempt/{moduleAttemptId}";
        if (moduleAttemptId === undefined || moduleAttemptId === null)
            throw new Error("The parameter 'moduleAttemptId' must be defined.");
        url_ = url_.replace("{moduleAttemptId}", encodeURIComponent("" + moduleAttemptId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    delete(moduleAttemptId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/AssessmentAttempt/{moduleAttemptId}";
        if (moduleAttemptId === undefined || moduleAttemptId === null)
            throw new Error("The parameter 'moduleAttemptId' must be defined.");
        url_ = url_.replace("{moduleAttemptId}", encodeURIComponent("" + moduleAttemptId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    create(settings: CreateModuleAttemptSettingsOfAssessmentResult, cancelToken?: CancelToken | undefined): Promise<ModuleAttemptOfAssessmentResult> {
        let url_ = this.baseUrl + "/v1/AssessmentAttempt";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ModuleAttemptOfAssessmentResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleAttemptOfAssessmentResult.fromJS(resultData200);
            return Promise.resolve<ModuleAttemptOfAssessmentResult>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleAttemptOfAssessmentResult>(null as any);
    }

    examplePass(moduleId: string, contentId: string, cancelToken?: CancelToken | undefined): Promise<AssessmentResult> {
        let url_ = this.baseUrl + "/v1/AssessmentAttempt/{moduleId}/Content/{contentId}/ExamplePass";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExamplePass(_response);
        });
    }

    protected processExamplePass(response: AxiosResponse): Promise<AssessmentResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AssessmentResult.fromJS(resultData200);
            return Promise.resolve<AssessmentResult>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AssessmentResult>(null as any);
    }
}

export class AssessmentContentClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAll(moduleId: string, skip: number | undefined, take: number | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfModuleContentOfAssessmentSettings> {
        let url_ = this.baseUrl + "/v1/AssessmentContent/{moduleId}/Content?";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfModuleContentOfAssessmentSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfModuleContentOfAssessmentSettings.fromJS(resultData200);
            return Promise.resolve<ListOfModuleContentOfAssessmentSettings>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfModuleContentOfAssessmentSettings>(null as any);
    }

    create(moduleId: string, settings: CreateModuleContentSettingsOfAssessmentSettings, cancelToken?: CancelToken | undefined): Promise<ModuleContentOfAssessmentSettings> {
        let url_ = this.baseUrl + "/v1/AssessmentContent/{moduleId}/Content";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ModuleContentOfAssessmentSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleContentOfAssessmentSettings.fromJS(resultData200);
            return Promise.resolve<ModuleContentOfAssessmentSettings>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleContentOfAssessmentSettings>(null as any);
    }

    get(moduleId: string, contentId: string, cancelToken?: CancelToken | undefined): Promise<ModuleContentOfAssessmentSettings> {
        let url_ = this.baseUrl + "/v1/AssessmentContent/{moduleId}/Content/{contentId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ModuleContentOfAssessmentSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleContentOfAssessmentSettings.fromJS(resultData200);
            return Promise.resolve<ModuleContentOfAssessmentSettings>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleContentOfAssessmentSettings>(null as any);
    }

    update(moduleId: string, contentId: string, settings: UpdateModuleContentSettingsOfAssessmentSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/AssessmentContent/{moduleId}/Content/{contentId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    delete(moduleId: string, contentId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/AssessmentContent/{moduleId}/Content/{contentId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    createFromZip(moduleId: string, file: FileParameter | null | undefined, cancelToken?: CancelToken | undefined): Promise<ModuleContentOfAssessmentSettings> {
        let url_ = this.baseUrl + "/v1/AssessmentContent/{moduleId}/Content/FromZip";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateFromZip(_response);
        });
    }

    protected processCreateFromZip(response: AxiosResponse): Promise<ModuleContentOfAssessmentSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModuleContentOfAssessmentSettings.fromJS(resultData200);
            return Promise.resolve<ModuleContentOfAssessmentSettings>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ModuleContentOfAssessmentSettings>(null as any);
    }

    updateFromZip(moduleId: string, contentId: string, file: FileParameter | null | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/AssessmentContent/{moduleId}/Content/{contentId}/FromZip";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateFromZip(_response);
        });
    }

    protected processUpdateFromZip(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    publish(moduleId: string, contentId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/AssessmentContent/{moduleId}/Content/{contentId}/Publish";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPublish(_response);
        });
    }

    protected processPublish(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    downloadFile(moduleId: string, contentId: string, fileId: string, cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/AssessmentContent/{moduleId}/Content/{contentId}/File/{fileId}/Download";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadFile(_response);
        });
    }

    protected processDownloadFile(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    export(moduleId: string, contentId: string, cancelToken?: CancelToken | undefined): Promise<CreateModuleContentSettingsOfAssessmentSettings> {
        let url_ = this.baseUrl + "/v1/AssessmentContent/{moduleId}/Content/{contentId}/Export";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExport(_response);
        });
    }

    protected processExport(response: AxiosResponse): Promise<CreateModuleContentSettingsOfAssessmentSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CreateModuleContentSettingsOfAssessmentSettings.fromJS(resultData200);
            return Promise.resolve<CreateModuleContentSettingsOfAssessmentSettings>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateModuleContentSettingsOfAssessmentSettings>(null as any);
    }

    example( cancelToken?: CancelToken | undefined): Promise<AssessmentSettings> {
        let url_ = this.baseUrl + "/v1/AssessmentContent/Example";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExample(_response);
        });
    }

    protected processExample(response: AxiosResponse): Promise<AssessmentSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AssessmentSettings.fromJS(resultData200);
            return Promise.resolve<AssessmentSettings>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AssessmentSettings>(null as any);
    }

    schema( cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/AssessmentContent/Schema";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSchema(_response);
        });
    }

    protected processSchema(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class AssessmentSubAttemptClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param assessmentId (optional) 
     */
    getAllForActor(actorId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, assessmentId: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfAssessmentSubAttempt> {
        let url_ = this.baseUrl + "/v1/AssessmentSubAttempt/Actor/{actorId}?";
        if (actorId === undefined || actorId === null)
            throw new Error("The parameter 'actorId' must be defined.");
        url_ = url_.replace("{actorId}", encodeURIComponent("" + actorId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (assessmentId !== undefined && assessmentId !== null)
            url_ += "assessmentId=" + encodeURIComponent("" + assessmentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForActor(_response);
        });
    }

    protected processGetAllForActor(response: AxiosResponse): Promise<ListOfAssessmentSubAttempt> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfAssessmentSubAttempt.fromJS(resultData200);
            return Promise.resolve<ListOfAssessmentSubAttempt>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfAssessmentSubAttempt>(null as any);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param assessmentId (optional) 
     * @param actorType (optional) 
     * @param from (optional) 
     * @param to (optional) 
     */
    getAllForGroup(groupId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, assessmentId: string | null | undefined, actorType: ActorType | null | undefined, from: Date | null | undefined, to: Date | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfAssessmentSubAttempt> {
        let url_ = this.baseUrl + "/v1/AssessmentSubAttempt/Group/{groupId}?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (assessmentId !== undefined && assessmentId !== null)
            url_ += "assessmentId=" + encodeURIComponent("" + assessmentId) + "&";
        if (actorType !== undefined && actorType !== null)
            url_ += "actorType=" + encodeURIComponent("" + actorType) + "&";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForGroup(_response);
        });
    }

    protected processGetAllForGroup(response: AxiosResponse): Promise<ListOfAssessmentSubAttempt> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfAssessmentSubAttempt.fromJS(resultData200);
            return Promise.resolve<ListOfAssessmentSubAttempt>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfAssessmentSubAttempt>(null as any);
    }

    get(subAttemptId: string, cancelToken?: CancelToken | undefined): Promise<AssessmentSubAttempt> {
        let url_ = this.baseUrl + "/v1/AssessmentSubAttempt/{subAttemptId}";
        if (subAttemptId === undefined || subAttemptId === null)
            throw new Error("The parameter 'subAttemptId' must be defined.");
        url_ = url_.replace("{subAttemptId}", encodeURIComponent("" + subAttemptId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<AssessmentSubAttempt> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AssessmentSubAttempt.fromJS(resultData200);
            return Promise.resolve<AssessmentSubAttempt>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AssessmentSubAttempt>(null as any);
    }

    update(subAttemptId: string, settings: UpdateAssessmentSubAttemptSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/AssessmentSubAttempt/{subAttemptId}";
        if (subAttemptId === undefined || subAttemptId === null)
            throw new Error("The parameter 'subAttemptId' must be defined.");
        url_ = url_.replace("{subAttemptId}", encodeURIComponent("" + subAttemptId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    delete(subAttemptId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/AssessmentSubAttempt/{subAttemptId}";
        if (subAttemptId === undefined || subAttemptId === null)
            throw new Error("The parameter 'subAttemptId' must be defined.");
        url_ = url_.replace("{subAttemptId}", encodeURIComponent("" + subAttemptId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    create(settings: CreateAssessmentSubAttemptSettings, cancelToken?: CancelToken | undefined): Promise<AssessmentSubAttempt> {
        let url_ = this.baseUrl + "/v1/AssessmentSubAttempt";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<AssessmentSubAttempt> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AssessmentSubAttempt.fromJS(resultData200);
            return Promise.resolve<AssessmentSubAttempt>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AssessmentSubAttempt>(null as any);
    }
}

export class AuthenticationClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * Set authentication cookie
     */
    signIn(settings: AuthenticationSettings, cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/Authentication/SignIn";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSignIn(_response);
        });
    }

    protected processSignIn(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Clear authentication cookie
     */
    signOut( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Authentication/SignOut";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSignOut(_response);
        });
    }

    protected processSignOut(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Generate a TokenModel
     */
    token(settings: AuthenticationSettings, cancelToken?: CancelToken | undefined): Promise<ChallengeToken> {
        let url_ = this.baseUrl + "/v1/Authentication/Token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processToken(_response);
        });
    }

    protected processToken(response: AxiosResponse): Promise<ChallengeToken> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ChallengeToken.fromJS(resultData200);
            return Promise.resolve<ChallengeToken>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ChallengeToken>(null as any);
    }

    refreshToken( cancelToken?: CancelToken | undefined): Promise<Token> {
        let url_ = this.baseUrl + "/v1/Authentication/RefreshToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRefreshToken(_response);
        });
    }

    protected processRefreshToken(response: AxiosResponse): Promise<Token> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Token.fromJS(resultData200);
            return Promise.resolve<Token>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Token>(null as any);
    }

    /**
     * Generate a TokenModel on behalf of userId
     */
    impersonate(userId: string, cancelToken?: CancelToken | undefined): Promise<Token> {
        let url_ = this.baseUrl + "/v1/Authentication/Impersonate/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processImpersonate(_response);
        });
    }

    protected processImpersonate(response: AxiosResponse): Promise<Token> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Token.fromJS(resultData200);
            return Promise.resolve<Token>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Token>(null as any);
    }

    /**
     * Revert the supplied TokenModel to one with no
    impersonating data
     */
    unimpersonate( cancelToken?: CancelToken | undefined): Promise<Token> {
        let url_ = this.baseUrl + "/v1/Authentication/Unimpersonate";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUnimpersonate(_response);
        });
    }

    protected processUnimpersonate(response: AxiosResponse): Promise<Token> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Token.fromJS(resultData200);
            return Promise.resolve<Token>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Token>(null as any);
    }

    /**
     * Gets the Identity
     */
    identity( cancelToken?: CancelToken | undefined): Promise<Identity> {
        let url_ = this.baseUrl + "/v1/Authentication/Identity";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processIdentity(_response);
        });
    }

    protected processIdentity(response: AxiosResponse): Promise<Identity> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Identity.fromJS(resultData200);
            return Promise.resolve<Identity>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Identity>(null as any);
    }

    /**
     * Checks if the authenticated Identity has the given permission
     * @param permission (optional) The required permission
     * @param groupId (optional) The GroupId. If this is null or empty, all the current identity's
    groups will be searched.
     * @param orChildren (optional) If groupId is provided and orChildren
    is true, all child groups of groupId
    will also be checked
     * @return Returns true if the current identity is permitted
     * @deprecated
     */
    permitted(permission: string | null | undefined, groupId: string | null | undefined, orChildren: boolean | null | undefined, cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/v1/Authentication/Permitted?";
        if (permission !== undefined && permission !== null)
            url_ += "permission=" + encodeURIComponent("" + permission) + "&";
        if (groupId !== undefined && groupId !== null)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        if (orChildren !== undefined && orChildren !== null)
            url_ += "orChildren=" + encodeURIComponent("" + orChildren) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPermitted(_response);
        });
    }

    protected processPermitted(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param permission The required permission
     */
    permittedAll(permission: string, groupIds: string[], cancelToken?: CancelToken | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/v1/Authentication/Permitted/{permission}";
        if (permission === undefined || permission === null)
            throw new Error("The parameter 'permission' must be defined.");
        url_ = url_.replace("{permission}", encodeURIComponent("" + permission));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(groupIds);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPermittedAll(_response);
        });
    }

    protected processPermittedAll(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<string[]>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(null as any);
    }
}

export class CommunicationPreferencesClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    get(userId: string, cancelToken?: CancelToken | undefined): Promise<CommunicationPreferences> {
        let url_ = this.baseUrl + "/v1/CommunicationPreferences/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<CommunicationPreferences> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CommunicationPreferences.fromJS(resultData200);
            return Promise.resolve<CommunicationPreferences>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CommunicationPreferences>(null as any);
    }

    update(userId: string, settings: UpdateCommunicationPreferencesSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/CommunicationPreferences/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    unsubscribeGET(token: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<UnsubscribeToken> {
        let url_ = this.baseUrl + "/v1/CommunicationPreferences/Unsubscribe?";
        if (token !== undefined && token !== null)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUnsubscribeGET(_response);
        });
    }

    protected processUnsubscribeGET(response: AxiosResponse): Promise<UnsubscribeToken> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UnsubscribeToken.fromJS(resultData200);
            return Promise.resolve<UnsubscribeToken>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UnsubscribeToken>(null as any);
    }

    unsubscribePOST(token: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<UnsubscribeToken> {
        let url_ = this.baseUrl + "/v1/CommunicationPreferences/Unsubscribe?";
        if (token !== undefined && token !== null)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUnsubscribePOST(_response);
        });
    }

    protected processUnsubscribePOST(response: AxiosResponse): Promise<UnsubscribeToken> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UnsubscribeToken.fromJS(resultData200);
            return Promise.resolve<UnsubscribeToken>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UnsubscribeToken>(null as any);
    }
}

export class EmailRegistrationClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * Check if the given email is registered in the system.
     * @return 200 OK if the email is found, else a 404
     */
    get(settings: EmailSettings, cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/EmailRegistration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class GroupCommentClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param includeChildGroups (optional) 
     */
    getAll(groupId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, includeChildGroups: boolean | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfGroupComment> {
        let url_ = this.baseUrl + "/v1/Group/{groupId}/Comment?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (includeChildGroups === null)
            throw new Error("The parameter 'includeChildGroups' cannot be null.");
        else if (includeChildGroups !== undefined)
            url_ += "includeChildGroups=" + encodeURIComponent("" + includeChildGroups) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfGroupComment> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfGroupComment.fromJS(resultData200);
            return Promise.resolve<ListOfGroupComment>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfGroupComment>(null as any);
    }

    create(groupId: string, settings: CreateCommentSettings, cancelToken?: CancelToken | undefined): Promise<GroupComment> {
        let url_ = this.baseUrl + "/v1/Group/{groupId}/Comment";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<GroupComment> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GroupComment.fromJS(resultData200);
            return Promise.resolve<GroupComment>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GroupComment>(null as any);
    }

    get(groupId: string, commentId: string, cancelToken?: CancelToken | undefined): Promise<GroupComment> {
        let url_ = this.baseUrl + "/v1/Group/{groupId}/Comment/{commentId}";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<GroupComment> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GroupComment.fromJS(resultData200);
            return Promise.resolve<GroupComment>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GroupComment>(null as any);
    }

    update(groupId: string, commentId: string, settings: UpdateCommentSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Group/{groupId}/Comment/{commentId}";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    delete(groupId: string, commentId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Group/{groupId}/Comment/{commentId}";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAllReplies(groupId: string, commentId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfComment> {
        let url_ = this.baseUrl + "/v1/Group/{groupId}/Comment/{commentId}/Reply?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllReplies(_response);
        });
    }

    protected processGetAllReplies(response: AxiosResponse): Promise<ListOfComment> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfComment.fromJS(resultData200);
            return Promise.resolve<ListOfComment>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfComment>(null as any);
    }
}

export class GroupClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    get(groupId: string, cancelToken?: CancelToken | undefined): Promise<Group> {
        let url_ = this.baseUrl + "/v1/Group/{groupId}";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Group> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Group.fromJS(resultData200);
            return Promise.resolve<Group>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Group>(null as any);
    }
}

export class GroupFileClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param includeChildGroups (optional) 
     */
    getAll(groupId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, includeChildGroups: boolean | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfGroupFile> {
        let url_ = this.baseUrl + "/v1/Group/{groupId}/File?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (includeChildGroups === null)
            throw new Error("The parameter 'includeChildGroups' cannot be null.");
        else if (includeChildGroups !== undefined)
            url_ += "includeChildGroups=" + encodeURIComponent("" + includeChildGroups) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfGroupFile> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfGroupFile.fromJS(resultData200);
            return Promise.resolve<ListOfGroupFile>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfGroupFile>(null as any);
    }

    create(groupId: string, settings: CreateFileSettings, cancelToken?: CancelToken | undefined): Promise<GroupFile> {
        let url_ = this.baseUrl + "/v1/Group/{groupId}/File";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<GroupFile> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GroupFile.fromJS(resultData200);
            return Promise.resolve<GroupFile>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GroupFile>(null as any);
    }

    get(groupId: string, fileId: string, cancelToken?: CancelToken | undefined): Promise<GroupFile> {
        let url_ = this.baseUrl + "/v1/Group/{groupId}/File/{fileId}";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<GroupFile> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GroupFile.fromJS(resultData200);
            return Promise.resolve<GroupFile>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GroupFile>(null as any);
    }

    update(groupId: string, fileId: string, settings: UpdateFileSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Group/{groupId}/File/{fileId}";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    delete(groupId: string, fileId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Group/{groupId}/File/{fileId}";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    download(groupId: string, fileId: string, cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/Group/{groupId}/File/{fileId}/Download";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownload(_response);
        });
    }

    protected processDownload(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class JobTypeClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAll(search: string | null | undefined, skip: number | undefined, take: number | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfJobType> {
        let url_ = this.baseUrl + "/v1/JobType?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfJobType> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfJobType.fromJS(resultData200);
            return Promise.resolve<ListOfJobType>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfJobType>(null as any);
    }

    create(settings: CreateJobTypeSettings, cancelToken?: CancelToken | undefined): Promise<JobType> {
        let url_ = this.baseUrl + "/v1/JobType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<JobType> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JobType.fromJS(resultData200);
            return Promise.resolve<JobType>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JobType>(null as any);
    }

    get(jobTypeId: string, cancelToken?: CancelToken | undefined): Promise<JobType> {
        let url_ = this.baseUrl + "/v1/JobType/{jobTypeId}";
        if (jobTypeId === undefined || jobTypeId === null)
            throw new Error("The parameter 'jobTypeId' must be defined.");
        url_ = url_.replace("{jobTypeId}", encodeURIComponent("" + jobTypeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<JobType> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JobType.fromJS(resultData200);
            return Promise.resolve<JobType>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JobType>(null as any);
    }

    update(jobTypeId: string, settings: UpdateJobTypeSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/JobType/{jobTypeId}";
        if (jobTypeId === undefined || jobTypeId === null)
            throw new Error("The parameter 'jobTypeId' must be defined.");
        url_ = url_.replace("{jobTypeId}", encodeURIComponent("" + jobTypeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    delete(jobTypeId: string, version: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/JobType/{jobTypeId}?";
        if (jobTypeId === undefined || jobTypeId === null)
            throw new Error("The parameter 'jobTypeId' must be defined.");
        url_ = url_.replace("{jobTypeId}", encodeURIComponent("" + jobTypeId));
        if (version === null)
            throw new Error("The parameter 'version' cannot be null.");
        else if (version !== undefined)
            url_ += "version=" + encodeURIComponent("" + version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class LabelClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAllForGroup(groupId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfLabel> {
        let url_ = this.baseUrl + "/v1/Label/Group/{groupId}?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForGroup(_response);
        });
    }

    protected processGetAllForGroup(response: AxiosResponse): Promise<ListOfLabel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfLabel.fromJS(resultData200);
            return Promise.resolve<ListOfLabel>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfLabel>(null as any);
    }

    get(labelId: string, cancelToken?: CancelToken | undefined): Promise<Label> {
        let url_ = this.baseUrl + "/v1/Label/{labelId}";
        if (labelId === undefined || labelId === null)
            throw new Error("The parameter 'labelId' must be defined.");
        url_ = url_.replace("{labelId}", encodeURIComponent("" + labelId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Label> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Label.fromJS(resultData200);
            return Promise.resolve<Label>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Label>(null as any);
    }

    update(labelId: string, settings: UpdateLabelSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Label/{labelId}";
        if (labelId === undefined || labelId === null)
            throw new Error("The parameter 'labelId' must be defined.");
        url_ = url_.replace("{labelId}", encodeURIComponent("" + labelId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    delete(labelId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Label/{labelId}";
        if (labelId === undefined || labelId === null)
            throw new Error("The parameter 'labelId' must be defined.");
        url_ = url_.replace("{labelId}", encodeURIComponent("" + labelId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    create(settings: CreateLabelSettings, cancelToken?: CancelToken | undefined): Promise<Label> {
        let url_ = this.baseUrl + "/v1/Label";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Label> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Label.fromJS(resultData200);
            return Promise.resolve<Label>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Label>(null as any);
    }
}

export class MemberClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param status (optional) 
     * @param jobTypeIds (optional) 
     * @param jobCategories (optional) 
     * @param roles (optional) 
     * @param includeDeactivated (optional) 
     */
    getAllForGroup(groupId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, status: MemberStatus | null | undefined, jobTypeIds: string[] | null | undefined, jobCategories: string[] | null | undefined, roles: string[] | null | undefined, includeDeactivated: boolean | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfMember> {
        let url_ = this.baseUrl + "/v1/Member/Group/{groupId}?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (status !== undefined && status !== null)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (jobTypeIds !== undefined && jobTypeIds !== null)
            jobTypeIds && jobTypeIds.forEach(item => { url_ += "jobTypeIds=" + encodeURIComponent("" + item) + "&"; });
        if (jobCategories !== undefined && jobCategories !== null)
            jobCategories && jobCategories.forEach(item => { url_ += "jobCategories=" + encodeURIComponent("" + item) + "&"; });
        if (roles !== undefined && roles !== null)
            roles && roles.forEach(item => { url_ += "roles=" + encodeURIComponent("" + item) + "&"; });
        if (includeDeactivated !== undefined && includeDeactivated !== null)
            url_ += "includeDeactivated=" + encodeURIComponent("" + includeDeactivated) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForGroup(_response);
        });
    }

    protected processGetAllForGroup(response: AxiosResponse): Promise<ListOfMember> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfMember.fromJS(resultData200);
            return Promise.resolve<ListOfMember>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfMember>(null as any);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param status (optional) 
     * @param jobTypeIds (optional) 
     * @param jobCategories (optional) 
     * @param memberRoles (optional) 
     * @param identityPermission (optional) 
     * @param includeDeactivated (optional) 
     */
    getAllForChildGroups(groupId: string, childGroupType: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, status: MemberStatus | null | undefined, jobTypeIds: string[] | null | undefined, jobCategories: string[] | null | undefined, memberRoles: string[] | null | undefined, identityPermission: string | null | undefined, includeDeactivated: boolean | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfMember> {
        let url_ = this.baseUrl + "/v1/Member/Group/{groupId}/Child/{childGroupType}?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (childGroupType === undefined || childGroupType === null)
            throw new Error("The parameter 'childGroupType' must be defined.");
        url_ = url_.replace("{childGroupType}", encodeURIComponent("" + childGroupType));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (status !== undefined && status !== null)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (jobTypeIds !== undefined && jobTypeIds !== null)
            jobTypeIds && jobTypeIds.forEach(item => { url_ += "jobTypeIds=" + encodeURIComponent("" + item) + "&"; });
        if (jobCategories !== undefined && jobCategories !== null)
            jobCategories && jobCategories.forEach(item => { url_ += "jobCategories=" + encodeURIComponent("" + item) + "&"; });
        if (memberRoles !== undefined && memberRoles !== null)
            memberRoles && memberRoles.forEach(item => { url_ += "memberRoles=" + encodeURIComponent("" + item) + "&"; });
        if (identityPermission !== undefined && identityPermission !== null)
            url_ += "identityPermission=" + encodeURIComponent("" + identityPermission) + "&";
        if (includeDeactivated !== undefined && includeDeactivated !== null)
            url_ += "includeDeactivated=" + encodeURIComponent("" + includeDeactivated) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForChildGroups(_response);
        });
    }

    protected processGetAllForChildGroups(response: AxiosResponse): Promise<ListOfMember> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfMember.fromJS(resultData200);
            return Promise.resolve<ListOfMember>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfMember>(null as any);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param status (optional) 
     */
    getAllForUser(userId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, status: MemberStatus | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfMember> {
        let url_ = this.baseUrl + "/v1/Member/User/{userId}?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (status !== undefined && status !== null)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForUser(_response);
        });
    }

    protected processGetAllForUser(response: AxiosResponse): Promise<ListOfMember> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfMember.fromJS(resultData200);
            return Promise.resolve<ListOfMember>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfMember>(null as any);
    }

    /**
     * Gets the list of users in a group at the given time.
     * @param groupId Id of the group to get the users from.
     * @param at (optional) The UTC time at which to get users. If not specified, the current time is used.
     * @param status (optional) The status used to filter the result.
     * @param role (optional) The role used to filter the result
     * @return The list of users with their membership status and roles within the group at the given time.
     */
    getAllGroupHistory(groupId: string, at: Date | null | undefined, status: MemberStatus | null | undefined, role: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<MemberHistory[]> {
        let url_ = this.baseUrl + "/v1/Member/Group/{groupId}/History?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (at !== undefined && at !== null)
            url_ += "at=" + encodeURIComponent(at ? "" + at.toISOString() : "") + "&";
        if (status !== undefined && status !== null)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (role !== undefined && role !== null)
            url_ += "role=" + encodeURIComponent("" + role) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllGroupHistory(_response);
        });
    }

    protected processGetAllGroupHistory(response: AxiosResponse): Promise<MemberHistory[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MemberHistory.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<MemberHistory[]>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MemberHistory[]>(null as any);
    }

    get(groupId: string, userId: string, cancelToken?: CancelToken | undefined): Promise<Member> {
        let url_ = this.baseUrl + "/v1/Member/Group/{groupId}/User/{userId}";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Member> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Member.fromJS(resultData200);
            return Promise.resolve<Member>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Member>(null as any);
    }

    add(groupId: string, userId: string, settings: AddGroupMemberSettings, cancelToken?: CancelToken | undefined): Promise<Member> {
        let url_ = this.baseUrl + "/v1/Member/Group/{groupId}/User/{userId}/Add";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAdd(_response);
        });
    }

    protected processAdd(response: AxiosResponse): Promise<Member> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Member.fromJS(resultData200);
            return Promise.resolve<Member>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Member>(null as any);
    }

    join(groupId: string, cancelToken?: CancelToken | undefined): Promise<Member> {
        let url_ = this.baseUrl + "/v1/Member/Group/{groupId}/User/Join";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processJoin(_response);
        });
    }

    protected processJoin(response: AxiosResponse): Promise<Member> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Member.fromJS(resultData200);
            return Promise.resolve<Member>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Member>(null as any);
    }

    update(groupId: string, userId: string, settings: UpdateGroupMemberSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Member/Group/{groupId}/User/{userId}/Update";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    remove(groupId: string, userId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Member/Group/{groupId}/User/{userId}/Remove";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRemove(_response);
        });
    }

    protected processRemove(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    ban(groupId: string, userId: string, reason: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Member/Group/{groupId}/User/{userId}/Ban?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (reason !== undefined && reason !== null)
            url_ += "reason=" + encodeURIComponent("" + reason) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBan(_response);
        });
    }

    protected processBan(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    leave(groupId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Member/Group/{groupId}/User/Leave";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLeave(_response);
        });
    }

    protected processLeave(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    acceptGroupInvitation(invitationId: string, cancelToken?: CancelToken | undefined): Promise<Member> {
        let url_ = this.baseUrl + "/v1/Member/GroupInvitation/{invitationId}/Accept";
        if (invitationId === undefined || invitationId === null)
            throw new Error("The parameter 'invitationId' must be defined.");
        url_ = url_.replace("{invitationId}", encodeURIComponent("" + invitationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAcceptGroupInvitation(_response);
        });
    }

    protected processAcceptGroupInvitation(response: AxiosResponse): Promise<Member> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Member.fromJS(resultData200);
            return Promise.resolve<Member>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Member>(null as any);
    }

    emailAll(groupId: string | null | undefined, message: string | null | undefined, role: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Member/Email?";
        if (groupId !== undefined && groupId !== null)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        if (message !== undefined && message !== null)
            url_ += "message=" + encodeURIComponent("" + message) + "&";
        if (role !== undefined && role !== null)
            url_ += "role=" + encodeURIComponent("" + role) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEmailAll(_response);
        });
    }

    protected processEmailAll(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    email(groupId: string, userId: string, message: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Member/Group/{groupId}/User/{userId}/Email?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (message !== undefined && message !== null)
            url_ += "message=" + encodeURIComponent("" + message) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEmail(_response);
        });
    }

    protected processEmail(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class OrganisationAccessTokenClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param organisationId (optional) 
     */
    getAll(search: string | null | undefined, skip: number | undefined, take: number | undefined, organisationId: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfOrganisationAccessToken> {
        let url_ = this.baseUrl + "/v1/OrganisationAccessToken?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (organisationId !== undefined && organisationId !== null)
            url_ += "organisationId=" + encodeURIComponent("" + organisationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfOrganisationAccessToken> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfOrganisationAccessToken.fromJS(resultData200);
            return Promise.resolve<ListOfOrganisationAccessToken>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfOrganisationAccessToken>(null as any);
    }

    create(settings: CreateOrganisationAccessTokenSettings, cancelToken?: CancelToken | undefined): Promise<OrganisationAccessToken> {
        let url_ = this.baseUrl + "/v1/OrganisationAccessToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<OrganisationAccessToken> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OrganisationAccessToken.fromJS(resultData200);
            return Promise.resolve<OrganisationAccessToken>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrganisationAccessToken>(null as any);
    }

    getAll2(tokenId: string, cancelToken?: CancelToken | undefined): Promise<OrganisationAccessToken> {
        let url_ = this.baseUrl + "/v1/OrganisationAccessToken/{tokenId}";
        if (tokenId === undefined || tokenId === null)
            throw new Error("The parameter 'tokenId' must be defined.");
        url_ = url_.replace("{tokenId}", encodeURIComponent("" + tokenId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll2(_response);
        });
    }

    protected processGetAll2(response: AxiosResponse): Promise<OrganisationAccessToken> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OrganisationAccessToken.fromJS(resultData200);
            return Promise.resolve<OrganisationAccessToken>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrganisationAccessToken>(null as any);
    }

    delete(tokenId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/OrganisationAccessToken/{tokenId}";
        if (tokenId === undefined || tokenId === null)
            throw new Error("The parameter 'tokenId' must be defined.");
        url_ = url_.replace("{tokenId}", encodeURIComponent("" + tokenId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class OrganisationClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param identityPermissions (optional) 
     */
    getAll(search: string | null | undefined, skip: number | undefined, take: number | undefined, identityPermissions: string[] | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfOrganisation> {
        let url_ = this.baseUrl + "/v1/Organisation?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (identityPermissions !== undefined && identityPermissions !== null)
            identityPermissions && identityPermissions.forEach(item => { url_ += "identityPermissions=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfOrganisation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfOrganisation.fromJS(resultData200);
            return Promise.resolve<ListOfOrganisation>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfOrganisation>(null as any);
    }

    create(settings: CreateOrganisationSettings, cancelToken?: CancelToken | undefined): Promise<Organisation> {
        let url_ = this.baseUrl + "/v1/Organisation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Organisation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Organisation.fromJS(resultData200);
            return Promise.resolve<Organisation>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Organisation>(null as any);
    }

    get(organisationId: string, cancelToken?: CancelToken | undefined): Promise<Organisation> {
        let url_ = this.baseUrl + "/v1/Organisation/{organisationId}";
        if (organisationId === undefined || organisationId === null)
            throw new Error("The parameter 'organisationId' must be defined.");
        url_ = url_.replace("{organisationId}", encodeURIComponent("" + organisationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Organisation> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Organisation.fromJS(resultData200);
            return Promise.resolve<Organisation>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Organisation>(null as any);
    }

    update(organisationId: string, settings: UpdateOrganisationSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Organisation/{organisationId}";
        if (organisationId === undefined || organisationId === null)
            throw new Error("The parameter 'organisationId' must be defined.");
        url_ = url_.replace("{organisationId}", encodeURIComponent("" + organisationId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    delete(organisationId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Organisation/{organisationId}";
        if (organisationId === undefined || organisationId === null)
            throw new Error("The parameter 'organisationId' must be defined.");
        url_ = url_.replace("{organisationId}", encodeURIComponent("" + organisationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class PasswordClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    get(userId: string, cancelToken?: CancelToken | undefined): Promise<Password> {
        let url_ = this.baseUrl + "/v1/Password/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Password> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Password.fromJS(resultData200);
            return Promise.resolve<Password>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Password>(null as any);
    }

    update(userId: string, settings: UpdatePasswordSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Password/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    updateTwoFactorAuthentication(userId: string, settings: UpdateTwoFactorAuthenticationSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Password/{userId}/UpdateTwoFactorAuthentication";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateTwoFactorAuthentication(_response);
        });
    }

    protected processUpdateTwoFactorAuthentication(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    requestReset(settings: RequestResetPasswordSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Password/RequestReset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRequestReset(_response);
        });
    }

    protected processRequestReset(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    reset(settings: ResetPasswordSettings, cancelToken?: CancelToken | undefined): Promise<Token> {
        let url_ = this.baseUrl + "/v1/Password/Reset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReset(_response);
        });
    }

    protected processReset(response: AxiosResponse): Promise<Token> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Token.fromJS(resultData200);
            return Promise.resolve<Token>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Token>(null as any);
    }
}

export class PhoneNumberRegistrationClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * Check if the phoneNumber is registered in the system
     * @return 200 OK if the phoneNumber is found, else a 404
     */
    get(phoneNumber: string, cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/PhoneNumberRegistration/{phoneNumber}";
        if (phoneNumber === undefined || phoneNumber === null)
            throw new Error("The parameter 'phoneNumber' must be defined.");
        url_ = url_.replace("{phoneNumber}", encodeURIComponent("" + phoneNumber));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class RoleClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    getAll(groupType: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfRole> {
        let url_ = this.baseUrl + "/v1/Role?";
        if (groupType !== undefined && groupType !== null)
            url_ += "groupType=" + encodeURIComponent("" + groupType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfRole> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfRole.fromJS(resultData200);
            return Promise.resolve<ListOfRole>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfRole>(null as any);
    }

    get(roleName: string, cancelToken?: CancelToken | undefined): Promise<Role> {
        let url_ = this.baseUrl + "/v1/Role/{roleName}";
        if (roleName === undefined || roleName === null)
            throw new Error("The parameter 'roleName' must be defined.");
        url_ = url_.replace("{roleName}", encodeURIComponent("" + roleName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Role> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Role.fromJS(resultData200);
            return Promise.resolve<Role>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Role>(null as any);
    }
}

export class TeamClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param organisationId (optional) 
     * @param identityPermissions (optional) 
     */
    getAll(search: string | null | undefined, skip: number | undefined, take: number | undefined, organisationId: string | null | undefined, identityPermissions: string[] | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfTeam> {
        let url_ = this.baseUrl + "/v1/Team?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (organisationId !== undefined && organisationId !== null)
            url_ += "organisationId=" + encodeURIComponent("" + organisationId) + "&";
        if (identityPermissions !== undefined && identityPermissions !== null)
            identityPermissions && identityPermissions.forEach(item => { url_ += "identityPermissions=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfTeam> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfTeam.fromJS(resultData200);
            return Promise.resolve<ListOfTeam>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfTeam>(null as any);
    }

    create(settings: CreateTeamSettings, cancelToken?: CancelToken | undefined): Promise<Team> {
        let url_ = this.baseUrl + "/v1/Team";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Team> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Team.fromJS(resultData200);
            return Promise.resolve<Team>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Team>(null as any);
    }

    get(teamId: string, cancelToken?: CancelToken | undefined): Promise<Team> {
        let url_ = this.baseUrl + "/v1/Team/{teamId}";
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Team> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Team.fromJS(resultData200);
            return Promise.resolve<Team>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Team>(null as any);
    }

    update(teamId: string, settings: UpdateTeamSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Team/{teamId}";
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    delete(teamId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Team/{teamId}";
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class UserActivityClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param moduleType (optional) 
     * @param programId (optional) 
     * @param from (optional) 
     * @param to (optional) 
     */
    getAllForGroup(groupId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, moduleType: string | null | undefined, programId: string | null | undefined, from: Date | null | undefined, to: Date | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfUserActivity> {
        let url_ = this.baseUrl + "/v1/UserActivity/Group/{groupId}?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (moduleType !== undefined && moduleType !== null)
            url_ += "moduleType=" + encodeURIComponent("" + moduleType) + "&";
        if (programId !== undefined && programId !== null)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForGroup(_response);
        });
    }

    protected processGetAllForGroup(response: AxiosResponse): Promise<ListOfUserActivity> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfUserActivity.fromJS(resultData200);
            return Promise.resolve<ListOfUserActivity>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfUserActivity>(null as any);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     * @param moduleType (optional) 
     * @param programId (optional) 
     * @param from (optional) 
     * @param to (optional) 
     */
    getAllForPublisher(publisherId: string, search: string | null | undefined, skip: number | undefined, take: number | undefined, moduleType: string | null | undefined, programId: string | null | undefined, from: Date | null | undefined, to: Date | null | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfUserActivity> {
        let url_ = this.baseUrl + "/v1/UserActivity/Publisher/{publisherId}?";
        if (publisherId === undefined || publisherId === null)
            throw new Error("The parameter 'publisherId' must be defined.");
        url_ = url_.replace("{publisherId}", encodeURIComponent("" + publisherId));
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (moduleType !== undefined && moduleType !== null)
            url_ += "moduleType=" + encodeURIComponent("" + moduleType) + "&";
        if (programId !== undefined && programId !== null)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllForPublisher(_response);
        });
    }

    protected processGetAllForPublisher(response: AxiosResponse): Promise<ListOfUserActivity> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfUserActivity.fromJS(resultData200);
            return Promise.resolve<ListOfUserActivity>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfUserActivity>(null as any);
    }
}

export class UserClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) The number (0 - 1000 inclusive) of items to get from the API.
     */
    getAll(search: string | null | undefined, skip: number | undefined, take: number | undefined, cancelToken?: CancelToken | undefined): Promise<ListOfUser> {
        let url_ = this.baseUrl + "/v1/User?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ListOfUser> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOfUser.fromJS(resultData200);
            return Promise.resolve<ListOfUser>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOfUser>(null as any);
    }

    create(settings: CreateUserSettings, cancelToken?: CancelToken | undefined): Promise<User> {
        let url_ = this.baseUrl + "/v1/User";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<User> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = User.fromJS(resultData200);
            return Promise.resolve<User>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<User>(null as any);
    }

    get(userId: string, cancelToken?: CancelToken | undefined): Promise<User> {
        let url_ = this.baseUrl + "/v1/User/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<User> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = User.fromJS(resultData200);
            return Promise.resolve<User>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<User>(null as any);
    }

    update(userId: string, settings: UpdateUserSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/User/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    delete(userId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/User/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    onboard(settings: OnboardUserSettings, cancelToken?: CancelToken | undefined): Promise<User> {
        let url_ = this.baseUrl + "/v1/User/Onboard";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOnboard(_response);
        });
    }

    protected processOnboard(response: AxiosResponse): Promise<User> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = User.fromJS(resultData200);
            return Promise.resolve<User>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<User>(null as any);
    }

    activate(userId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/User/{userId}/Activate";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processActivate(_response);
        });
    }

    protected processActivate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    merge(settings: MergeUserSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/User/Merge";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMerge(_response);
        });
    }

    protected processMerge(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    contact(userId: string, message: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/User/{userId}/Contact?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (message !== undefined && message !== null)
            url_ += "message=" + encodeURIComponent("" + message) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processContact(_response);
        });
    }

    protected processContact(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    sendWelcomeEmail(userId: string, settings: SendWelcomeEmailSettings, cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/User/{userId}/SendWelcomeEmail";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSendWelcomeEmail(_response);
        });
    }

    protected processSendWelcomeEmail(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    welcomeEmailTemplate(userName: string | null | undefined, userEmail: string | null | undefined, creatorName: string | null | undefined, message_CreatorName: string | null | undefined, message_CreatorImageUri: string | null | undefined, message_CreatorDescription: string | null | undefined, message_Message: string | null | undefined, welcomeButtonUri: string | null | undefined, welcomeButtonText: string | null | undefined, group_Title: string | null | undefined, group_ImageUri: string | null | undefined, group_Uri: string | null | undefined, group_Description: string | null | undefined, group_Subtitle: string | null | undefined, group_SubtitleImageUri: string | null | undefined, group_ActionButton: string | null | undefined, group_ActionUri: string | null | undefined, applicationName: string | null | undefined, productName: string | null | undefined, supportUri: string | null | undefined, termOfServiceUri: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/User/WelcomeEmailTemplate?";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (userEmail !== undefined && userEmail !== null)
            url_ += "UserEmail=" + encodeURIComponent("" + userEmail) + "&";
        if (creatorName !== undefined && creatorName !== null)
            url_ += "CreatorName=" + encodeURIComponent("" + creatorName) + "&";
        if (message_CreatorName !== undefined && message_CreatorName !== null)
            url_ += "Message.CreatorName=" + encodeURIComponent("" + message_CreatorName) + "&";
        if (message_CreatorImageUri !== undefined && message_CreatorImageUri !== null)
            url_ += "Message.CreatorImageUri=" + encodeURIComponent("" + message_CreatorImageUri) + "&";
        if (message_CreatorDescription !== undefined && message_CreatorDescription !== null)
            url_ += "Message.CreatorDescription=" + encodeURIComponent("" + message_CreatorDescription) + "&";
        if (message_Message !== undefined && message_Message !== null)
            url_ += "Message.Message=" + encodeURIComponent("" + message_Message) + "&";
        if (welcomeButtonUri !== undefined && welcomeButtonUri !== null)
            url_ += "WelcomeButtonUri=" + encodeURIComponent("" + welcomeButtonUri) + "&";
        if (welcomeButtonText !== undefined && welcomeButtonText !== null)
            url_ += "WelcomeButtonText=" + encodeURIComponent("" + welcomeButtonText) + "&";
        if (group_Title !== undefined && group_Title !== null)
            url_ += "Group.Title=" + encodeURIComponent("" + group_Title) + "&";
        if (group_ImageUri !== undefined && group_ImageUri !== null)
            url_ += "Group.ImageUri=" + encodeURIComponent("" + group_ImageUri) + "&";
        if (group_Uri !== undefined && group_Uri !== null)
            url_ += "Group.Uri=" + encodeURIComponent("" + group_Uri) + "&";
        if (group_Description !== undefined && group_Description !== null)
            url_ += "Group.Description=" + encodeURIComponent("" + group_Description) + "&";
        if (group_Subtitle !== undefined && group_Subtitle !== null)
            url_ += "Group.Subtitle=" + encodeURIComponent("" + group_Subtitle) + "&";
        if (group_SubtitleImageUri !== undefined && group_SubtitleImageUri !== null)
            url_ += "Group.SubtitleImageUri=" + encodeURIComponent("" + group_SubtitleImageUri) + "&";
        if (group_ActionButton !== undefined && group_ActionButton !== null)
            url_ += "Group.ActionButton=" + encodeURIComponent("" + group_ActionButton) + "&";
        if (group_ActionUri !== undefined && group_ActionUri !== null)
            url_ += "Group.ActionUri=" + encodeURIComponent("" + group_ActionUri) + "&";
        if (applicationName !== undefined && applicationName !== null)
            url_ += "ApplicationName=" + encodeURIComponent("" + applicationName) + "&";
        if (productName !== undefined && productName !== null)
            url_ += "ProductName=" + encodeURIComponent("" + productName) + "&";
        if (supportUri !== undefined && supportUri !== null)
            url_ += "SupportUri=" + encodeURIComponent("" + supportUri) + "&";
        if (termOfServiceUri !== undefined && termOfServiceUri !== null)
            url_ += "TermOfServiceUri=" + encodeURIComponent("" + termOfServiceUri) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processWelcomeEmailTemplate(_response);
        });
    }

    protected processWelcomeEmailTemplate(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    contactEmailTemplate(userName: string | null | undefined, creatorEmail: string | null | undefined, creatorName: string | null | undefined, message_CreatorName: string | null | undefined, message_CreatorImageUri: string | null | undefined, message_CreatorDescription: string | null | undefined, message_Message: string | null | undefined, group_Title: string | null | undefined, group_ImageUri: string | null | undefined, group_Uri: string | null | undefined, group_Description: string | null | undefined, group_Subtitle: string | null | undefined, group_SubtitleImageUri: string | null | undefined, group_ActionButton: string | null | undefined, group_ActionUri: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/User/ContactEmailTemplate?";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (creatorEmail !== undefined && creatorEmail !== null)
            url_ += "CreatorEmail=" + encodeURIComponent("" + creatorEmail) + "&";
        if (creatorName !== undefined && creatorName !== null)
            url_ += "CreatorName=" + encodeURIComponent("" + creatorName) + "&";
        if (message_CreatorName !== undefined && message_CreatorName !== null)
            url_ += "Message.CreatorName=" + encodeURIComponent("" + message_CreatorName) + "&";
        if (message_CreatorImageUri !== undefined && message_CreatorImageUri !== null)
            url_ += "Message.CreatorImageUri=" + encodeURIComponent("" + message_CreatorImageUri) + "&";
        if (message_CreatorDescription !== undefined && message_CreatorDescription !== null)
            url_ += "Message.CreatorDescription=" + encodeURIComponent("" + message_CreatorDescription) + "&";
        if (message_Message !== undefined && message_Message !== null)
            url_ += "Message.Message=" + encodeURIComponent("" + message_Message) + "&";
        if (group_Title !== undefined && group_Title !== null)
            url_ += "Group.Title=" + encodeURIComponent("" + group_Title) + "&";
        if (group_ImageUri !== undefined && group_ImageUri !== null)
            url_ += "Group.ImageUri=" + encodeURIComponent("" + group_ImageUri) + "&";
        if (group_Uri !== undefined && group_Uri !== null)
            url_ += "Group.Uri=" + encodeURIComponent("" + group_Uri) + "&";
        if (group_Description !== undefined && group_Description !== null)
            url_ += "Group.Description=" + encodeURIComponent("" + group_Description) + "&";
        if (group_Subtitle !== undefined && group_Subtitle !== null)
            url_ += "Group.Subtitle=" + encodeURIComponent("" + group_Subtitle) + "&";
        if (group_SubtitleImageUri !== undefined && group_SubtitleImageUri !== null)
            url_ += "Group.SubtitleImageUri=" + encodeURIComponent("" + group_SubtitleImageUri) + "&";
        if (group_ActionButton !== undefined && group_ActionButton !== null)
            url_ += "Group.ActionButton=" + encodeURIComponent("" + group_ActionButton) + "&";
        if (group_ActionUri !== undefined && group_ActionUri !== null)
            url_ += "Group.ActionUri=" + encodeURIComponent("" + group_ActionUri) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processContactEmailTemplate(_response);
        });
    }

    protected processContactEmailTemplate(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class UserEmailClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    get(userId: string, cancelToken?: CancelToken | undefined): Promise<UserEmails> {
        let url_ = this.baseUrl + "/v1/UserEmail/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<UserEmails> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserEmails.fromJS(resultData200);
            return Promise.resolve<UserEmails>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserEmails>(null as any);
    }

    add(userId: string, settings: UserEmailSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/UserEmail/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAdd(_response);
        });
    }

    protected processAdd(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    remove(userId: string, settings: UserEmailSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/UserEmail/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "DELETE",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRemove(_response);
        });
    }

    protected processRemove(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    changePrimary(userId: string, settings: UserEmailSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/UserEmail/{userId}/ChangePrimary";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangePrimary(_response);
        });
    }

    protected processChangePrimary(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    sendVerification(userId: string, settings: UserEmailSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/UserEmail/{userId}/SendVerification";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSendVerification(_response);
        });
    }

    protected processSendVerification(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    verifyGET(verificationToken: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<UserEmailVerificationToken> {
        let url_ = this.baseUrl + "/v1/UserEmail/Verify?";
        if (verificationToken !== undefined && verificationToken !== null)
            url_ += "verificationToken=" + encodeURIComponent("" + verificationToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVerifyGET(_response);
        });
    }

    protected processVerifyGET(response: AxiosResponse): Promise<UserEmailVerificationToken> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserEmailVerificationToken.fromJS(resultData200);
            return Promise.resolve<UserEmailVerificationToken>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserEmailVerificationToken>(null as any);
    }

    verifyPOST(verificationToken: string, cancelToken?: CancelToken | undefined): Promise<UserEmailVerificationToken> {
        let url_ = this.baseUrl + "/v1/UserEmail/Verify/{verificationToken}";
        if (verificationToken === undefined || verificationToken === null)
            throw new Error("The parameter 'verificationToken' must be defined.");
        url_ = url_.replace("{verificationToken}", encodeURIComponent("" + verificationToken));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVerifyPOST(_response);
        });
    }

    protected processVerifyPOST(response: AxiosResponse): Promise<UserEmailVerificationToken> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserEmailVerificationToken.fromJS(resultData200);
            return Promise.resolve<UserEmailVerificationToken>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserEmailVerificationToken>(null as any);
    }

    contact(userId: string, message: string | null | undefined, groupId: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/UserEmail/{userId}/Contact?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (message !== undefined && message !== null)
            url_ += "message=" + encodeURIComponent("" + message) + "&";
        if (groupId !== undefined && groupId !== null)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processContact(_response);
        });
    }

    protected processContact(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class UserPhoneNumberClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    get(userId: string, cancelToken?: CancelToken | undefined): Promise<UserPhoneNumber> {
        let url_ = this.baseUrl + "/v1/UserPhoneNumber/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<UserPhoneNumber> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserPhoneNumber.fromJS(resultData200);
            return Promise.resolve<UserPhoneNumber>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserPhoneNumber>(null as any);
    }

    update(userId: string, settings: UpdateUserPhoneNumberSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/UserPhoneNumber/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    sendVerification(userId: string, cancelToken?: CancelToken | undefined): Promise<VerificationRequestResult> {
        let url_ = this.baseUrl + "/v1/UserPhoneNumber/{userId}/SendVerification";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSendVerification(_response);
        });
    }

    protected processSendVerification(response: AxiosResponse): Promise<VerificationRequestResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = VerificationRequestResult.fromJS(resultData200);
            return Promise.resolve<VerificationRequestResult>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<VerificationRequestResult>(null as any);
    }

    verify(verificationCode: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/UserPhoneNumber/Verify/{verificationCode}";
        if (verificationCode === undefined || verificationCode === null)
            throw new Error("The parameter 'verificationCode' must be defined.");
        url_ = url_.replace("{verificationCode}", encodeURIComponent("" + verificationCode));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVerify(_response);
        });
    }

    protected processVerify(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("You are not permitted to view this.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("This resource could not be found.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException("Service unavailable. Please try again later.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException("Request timed out. Please try again.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ListOfEmail {
    totalItemCount!: number;
    items!: Email[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Email.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfEmail {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfEmail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class Email {
    id?: string | undefined;
    type?: EmailType;
    from?: EmailAddress | undefined;
    replyTo?: EmailAddress | undefined;
    to?: EmailAddress | undefined;
    subject?: string | undefined;
    bodyHtml?: string | undefined;
    created?: Date;
    modified?: Date;
    status?: EmailStatus;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.from = _data["from"] ? EmailAddress.fromJS(_data["from"]) : <any>undefined;
            this.replyTo = _data["replyTo"] ? EmailAddress.fromJS(_data["replyTo"]) : <any>undefined;
            this.to = _data["to"] ? EmailAddress.fromJS(_data["to"]) : <any>undefined;
            this.subject = _data["subject"];
            this.bodyHtml = _data["bodyHtml"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): Email {
        data = typeof data === 'object' ? data : {};
        let result = new Email();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["from"] = this.from ? this.from.toJSON() : <any>undefined;
        data["replyTo"] = this.replyTo ? this.replyTo.toJSON() : <any>undefined;
        data["to"] = this.to ? this.to.toJSON() : <any>undefined;
        data["subject"] = this.subject;
        data["bodyHtml"] = this.bodyHtml;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data;
    }
}

export enum EmailType {
    None = "None",
    EventInvite = "EventInvite",
    EventChanged = "EventChanged",
    ScheduledLink = "ScheduledLink",
    RequestSurvey = "RequestSurvey",
    AddedToGroup = "AddedToGroup",
    AddedToClass = "AddedToClass",
    ModuleAttempt = "ModuleAttempt",
    Authentication = "Authentication",
    Confirm = "Confirm",
    ContactUser = "ContactUser",
    PublishingRequested = "PublishingRequested",
    PublishingRequestApproved = "PublishingRequestApproved",
    PublishingRequestRejected = "PublishingRequestRejected",
    Welcome = "Welcome",
    Support = "Support",
    SupportConfirmation = "SupportConfirmation",
    SupportStatusChanged = "SupportStatusChanged",
    RequestResetPassword = "RequestResetPassword",
    RequestResetPasswordFailed = "RequestResetPasswordFailed",
    PasswordChanged = "PasswordChanged",
    PrimaryEmailChanged = "PrimaryEmailChanged",
}

export class EmailAddress {
    address?: string | undefined;
    name?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.address = _data["address"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): EmailAddress {
        data = typeof data === 'object' ? data : {};
        let result = new EmailAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address;
        data["name"] = this.name;
        return data;
    }
}

/** 0 = None 1 = Submitted 2 = Received 3 = Read 4 = Clicked 5 = Spammed 6 = Error */
export enum EmailStatus {
    None = 0,
    Submitted = 1,
    Received = 2,
    Read = 3,
    Clicked = 4,
    Spammed = 5,
    Error = 6,
}

export class ListOfUserAttendance {
    totalItemCount!: number;
    items!: UserAttendance[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserAttendance.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfUserAttendance {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfUserAttendance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class Attendance {
    id?: string | undefined;
    memberId?: string | undefined;
    status?: AttendanceStatus;
    created?: Date;
    modified?: Date;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.memberId = _data["memberId"];
            this.status = _data["status"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): Attendance {
        data = typeof data === 'object' ? data : {};
        let result = new Attendance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["memberId"] = this.memberId;
        data["status"] = this.status;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        data["version"] = this.version;
        return data;
    }
}

export class UserAttendance extends Attendance {
    userId?: string | undefined;
    userName?: string | undefined;
    userImageUri?: string | undefined;
    userJobTypeId?: string | undefined;
    userJobTypeName?: string | undefined;
    userJobTypeCategory?: string | undefined;
    userQualifications?: string | undefined;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.userImageUri = _data["userImageUri"];
            this.userJobTypeId = _data["userJobTypeId"];
            this.userJobTypeName = _data["userJobTypeName"];
            this.userJobTypeCategory = _data["userJobTypeCategory"];
            this.userQualifications = _data["userQualifications"];
        }
    }

    static fromJS(data: any): UserAttendance {
        data = typeof data === 'object' ? data : {};
        let result = new UserAttendance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["userImageUri"] = this.userImageUri;
        data["userJobTypeId"] = this.userJobTypeId;
        data["userJobTypeName"] = this.userJobTypeName;
        data["userJobTypeCategory"] = this.userJobTypeCategory;
        data["userQualifications"] = this.userQualifications;
        super.toJSON(data);
        return data;
    }
}

/** 0 = None 1 = Yes 2 = No 3 = Maybe */
export enum AttendanceStatus {
    None = 0,
    Yes = 1,
    No = 2,
    Maybe = 3,
}

export class UpdateAttendanceSettings {
    status?: AttendanceStatus;
    version!: number;

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateAttendanceSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAttendanceSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["version"] = this.version;
        return data;
    }
}

export class ListOfMeeting {
    totalItemCount!: number;
    items!: Meeting[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Meeting.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfMeeting {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfMeeting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class Meeting {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    start?: Date | undefined;
    end?: Date | undefined;
    location?: Location;
    parentId?: string | undefined;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.start = _data["start"] ? new Date(_data["start"].toString()) : <any>undefined;
            this.end = _data["end"] ? new Date(_data["end"].toString()) : <any>undefined;
            this.location = _data["location"] ? Location.fromJS(_data["location"]) : <any>undefined;
            this.parentId = _data["parentId"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): Meeting {
        data = typeof data === 'object' ? data : {};
        let result = new Meeting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["start"] = this.start ? this.start.toISOString() : <any>undefined;
        data["end"] = this.end ? this.end.toISOString() : <any>undefined;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["parentId"] = this.parentId;
        data["version"] = this.version;
        return data;
    }
}

export class Location {
    address?: string | undefined;
    coordinates?: Coordinates;

    init(_data?: any) {
        if (_data) {
            this.address = _data["address"];
            this.coordinates = _data["coordinates"] ? Coordinates.fromJS(_data["coordinates"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Location {
        data = typeof data === 'object' ? data : {};
        let result = new Location();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address;
        data["coordinates"] = this.coordinates ? this.coordinates.toJSON() : <any>undefined;
        return data;
    }
}

export class Coordinates {
    longitude?: number;
    latitude?: number;

    init(_data?: any) {
        if (_data) {
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
        }
    }

    static fromJS(data: any): Coordinates {
        data = typeof data === 'object' ? data : {};
        let result = new Coordinates();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        return data;
    }
}

export class CreateMeetingSettings {
    parentId!: string;
    name!: string;
    description?: string | undefined;
    start?: Date | undefined;
    end?: Date | undefined;
    location?: LocationBuilder | undefined;
    files?: CreateFileSettings[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.parentId = _data["parentId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.start = _data["start"] ? new Date(_data["start"].toString()) : <any>undefined;
            this.end = _data["end"] ? new Date(_data["end"].toString()) : <any>undefined;
            this.location = _data["location"] ? LocationBuilder.fromJS(_data["location"]) : <any>undefined;
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(CreateFileSettings.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateMeetingSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMeetingSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["start"] = this.start ? this.start.toISOString() : <any>undefined;
        data["end"] = this.end ? this.end.toISOString() : <any>undefined;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data;
    }
}

export class LocationBuilder {
    address?: string | undefined;
    longitude?: number;
    latitude?: number;

    init(_data?: any) {
        if (_data) {
            this.address = _data["address"];
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
        }
    }

    static fromJS(data: any): LocationBuilder {
        data = typeof data === 'object' ? data : {};
        let result = new LocationBuilder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        return data;
    }
}

export class CreateFileSettings {
    name!: string;
    description?: string | undefined;
    dataUri!: string;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.dataUri = _data["dataUri"];
        }
    }

    static fromJS(data: any): CreateFileSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFileSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["dataUri"] = this.dataUri;
        return data;
    }
}

export class UpdateMeetingSettings {
    name!: string;
    description?: string | undefined;
    start?: Date | undefined;
    end?: Date | undefined;
    location?: LocationBuilder | undefined;
    version!: number;
    notify?: boolean;
    eventUri?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.start = _data["start"] ? new Date(_data["start"].toString()) : <any>undefined;
            this.end = _data["end"] ? new Date(_data["end"].toString()) : <any>undefined;
            this.location = _data["location"] ? LocationBuilder.fromJS(_data["location"]) : <any>undefined;
            this.version = _data["version"];
            this.notify = _data["notify"];
            this.eventUri = _data["eventUri"];
        }
    }

    static fromJS(data: any): UpdateMeetingSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMeetingSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["start"] = this.start ? this.start.toISOString() : <any>undefined;
        data["end"] = this.end ? this.end.toISOString() : <any>undefined;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["version"] = this.version;
        data["notify"] = this.notify;
        data["eventUri"] = this.eventUri;
        return data;
    }
}

export class ListOfFile {
    totalItemCount!: number;
    items!: File[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(File.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfFile {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class File {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    byteCount?: number;
    contentType?: string | undefined;
    extension?: string | undefined;
    creatorId?: string | undefined;
    creatorName?: string | undefined;
    created?: Date;
    modified?: Date;
    parentId?: string | undefined;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.byteCount = _data["byteCount"];
            this.contentType = _data["contentType"];
            this.extension = _data["extension"];
            this.creatorId = _data["creatorId"];
            this.creatorName = _data["creatorName"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
            this.parentId = _data["parentId"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): File {
        data = typeof data === 'object' ? data : {};
        let result = new File();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["byteCount"] = this.byteCount;
        data["contentType"] = this.contentType;
        data["extension"] = this.extension;
        data["creatorId"] = this.creatorId;
        data["creatorName"] = this.creatorName;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        data["parentId"] = this.parentId;
        data["version"] = this.version;
        return data;
    }
}

export class UpdateFileSettings {
    name!: string;
    description?: string | undefined;
    dataUri?: string | undefined;
    version!: number;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.dataUri = _data["dataUri"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateFileSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFileSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["dataUri"] = this.dataUri;
        data["version"] = this.version;
        return data;
    }
}

export class ListOfGroupAttendance {
    totalItemCount!: number;
    items!: GroupAttendance[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GroupAttendance.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfGroupAttendance {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfGroupAttendance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class GroupAttendance extends Attendance {
    groupName?: string | undefined;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.groupName = _data["groupName"];
        }
    }

    static fromJS(data: any): GroupAttendance {
        data = typeof data === 'object' ? data : {};
        let result = new GroupAttendance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupName"] = this.groupName;
        super.toJSON(data);
        return data;
    }
}

export class ListOfBackup {
    totalItemCount!: number;
    items!: Backup[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Backup.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfBackup {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfBackup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class Backup {
    id?: string | undefined;
    type?: BackupType;
    started?: Date;
    completed?: Date | undefined;
    status?: BackupStatus;
    message?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.started = _data["started"] ? new Date(_data["started"].toString()) : <any>undefined;
            this.completed = _data["completed"] ? new Date(_data["completed"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): Backup {
        data = typeof data === 'object' ? data : {};
        let result = new Backup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["started"] = this.started ? this.started.toISOString() : <any>undefined;
        data["completed"] = this.completed ? this.completed.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["message"] = this.message;
        return data;
    }
}

/** 0 = Unknown 1 = Scheduled 2 = Manual */
export enum BackupType {
    Unknown = 0,
    Scheduled = 1,
    Manual = 2,
}

/** 0 = Running 1 = Completed 2 = Error */
export enum BackupStatus {
    Running = 0,
    Completed = 1,
    Error = 2,
}

export class ListOfExternalApplication {
    totalItemCount!: number;
    items!: ExternalApplication[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ExternalApplication.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfExternalApplication {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfExternalApplication();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class ExternalApplication {
    id?: string | undefined;
    name?: string | undefined;
    imageUri?: string | undefined;
    endpoint?: string | undefined;
    isDefault?: boolean;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.imageUri = _data["imageUri"];
            this.endpoint = _data["endpoint"];
            this.isDefault = _data["isDefault"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): ExternalApplication {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalApplication();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["imageUri"] = this.imageUri;
        data["endpoint"] = this.endpoint;
        data["isDefault"] = this.isDefault;
        data["version"] = this.version;
        return data;
    }
}

export class CreateExternalApplicationSettings {
    name!: string;
    imageUri?: string | undefined;
    endpoint?: string | undefined;
    isDefault?: boolean;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.imageUri = _data["imageUri"];
            this.endpoint = _data["endpoint"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): CreateExternalApplicationSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateExternalApplicationSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["imageUri"] = this.imageUri;
        data["endpoint"] = this.endpoint;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export class UpdateExternalApplicationSettings {
    name!: string;
    imageUri?: string | undefined;
    endpoint?: string | undefined;
    isDefault?: boolean;
    version!: number;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.imageUri = _data["imageUri"];
            this.endpoint = _data["endpoint"];
            this.isDefault = _data["isDefault"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateExternalApplicationSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateExternalApplicationSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["imageUri"] = this.imageUri;
        data["endpoint"] = this.endpoint;
        data["isDefault"] = this.isDefault;
        data["version"] = this.version;
        return data;
    }
}

export class ResizedImage {
    uri?: string | undefined;
    width?: number;
    height?: number;

    init(_data?: any) {
        if (_data) {
            this.uri = _data["uri"];
            this.width = _data["width"];
            this.height = _data["height"];
        }
    }

    static fromJS(data: any): ResizedImage {
        data = typeof data === 'object' ? data : {};
        let result = new ResizedImage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uri"] = this.uri;
        data["width"] = this.width;
        data["height"] = this.height;
        return data;
    }
}

export class ListOfLog {
    totalItemCount!: number;
    items!: Log[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Log.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfLog {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class Log {
    id?: string | undefined;
    created?: Date;
    message?: string | undefined;
    level?: number;
    context?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.message = _data["message"];
            this.level = _data["level"];
            this.context = _data["context"];
        }
    }

    static fromJS(data: any): Log {
        data = typeof data === 'object' ? data : {};
        let result = new Log();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["message"] = this.message;
        data["level"] = this.level;
        data["context"] = this.context;
        return data;
    }
}

export class MarkdownPreviewSettings {
    text?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): MarkdownPreviewSettings {
        data = typeof data === 'object' ? data : {};
        let result = new MarkdownPreviewSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        return data;
    }
}

export class Platform {
    id?: string | undefined;
    name?: string | undefined;
    environment?: string | undefined;
    timeZoneId?: string | undefined;
    version?: ApplicationVersion;
    compileConfiguration?: string | undefined;
    compileDate?: Date | undefined;
    reCaptchaSiteKey?: string | undefined;
    supportEmailAddress?: string | undefined;
    systemEmailAddress?: string | undefined;
    cultures?: Culture[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.environment = _data["environment"];
            this.timeZoneId = _data["timeZoneId"];
            this.version = _data["version"] ? ApplicationVersion.fromJS(_data["version"]) : <any>undefined;
            this.compileConfiguration = _data["compileConfiguration"];
            this.compileDate = _data["compileDate"] ? new Date(_data["compileDate"].toString()) : <any>undefined;
            this.reCaptchaSiteKey = _data["reCaptchaSiteKey"];
            this.supportEmailAddress = _data["supportEmailAddress"];
            this.systemEmailAddress = _data["systemEmailAddress"];
            if (Array.isArray(_data["cultures"])) {
                this.cultures = [] as any;
                for (let item of _data["cultures"])
                    this.cultures!.push(Culture.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Platform {
        data = typeof data === 'object' ? data : {};
        let result = new Platform();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["environment"] = this.environment;
        data["timeZoneId"] = this.timeZoneId;
        data["version"] = this.version ? this.version.toJSON() : <any>undefined;
        data["compileConfiguration"] = this.compileConfiguration;
        data["compileDate"] = this.compileDate ? this.compileDate.toISOString() : <any>undefined;
        data["reCaptchaSiteKey"] = this.reCaptchaSiteKey;
        data["supportEmailAddress"] = this.supportEmailAddress;
        data["systemEmailAddress"] = this.systemEmailAddress;
        if (Array.isArray(this.cultures)) {
            data["cultures"] = [];
            for (let item of this.cultures)
                data["cultures"].push(item.toJSON());
        }
        return data;
    }
}

export class ApplicationVersion {
    major?: number;
    minor?: number;
    build?: number;

    init(_data?: any) {
        if (_data) {
            this.major = _data["major"];
            this.minor = _data["minor"];
            this.build = _data["build"];
        }
    }

    static fromJS(data: any): ApplicationVersion {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationVersion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["major"] = this.major;
        data["minor"] = this.minor;
        data["build"] = this.build;
        return data;
    }
}

export class Culture {
    id?: string | undefined;
    name?: string | undefined;
    datePattern?: string | undefined;
    shortDatePattern?: string | undefined;
    timePattern?: string | undefined;
    shortTimePattern?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.datePattern = _data["datePattern"];
            this.shortDatePattern = _data["shortDatePattern"];
            this.timePattern = _data["timePattern"];
            this.shortTimePattern = _data["shortTimePattern"];
        }
    }

    static fromJS(data: any): Culture {
        data = typeof data === 'object' ? data : {};
        let result = new Culture();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["datePattern"] = this.datePattern;
        data["shortDatePattern"] = this.shortDatePattern;
        data["timePattern"] = this.timePattern;
        data["shortTimePattern"] = this.shortTimePattern;
        return data;
    }
}

export class PlatformStatus {
    status?: SystemStatus;
    buildingProgress?: number;

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.buildingProgress = _data["buildingProgress"];
        }
    }

    static fromJS(data: any): PlatformStatus {
        data = typeof data === 'object' ? data : {};
        let result = new PlatformStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["buildingProgress"] = this.buildingProgress;
        return data;
    }
}

/** 0 = Built 1 = Building 2 = Maintenance -1 = Failed */
export enum SystemStatus {
    Built = 0,
    Building = 1,
    Maintenance = 2,
    Failed = -1,
}

export class ListOfProjectionBuild {
    totalItemCount!: number;
    items!: ProjectionBuild[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProjectionBuild.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfProjectionBuild {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfProjectionBuild();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class ProjectionBuild {
    eventsProcessed?: number;
    estimatedTotalEvents?: number;
    status?: ProjectionStatus;

    init(_data?: any) {
        if (_data) {
            this.eventsProcessed = _data["eventsProcessed"];
            this.estimatedTotalEvents = _data["estimatedTotalEvents"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): ProjectionBuild {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectionBuild();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eventsProcessed"] = this.eventsProcessed;
        data["estimatedTotalEvents"] = this.estimatedTotalEvents;
        data["status"] = this.status;
        return data;
    }
}

/** 0 = Unknown 1 = Pending 2 = Running 3 = Completed -1 = Failed */
export enum ProjectionStatus {
    Unknown = 0,
    Pending = 1,
    Running = 2,
    Completed = 3,
    Failed = -1,
}

export class ListOfNotification {
    totalItemCount!: number;
    items!: Notification[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Notification.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfNotification {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class Notification {
    id?: string | undefined;
    type?: string | undefined;
    recipientId?: string | undefined;
    parameters?: any | undefined;
    seen?: boolean;
    read?: boolean;
    creatorId?: string | undefined;
    creatorName?: string | undefined;
    created?: Date;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.recipientId = _data["recipientId"];
            this.parameters = _data["parameters"];
            this.seen = _data["seen"];
            this.read = _data["read"];
            this.creatorId = _data["creatorId"];
            this.creatorName = _data["creatorName"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): Notification {
        data = typeof data === 'object' ? data : {};
        let result = new Notification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["recipientId"] = this.recipientId;
        data["parameters"] = this.parameters;
        data["seen"] = this.seen;
        data["read"] = this.read;
        data["creatorId"] = this.creatorId;
        data["creatorName"] = this.creatorName;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["version"] = this.version;
        return data;
    }
}

export class UpdateNotificationSettings {
    seen?: boolean;
    read?: boolean;
    version!: number;

    init(_data?: any) {
        if (_data) {
            this.seen = _data["seen"];
            this.read = _data["read"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateNotificationSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNotificationSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["seen"] = this.seen;
        data["read"] = this.read;
        data["version"] = this.version;
        return data;
    }
}

export class ListOfScheduledEmail {
    totalItemCount!: number;
    items!: ScheduledEmail[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ScheduledEmail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfScheduledEmail {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfScheduledEmail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class ScheduledEmail {
    id?: string | undefined;
    type?: string | undefined;
    title?: string | undefined;
    note?: string | undefined;
    externalApplicationId?: string | undefined;
    groupId?: string | undefined;
    groupName?: string | undefined;
    organisationId?: string | undefined;
    timeZoneId?: string | undefined;
    creatorId?: string | undefined;
    created?: Date;
    recipientIds?: string[] | undefined;
    parameters?: any | undefined;
    schedule?: ScheduleOption | undefined;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.title = _data["title"];
            this.note = _data["note"];
            this.externalApplicationId = _data["externalApplicationId"];
            this.groupId = _data["groupId"];
            this.groupName = _data["groupName"];
            this.organisationId = _data["organisationId"];
            this.timeZoneId = _data["timeZoneId"];
            this.creatorId = _data["creatorId"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            if (Array.isArray(_data["recipientIds"])) {
                this.recipientIds = [] as any;
                for (let item of _data["recipientIds"])
                    this.recipientIds!.push(item);
            }
            this.parameters = _data["parameters"];
            this.schedule = _data["schedule"] ? ScheduleOption.fromJS(_data["schedule"]) : <any>undefined;
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): ScheduledEmail {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduledEmail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["title"] = this.title;
        data["note"] = this.note;
        data["externalApplicationId"] = this.externalApplicationId;
        data["groupId"] = this.groupId;
        data["groupName"] = this.groupName;
        data["organisationId"] = this.organisationId;
        data["timeZoneId"] = this.timeZoneId;
        data["creatorId"] = this.creatorId;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        if (Array.isArray(this.recipientIds)) {
            data["recipientIds"] = [];
            for (let item of this.recipientIds)
                data["recipientIds"].push(item);
        }
        data["parameters"] = this.parameters;
        data["schedule"] = this.schedule ? this.schedule.toJSON() : <any>undefined;
        data["version"] = this.version;
        return data;
    }
}

export class ScheduleOption {
    start?: Date;
    repeatType?: RepeatType;
    repeatInterval?: number;
    repeatOn?: number[] | undefined;
    end?: Date | undefined;

    init(_data?: any) {
        if (_data) {
            this.start = _data["start"] ? new Date(_data["start"].toString()) : <any>undefined;
            this.repeatType = _data["repeatType"];
            this.repeatInterval = _data["repeatInterval"];
            if (Array.isArray(_data["repeatOn"])) {
                this.repeatOn = [] as any;
                for (let item of _data["repeatOn"])
                    this.repeatOn!.push(item);
            }
            this.end = _data["end"] ? new Date(_data["end"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ScheduleOption {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleOption();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["start"] = this.start ? this.start.toISOString() : <any>undefined;
        data["repeatType"] = this.repeatType;
        data["repeatInterval"] = this.repeatInterval;
        if (Array.isArray(this.repeatOn)) {
            data["repeatOn"] = [];
            for (let item of this.repeatOn)
                data["repeatOn"].push(item);
        }
        data["end"] = this.end ? this.end.toISOString() : <any>undefined;
        return data;
    }
}

/** 0 = None 1 = Daily 2 = Weekly 3 = MonthlyByDay 4 = MonthlyByDayOfWeek 5 = Yearly */
export enum RepeatType {
    None = 0,
    Daily = 1,
    Weekly = 2,
    MonthlyByDay = 3,
    MonthlyByDayOfWeek = 4,
    Yearly = 5,
}

export class CreateScheduledEmailSettings {
    type!: string;
    title?: string | undefined;
    note?: string | undefined;
    groupId!: string;
    schedule!: ScheduleOption;
    recipientIds?: string[] | undefined;
    externalApplicationId?: string | undefined;
    parameters!: any;

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.note = _data["note"];
            this.groupId = _data["groupId"];
            this.schedule = _data["schedule"] ? ScheduleOption.fromJS(_data["schedule"]) : new ScheduleOption();
            if (Array.isArray(_data["recipientIds"])) {
                this.recipientIds = [] as any;
                for (let item of _data["recipientIds"])
                    this.recipientIds!.push(item);
            }
            this.externalApplicationId = _data["externalApplicationId"];
            this.parameters = _data["parameters"];
        }
    }

    static fromJS(data: any): CreateScheduledEmailSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateScheduledEmailSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["note"] = this.note;
        data["groupId"] = this.groupId;
        data["schedule"] = this.schedule ? this.schedule.toJSON() : <any>undefined;
        if (Array.isArray(this.recipientIds)) {
            data["recipientIds"] = [];
            for (let item of this.recipientIds)
                data["recipientIds"].push(item);
        }
        data["externalApplicationId"] = this.externalApplicationId;
        data["parameters"] = this.parameters;
        return data;
    }
}

export class UpdateScheduledEmailSettings {
    title?: string | undefined;
    note?: string | undefined;
    schedule?: ScheduleOption | undefined;
    recipientIds?: string[] | undefined;
    externalApplicationId?: string | undefined;
    parameters?: any | undefined;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.note = _data["note"];
            this.schedule = _data["schedule"] ? ScheduleOption.fromJS(_data["schedule"]) : <any>undefined;
            if (Array.isArray(_data["recipientIds"])) {
                this.recipientIds = [] as any;
                for (let item of _data["recipientIds"])
                    this.recipientIds!.push(item);
            }
            this.externalApplicationId = _data["externalApplicationId"];
            this.parameters = _data["parameters"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateScheduledEmailSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateScheduledEmailSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["note"] = this.note;
        data["schedule"] = this.schedule ? this.schedule.toJSON() : <any>undefined;
        if (Array.isArray(this.recipientIds)) {
            data["recipientIds"] = [];
            for (let item of this.recipientIds)
                data["recipientIds"].push(item);
        }
        data["externalApplicationId"] = this.externalApplicationId;
        data["parameters"] = this.parameters;
        data["version"] = this.version;
        return data;
    }
}

export class ListOfObservationContent {
    totalItemCount!: number;
    items!: ObservationContent[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ObservationContent.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfObservationContent {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfObservationContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class ObservationContent {
    id?: string | undefined;
    publisherId?: string | undefined;
    definitionId?: string | undefined;
    questions?: any[] | undefined;
    published?: boolean;
    created?: Date;
    modified?: Date;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.publisherId = _data["publisherId"];
            this.definitionId = _data["definitionId"];
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(item);
            }
            this.published = _data["published"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): ObservationContent {
        data = typeof data === 'object' ? data : {};
        let result = new ObservationContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["publisherId"] = this.publisherId;
        data["definitionId"] = this.definitionId;
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item);
        }
        data["published"] = this.published;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        data["version"] = this.version;
        return data;
    }
}

export class CreateObservationContentSettings {
    definitionId!: string;
    questions!: any[];
    published?: boolean;

    init(_data?: any) {
        if (_data) {
            this.definitionId = _data["definitionId"];
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(item);
            }
            this.published = _data["published"];
        }
    }

    static fromJS(data: any): CreateObservationContentSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateObservationContentSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["definitionId"] = this.definitionId;
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item);
        }
        data["published"] = this.published;
        return data;
    }
}

export class UpdateObservationContentSettings {
    questions!: any[];
    version?: number;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(item);
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateObservationContentSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateObservationContentSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item);
        }
        data["version"] = this.version;
        return data;
    }
}

export class ListOfLocatableObservation {
    totalItemCount!: number;
    items!: LocatableObservation[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LocatableObservation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfLocatableObservation {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfLocatableObservation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class Observation {
    id?: string | undefined;
    name?: string | undefined;
    performed?: Date;
    answers?: any[] | undefined;
    groupId?: string | undefined;
    groupName?: string | undefined;
    groupType?: string | undefined;
    organisationId?: string | undefined;
    observerId?: string | undefined;
    observerName?: string | undefined;
    definitionId?: string | undefined;
    publisherId?: string | undefined;
    contentId?: string | undefined;
    creatorId?: string | undefined;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.performed = _data["performed"] ? new Date(_data["performed"].toString()) : <any>undefined;
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(item);
            }
            this.groupId = _data["groupId"];
            this.groupName = _data["groupName"];
            this.groupType = _data["groupType"];
            this.organisationId = _data["organisationId"];
            this.observerId = _data["observerId"];
            this.observerName = _data["observerName"];
            this.definitionId = _data["definitionId"];
            this.publisherId = _data["publisherId"];
            this.contentId = _data["contentId"];
            this.creatorId = _data["creatorId"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): Observation {
        data = typeof data === 'object' ? data : {};
        let result = new Observation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["performed"] = this.performed ? this.performed.toISOString() : <any>undefined;
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item);
        }
        data["groupId"] = this.groupId;
        data["groupName"] = this.groupName;
        data["groupType"] = this.groupType;
        data["organisationId"] = this.organisationId;
        data["observerId"] = this.observerId;
        data["observerName"] = this.observerName;
        data["definitionId"] = this.definitionId;
        data["publisherId"] = this.publisherId;
        data["contentId"] = this.contentId;
        data["creatorId"] = this.creatorId;
        data["version"] = this.version;
        return data;
    }
}

export class LocatableObservation extends Observation {
    coordinates?: Coordinates | undefined;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.coordinates = _data["coordinates"] ? Coordinates.fromJS(_data["coordinates"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LocatableObservation {
        data = typeof data === 'object' ? data : {};
        let result = new LocatableObservation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["coordinates"] = this.coordinates ? this.coordinates.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export class PageOptions {
    skip?: number;
    /** The number (0 - 1000 inclusive) of items to get from the API. */
    take?: number;

    init(_data?: any) {
        if (_data) {
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): PageOptions {
        data = typeof data === 'object' ? data : {};
        let result = new PageOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export class ObservationAreaOptions extends PageOptions {
    southWest?: CoordinatesBuilder | undefined;
    northEast?: CoordinatesBuilder | undefined;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.southWest = _data["southWest"] ? CoordinatesBuilder.fromJS(_data["southWest"]) : <any>undefined;
            this.northEast = _data["northEast"] ? CoordinatesBuilder.fromJS(_data["northEast"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ObservationAreaOptions {
        data = typeof data === 'object' ? data : {};
        let result = new ObservationAreaOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["southWest"] = this.southWest ? this.southWest.toJSON() : <any>undefined;
        data["northEast"] = this.northEast ? this.northEast.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export class CoordinatesBuilder {
    longitude?: number;
    latitude?: number;

    init(_data?: any) {
        if (_data) {
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
        }
    }

    static fromJS(data: any): CoordinatesBuilder {
        data = typeof data === 'object' ? data : {};
        let result = new CoordinatesBuilder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        return data;
    }
}

export class ListOfObservation {
    totalItemCount!: number;
    items!: Observation[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Observation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfObservation {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfObservation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class CreateObservationSettings {
    contentId!: string;
    groupId!: string;
    observerId?: string | undefined;
    answers?: any[] | undefined;
    performed?: Date;

    init(_data?: any) {
        if (_data) {
            this.contentId = _data["contentId"];
            this.groupId = _data["groupId"];
            this.observerId = _data["observerId"];
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(item);
            }
            this.performed = _data["performed"] ? new Date(_data["performed"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateObservationSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateObservationSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        data["groupId"] = this.groupId;
        data["observerId"] = this.observerId;
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item);
        }
        data["performed"] = this.performed ? this.performed.toISOString() : <any>undefined;
        return data;
    }
}

export class UpdateObservationSettings {
    observerId?: string | undefined;
    answers?: any[] | undefined;
    performed?: Date;
    version!: number;

    init(_data?: any) {
        if (_data) {
            this.observerId = _data["observerId"];
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(item);
            }
            this.performed = _data["performed"] ? new Date(_data["performed"].toString()) : <any>undefined;
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateObservationSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateObservationSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["observerId"] = this.observerId;
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item);
        }
        data["performed"] = this.performed ? this.performed.toISOString() : <any>undefined;
        data["version"] = this.version;
        return data;
    }
}

export class PredictObservationSettings {
    dataUri!: string;

    init(_data?: any) {
        if (_data) {
            this.dataUri = _data["dataUri"];
        }
    }

    static fromJS(data: any): PredictObservationSettings {
        data = typeof data === 'object' ? data : {};
        let result = new PredictObservationSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataUri"] = this.dataUri;
        return data;
    }
}

export class ListOfObservationDefinition {
    totalItemCount!: number;
    items!: ObservationDefinition[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ObservationDefinition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfObservationDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfObservationDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class ObservationDefinition {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    publisherId?: string | undefined;
    publisherName?: string | undefined;
    published?: boolean;
    publishedContentId?: string | undefined;
    programs?: ProgramInObservationDefinition[] | undefined;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.publisherId = _data["publisherId"];
            this.publisherName = _data["publisherName"];
            this.published = _data["published"];
            this.publishedContentId = _data["publishedContentId"];
            if (Array.isArray(_data["programs"])) {
                this.programs = [] as any;
                for (let item of _data["programs"])
                    this.programs!.push(ProgramInObservationDefinition.fromJS(item));
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): ObservationDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new ObservationDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["publisherId"] = this.publisherId;
        data["publisherName"] = this.publisherName;
        data["published"] = this.published;
        data["publishedContentId"] = this.publishedContentId;
        if (Array.isArray(this.programs)) {
            data["programs"] = [];
            for (let item of this.programs)
                data["programs"].push(item.toJSON());
        }
        data["version"] = this.version;
        return data;
    }
}

export class ProgramInObservationDefinition {
    id?: string | undefined;
    name?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ProgramInObservationDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramInObservationDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export class CreateObservationDefinitionSettings {
    publisherId!: string;
    name!: string;
    description!: string;

    init(_data?: any) {
        if (_data) {
            this.publisherId = _data["publisherId"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateObservationDefinitionSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateObservationDefinitionSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["publisherId"] = this.publisherId;
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export class UpdateObservationDefinitionSettings {
    name!: string;
    description!: string;
    version!: number;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateObservationDefinitionSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateObservationDefinitionSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["version"] = this.version;
        return data;
    }
}

export class ListOfObservationForm {
    totalItemCount!: number;
    items!: ObservationForm[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ObservationForm.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfObservationForm {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfObservationForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class ObservationForm {
    id?: string | undefined;
    publisherId?: string | undefined;
    definitionId?: string | undefined;
    contentId?: string | undefined;
    fileQuestionIndex?: number | undefined;
    modelId?: string | undefined;
    modelVersion?: string | undefined;
    widthMillimetres?: number;
    heightMillimetres?: number;
    modified?: Date;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.publisherId = _data["publisherId"];
            this.definitionId = _data["definitionId"];
            this.contentId = _data["contentId"];
            this.fileQuestionIndex = _data["fileQuestionIndex"];
            this.modelId = _data["modelId"];
            this.modelVersion = _data["modelVersion"];
            this.widthMillimetres = _data["widthMillimetres"];
            this.heightMillimetres = _data["heightMillimetres"];
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): ObservationForm {
        data = typeof data === 'object' ? data : {};
        let result = new ObservationForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["publisherId"] = this.publisherId;
        data["definitionId"] = this.definitionId;
        data["contentId"] = this.contentId;
        data["fileQuestionIndex"] = this.fileQuestionIndex;
        data["modelId"] = this.modelId;
        data["modelVersion"] = this.modelVersion;
        data["widthMillimetres"] = this.widthMillimetres;
        data["heightMillimetres"] = this.heightMillimetres;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        data["version"] = this.version;
        return data;
    }
}

export class CreateObservationFormSettings {
    contentId!: string;
    /** The index of the file question in the target observation content
that will be used to store the OCR image. */
    fileQuestionIndex?: number | undefined;
    /** ID of the ML training model. */
    modelId!: string;
    /** Version of the ML training model. */
    modelVersion!: string;
    widthMillimetres?: number;
    heightMillimetres?: number;

    init(_data?: any) {
        if (_data) {
            this.contentId = _data["contentId"];
            this.fileQuestionIndex = _data["fileQuestionIndex"];
            this.modelId = _data["modelId"];
            this.modelVersion = _data["modelVersion"];
            this.widthMillimetres = _data["widthMillimetres"];
            this.heightMillimetres = _data["heightMillimetres"];
        }
    }

    static fromJS(data: any): CreateObservationFormSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateObservationFormSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        data["fileQuestionIndex"] = this.fileQuestionIndex;
        data["modelId"] = this.modelId;
        data["modelVersion"] = this.modelVersion;
        data["widthMillimetres"] = this.widthMillimetres;
        data["heightMillimetres"] = this.heightMillimetres;
        return data;
    }
}

export class UpdateObservationFormSettings {
    fileQuestionIndex?: number | undefined;
    modelId!: string;
    modelVersion!: string;
    widthMillimetres?: number;
    heightMillimetres?: number;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.fileQuestionIndex = _data["fileQuestionIndex"];
            this.modelId = _data["modelId"];
            this.modelVersion = _data["modelVersion"];
            this.widthMillimetres = _data["widthMillimetres"];
            this.heightMillimetres = _data["heightMillimetres"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateObservationFormSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateObservationFormSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileQuestionIndex"] = this.fileQuestionIndex;
        data["modelId"] = this.modelId;
        data["modelVersion"] = this.modelVersion;
        data["widthMillimetres"] = this.widthMillimetres;
        data["heightMillimetres"] = this.heightMillimetres;
        data["version"] = this.version;
        return data;
    }
}

export class MigrateObservationDefinitionSettings {
    publisherId!: string;
    version!: number;

    init(_data?: any) {
        if (_data) {
            this.publisherId = _data["publisherId"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): MigrateObservationDefinitionSettings {
        data = typeof data === 'object' ? data : {};
        let result = new MigrateObservationDefinitionSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["publisherId"] = this.publisherId;
        data["version"] = this.version;
        return data;
    }
}

export class DuplicateObservationDefinitionSettings {
    name!: string;
    description!: string;
    /** List of consumers to be migrated with the new observation definition. */
    consumerIds!: string[];
    dryRun?: boolean;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["consumerIds"])) {
                this.consumerIds = [] as any;
                for (let item of _data["consumerIds"])
                    this.consumerIds!.push(item);
            }
            this.dryRun = _data["dryRun"];
        }
    }

    static fromJS(data: any): DuplicateObservationDefinitionSettings {
        data = typeof data === 'object' ? data : {};
        let result = new DuplicateObservationDefinitionSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.consumerIds)) {
            data["consumerIds"] = [];
            for (let item of this.consumerIds)
                data["consumerIds"].push(item);
        }
        data["dryRun"] = this.dryRun;
        return data;
    }
}

export class BatchMergeObservationAnonymousUsersSettings {
    definitionId!: string;
    groupId!: string;
    anonymousUsers!: string[];
    userId!: string;

    init(_data?: any) {
        if (_data) {
            this.definitionId = _data["definitionId"];
            this.groupId = _data["groupId"];
            if (Array.isArray(_data["anonymousUsers"])) {
                this.anonymousUsers = [] as any;
                for (let item of _data["anonymousUsers"])
                    this.anonymousUsers!.push(item);
            }
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): BatchMergeObservationAnonymousUsersSettings {
        data = typeof data === 'object' ? data : {};
        let result = new BatchMergeObservationAnonymousUsersSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["definitionId"] = this.definitionId;
        data["groupId"] = this.groupId;
        if (Array.isArray(this.anonymousUsers)) {
            data["anonymousUsers"] = [];
            for (let item of this.anonymousUsers)
                data["anonymousUsers"].push(item);
        }
        data["userId"] = this.userId;
        return data;
    }
}

export class ListOfObservationSettings {
    totalItemCount!: number;
    items!: ObservationSettings[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ObservationSettings.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfObservationSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfObservationSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class ObservationSettings {
    id?: string | undefined;
    organisationId?: string | undefined;
    definitionId?: string | undefined;
    publisherId?: string | undefined;
    privacy?: PrivacyLevel;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.organisationId = _data["organisationId"];
            this.definitionId = _data["definitionId"];
            this.publisherId = _data["publisherId"];
            this.privacy = _data["privacy"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): ObservationSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ObservationSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["organisationId"] = this.organisationId;
        data["definitionId"] = this.definitionId;
        data["publisherId"] = this.publisherId;
        data["privacy"] = this.privacy;
        data["version"] = this.version;
        return data;
    }
}

/** 0 = Public 1 = Closed 2 = Secret */
export enum PrivacyLevel {
    Public = 0,
    Closed = 1,
    Secret = 2,
}

export class CreateObservationSettingsSettings {
    organisationId!: string;
    definitionId!: string;
    privacy?: PrivacyLevel;

    init(_data?: any) {
        if (_data) {
            this.organisationId = _data["organisationId"];
            this.definitionId = _data["definitionId"];
            this.privacy = _data["privacy"];
        }
    }

    static fromJS(data: any): CreateObservationSettingsSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateObservationSettingsSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organisationId"] = this.organisationId;
        data["definitionId"] = this.definitionId;
        data["privacy"] = this.privacy;
        return data;
    }
}

export class UpdateObservationSettingsSettings {
    privacy?: PrivacyLevel;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.privacy = _data["privacy"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateObservationSettingsSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateObservationSettingsSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["privacy"] = this.privacy;
        data["version"] = this.version;
        return data;
    }
}

export class Customer {
    id?: string | undefined;
    userId?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): Customer {
        data = typeof data === 'object' ? data : {};
        let result = new Customer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        return data;
    }
}

export class Merchant {
    id?: string | undefined;
    publisherId?: string | undefined;
    verified?: boolean;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.publisherId = _data["publisherId"];
            this.verified = _data["verified"];
        }
    }

    static fromJS(data: any): Merchant {
        data = typeof data === 'object' ? data : {};
        let result = new Merchant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["publisherId"] = this.publisherId;
        data["verified"] = this.verified;
        return data;
    }
}

export class Payment {
    id?: string | undefined;
    created?: Date;
    userId?: string | undefined;
    customerId?: string | undefined;
    publisherId?: string | undefined;
    merchantId?: string | undefined;
    productId?: string | undefined;
    itemId?: string | undefined;
    currencyCode?: string | undefined;
    amount?: number;
    merchantAmount?: number;
    status?: PaymentStatus;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.customerId = _data["customerId"];
            this.publisherId = _data["publisherId"];
            this.merchantId = _data["merchantId"];
            this.productId = _data["productId"];
            this.itemId = _data["itemId"];
            this.currencyCode = _data["currencyCode"];
            this.amount = _data["amount"];
            this.merchantAmount = _data["merchantAmount"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): Payment {
        data = typeof data === 'object' ? data : {};
        let result = new Payment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["customerId"] = this.customerId;
        data["publisherId"] = this.publisherId;
        data["merchantId"] = this.merchantId;
        data["productId"] = this.productId;
        data["itemId"] = this.itemId;
        data["currencyCode"] = this.currencyCode;
        data["amount"] = this.amount;
        data["merchantAmount"] = this.merchantAmount;
        data["status"] = this.status;
        return data;
    }
}

/** 0 = None 1 = Pending 2 = Succeeded 3 = Failed 4 = Refunded */
export enum PaymentStatus {
    None = 0,
    Pending = 1,
    Succeeded = 2,
    Failed = 3,
    Refunded = 4,
}

export class CreatePaymentSettings {
    productId!: string;
    token!: string;

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): CreatePaymentSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePaymentSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["token"] = this.token;
        return data;
    }
}

export class Region {
    name?: string | undefined;
    countries?: Country[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["countries"])) {
                this.countries = [] as any;
                for (let item of _data["countries"])
                    this.countries!.push(Country.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Region {
        data = typeof data === 'object' ? data : {};
        let result = new Region();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.countries)) {
            data["countries"] = [];
            for (let item of this.countries)
                data["countries"].push(item.toJSON());
        }
        return data;
    }
}

export class Country {
    name?: string | undefined;
    code?: string | undefined;
    currencies?: Currency[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            if (Array.isArray(_data["currencies"])) {
                this.currencies = [] as any;
                for (let item of _data["currencies"])
                    this.currencies!.push(Currency.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Country {
        data = typeof data === 'object' ? data : {};
        let result = new Country();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        if (Array.isArray(this.currencies)) {
            data["currencies"] = [];
            for (let item of this.currencies)
                data["currencies"].push(item.toJSON());
        }
        return data;
    }
}

export class Currency {
    name?: string | undefined;
    code?: string | undefined;
    symbol?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.symbol = _data["symbol"];
        }
    }

    static fromJS(data: any): Currency {
        data = typeof data === 'object' ? data : {};
        let result = new Currency();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["symbol"] = this.symbol;
        return data;
    }
}

export class Product {
    id?: string | undefined;
    itemName?: string | undefined;
    itemType?: string | undefined;
    itemDescription?: string | undefined;
    publisherId?: string | undefined;
    publisherName?: string | undefined;
    publisherApproved?: boolean;
    programId?: string | undefined;
    programName?: string | undefined;
    merchantId?: string | undefined;
    itemId?: string | undefined;
    prices?: Price[] | undefined;
    published?: boolean;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.itemName = _data["itemName"];
            this.itemType = _data["itemType"];
            this.itemDescription = _data["itemDescription"];
            this.publisherId = _data["publisherId"];
            this.publisherName = _data["publisherName"];
            this.publisherApproved = _data["publisherApproved"];
            this.programId = _data["programId"];
            this.programName = _data["programName"];
            this.merchantId = _data["merchantId"];
            this.itemId = _data["itemId"];
            if (Array.isArray(_data["prices"])) {
                this.prices = [] as any;
                for (let item of _data["prices"])
                    this.prices!.push(Price.fromJS(item));
            }
            this.published = _data["published"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): Product {
        data = typeof data === 'object' ? data : {};
        let result = new Product();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["itemName"] = this.itemName;
        data["itemType"] = this.itemType;
        data["itemDescription"] = this.itemDescription;
        data["publisherId"] = this.publisherId;
        data["publisherName"] = this.publisherName;
        data["publisherApproved"] = this.publisherApproved;
        data["programId"] = this.programId;
        data["programName"] = this.programName;
        data["merchantId"] = this.merchantId;
        data["itemId"] = this.itemId;
        if (Array.isArray(this.prices)) {
            data["prices"] = [];
            for (let item of this.prices)
                data["prices"].push(item.toJSON());
        }
        data["published"] = this.published;
        data["version"] = this.version;
        return data;
    }
}

export class Price {
    countryCode?: string | undefined;
    currencyCode?: string | undefined;
    amount?: number;

    init(_data?: any) {
        if (_data) {
            this.countryCode = _data["countryCode"];
            this.currencyCode = _data["currencyCode"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): Price {
        data = typeof data === 'object' ? data : {};
        let result = new Price();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryCode"] = this.countryCode;
        data["currencyCode"] = this.currencyCode;
        data["amount"] = this.amount;
        return data;
    }
}

export class CreateProductSettings {
    publisherId!: string;
    itemId!: string;
    published?: boolean;
    prices?: Price[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.publisherId = _data["publisherId"];
            this.itemId = _data["itemId"];
            this.published = _data["published"];
            if (Array.isArray(_data["prices"])) {
                this.prices = [] as any;
                for (let item of _data["prices"])
                    this.prices!.push(Price.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateProductSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["publisherId"] = this.publisherId;
        data["itemId"] = this.itemId;
        data["published"] = this.published;
        if (Array.isArray(this.prices)) {
            data["prices"] = [];
            for (let item of this.prices)
                data["prices"].push(item.toJSON());
        }
        return data;
    }
}

export class UpdateProductSettings {
    prices?: Price[] | undefined;
    published?: boolean;
    version!: number;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["prices"])) {
                this.prices = [] as any;
                for (let item of _data["prices"])
                    this.prices!.push(Price.fromJS(item));
            }
            this.published = _data["published"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateProductSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.prices)) {
            data["prices"] = [];
            for (let item of this.prices)
                data["prices"].push(item.toJSON());
        }
        data["published"] = this.published;
        data["version"] = this.version;
        return data;
    }
}

export class ListOfPublisher {
    totalItemCount!: number;
    items!: Publisher[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Publisher.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfPublisher {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfPublisher();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class Publisher {
    id?: string | undefined;
    requested?: boolean;
    request?: PublishingOptions | undefined;
    approved?: boolean;
    publishing?: PublishingOptions | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.requested = _data["requested"];
            this.request = _data["request"] ? PublishingOptions.fromJS(_data["request"]) : <any>undefined;
            this.approved = _data["approved"];
            this.publishing = _data["publishing"] ? PublishingOptions.fromJS(_data["publishing"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Publisher {
        data = typeof data === 'object' ? data : {};
        let result = new Publisher();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["requested"] = this.requested;
        data["request"] = this.request ? this.request.toJSON() : <any>undefined;
        data["approved"] = this.approved;
        data["publishing"] = this.publishing ? this.publishing.toJSON() : <any>undefined;
        return data;
    }
}

export class PublishingOptions {
    freeBusinessToConsumer?: boolean;
    paidBusinessToConsumer?: boolean;
    businessToBusiness?: boolean;

    init(_data?: any) {
        if (_data) {
            this.freeBusinessToConsumer = _data["freeBusinessToConsumer"];
            this.paidBusinessToConsumer = _data["paidBusinessToConsumer"];
            this.businessToBusiness = _data["businessToBusiness"];
        }
    }

    static fromJS(data: any): PublishingOptions {
        data = typeof data === 'object' ? data : {};
        let result = new PublishingOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["freeBusinessToConsumer"] = this.freeBusinessToConsumer;
        data["paidBusinessToConsumer"] = this.paidBusinessToConsumer;
        data["businessToBusiness"] = this.businessToBusiness;
        return data;
    }
}

export class RequestPublisherSettings {
    options!: PublishingOptions;
    notes?: string | undefined;
    approvalUri?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.options = _data["options"] ? PublishingOptions.fromJS(_data["options"]) : new PublishingOptions();
            this.notes = _data["notes"];
            this.approvalUri = _data["approvalUri"];
        }
    }

    static fromJS(data: any): RequestPublisherSettings {
        data = typeof data === 'object' ? data : {};
        let result = new RequestPublisherSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["options"] = this.options ? this.options.toJSON() : <any>undefined;
        data["notes"] = this.notes;
        data["approvalUri"] = this.approvalUri;
        return data;
    }
}

export class ApprovePublisherSettings {
    options!: PublishingOptions;
    notes?: string | undefined;
    publishingUri?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.options = _data["options"] ? PublishingOptions.fromJS(_data["options"]) : new PublishingOptions();
            this.notes = _data["notes"];
            this.publishingUri = _data["publishingUri"];
        }
    }

    static fromJS(data: any): ApprovePublisherSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovePublisherSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["options"] = this.options ? this.options.toJSON() : <any>undefined;
        data["notes"] = this.notes;
        data["publishingUri"] = this.publishingUri;
        return data;
    }
}

export class ListOfImplementation {
    totalItemCount!: number;
    items!: Implementation[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Implementation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfImplementation {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfImplementation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class Implementation {
    id?: string | undefined;
    templateId?: string | undefined;
    creatorId?: string | undefined;
    publisherId?: string | undefined;
    publisherName?: string | undefined;
    publisherLogoUri?: string | undefined;
    consumerId?: string | undefined;
    consumerName?: string | undefined;
    consumerLogoUri?: string | undefined;
    teamId?: string | undefined;
    teamName?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    startDate?: Date | undefined;
    archived?: boolean;
    phases?: PhaseInImplementation[] | undefined;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.templateId = _data["templateId"];
            this.creatorId = _data["creatorId"];
            this.publisherId = _data["publisherId"];
            this.publisherName = _data["publisherName"];
            this.publisherLogoUri = _data["publisherLogoUri"];
            this.consumerId = _data["consumerId"];
            this.consumerName = _data["consumerName"];
            this.consumerLogoUri = _data["consumerLogoUri"];
            this.teamId = _data["teamId"];
            this.teamName = _data["teamName"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.archived = _data["archived"];
            if (Array.isArray(_data["phases"])) {
                this.phases = [] as any;
                for (let item of _data["phases"])
                    this.phases!.push(PhaseInImplementation.fromJS(item));
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): Implementation {
        data = typeof data === 'object' ? data : {};
        let result = new Implementation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["templateId"] = this.templateId;
        data["creatorId"] = this.creatorId;
        data["publisherId"] = this.publisherId;
        data["publisherName"] = this.publisherName;
        data["publisherLogoUri"] = this.publisherLogoUri;
        data["consumerId"] = this.consumerId;
        data["consumerName"] = this.consumerName;
        data["consumerLogoUri"] = this.consumerLogoUri;
        data["teamId"] = this.teamId;
        data["teamName"] = this.teamName;
        data["name"] = this.name;
        data["description"] = this.description;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["archived"] = this.archived;
        if (Array.isArray(this.phases)) {
            data["phases"] = [];
            for (let item of this.phases)
                data["phases"].push(item.toJSON());
        }
        data["version"] = this.version;
        return data;
    }
}

export class PhaseInImplementation {
    name?: string | undefined;
    order?: number;
    tasks?: TaskInImplementation[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.order = _data["order"];
            if (Array.isArray(_data["tasks"])) {
                this.tasks = [] as any;
                for (let item of _data["tasks"])
                    this.tasks!.push(TaskInImplementation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PhaseInImplementation {
        data = typeof data === 'object' ? data : {};
        let result = new PhaseInImplementation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["order"] = this.order;
        if (Array.isArray(this.tasks)) {
            data["tasks"] = [];
            for (let item of this.tasks)
                data["tasks"].push(item.toJSON());
        }
        return data;
    }
}

export class TaskInImplementation {
    id?: string | undefined;
    name?: string | undefined;
    order?: number;
    status?: TaskStatus;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.order = _data["order"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): TaskInImplementation {
        data = typeof data === 'object' ? data : {};
        let result = new TaskInImplementation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["order"] = this.order;
        data["status"] = this.status;
        return data;
    }
}

/** 0 = None 1 = NotStarted 2 = Started 3 = Complete 4 = Rejected */
export enum TaskStatus {
    None = 0,
    NotStarted = 1,
    Started = 2,
    Complete = 3,
    Rejected = 4,
}

export class ListOfTask {
    totalItemCount!: number;
    items!: Task[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Task.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfTask {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class Task {
    id?: string | undefined;
    groupId?: string | undefined;
    creatorId?: string | undefined;
    creatorName?: string | undefined;
    creatorImageUri?: string | undefined;
    templateId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    estimatedDuration?: string;
    status?: TaskStatus;
    due?: Date | undefined;
    subtasks?: SubtaskInTask[] | undefined;
    assignees?: AssigneeInTask[] | undefined;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.groupId = _data["groupId"];
            this.creatorId = _data["creatorId"];
            this.creatorName = _data["creatorName"];
            this.creatorImageUri = _data["creatorImageUri"];
            this.templateId = _data["templateId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.estimatedDuration = _data["estimatedDuration"];
            this.status = _data["status"];
            this.due = _data["due"] ? new Date(_data["due"].toString()) : <any>undefined;
            if (Array.isArray(_data["subtasks"])) {
                this.subtasks = [] as any;
                for (let item of _data["subtasks"])
                    this.subtasks!.push(SubtaskInTask.fromJS(item));
            }
            if (Array.isArray(_data["assignees"])) {
                this.assignees = [] as any;
                for (let item of _data["assignees"])
                    this.assignees!.push(AssigneeInTask.fromJS(item));
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): Task {
        data = typeof data === 'object' ? data : {};
        let result = new Task();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["groupId"] = this.groupId;
        data["creatorId"] = this.creatorId;
        data["creatorName"] = this.creatorName;
        data["creatorImageUri"] = this.creatorImageUri;
        data["templateId"] = this.templateId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["estimatedDuration"] = this.estimatedDuration;
        data["status"] = this.status;
        data["due"] = this.due ? this.due.toISOString() : <any>undefined;
        if (Array.isArray(this.subtasks)) {
            data["subtasks"] = [];
            for (let item of this.subtasks)
                data["subtasks"].push(item.toJSON());
        }
        if (Array.isArray(this.assignees)) {
            data["assignees"] = [];
            for (let item of this.assignees)
                data["assignees"].push(item.toJSON());
        }
        data["version"] = this.version;
        return data;
    }
}

export class SubtaskInTask {
    id?: string | undefined;
    name?: string | undefined;
    order?: number;
    estimatedDuration?: string;
    status?: TaskStatus;
    due?: Date | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.order = _data["order"];
            this.estimatedDuration = _data["estimatedDuration"];
            this.status = _data["status"];
            this.due = _data["due"] ? new Date(_data["due"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SubtaskInTask {
        data = typeof data === 'object' ? data : {};
        let result = new SubtaskInTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["order"] = this.order;
        data["estimatedDuration"] = this.estimatedDuration;
        data["status"] = this.status;
        data["due"] = this.due ? this.due.toISOString() : <any>undefined;
        return data;
    }
}

export class AssigneeInTask {
    id?: string | undefined;
    name?: string | undefined;
    imageUri?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.imageUri = _data["imageUri"];
        }
    }

    static fromJS(data: any): AssigneeInTask {
        data = typeof data === 'object' ? data : {};
        let result = new AssigneeInTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["imageUri"] = this.imageUri;
        return data;
    }
}

export class CreateImplementationSettings {
    publisherId!: string;
    templateId?: string | undefined;
    consumerId?: string | undefined;
    teamId?: string | undefined;
    name!: string;
    description?: string | undefined;
    startDate?: Date | undefined;
    phases?: ImplementationPhase[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.publisherId = _data["publisherId"];
            this.templateId = _data["templateId"];
            this.consumerId = _data["consumerId"];
            this.teamId = _data["teamId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["phases"])) {
                this.phases = [] as any;
                for (let item of _data["phases"])
                    this.phases!.push(ImplementationPhase.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateImplementationSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateImplementationSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["publisherId"] = this.publisherId;
        data["templateId"] = this.templateId;
        data["consumerId"] = this.consumerId;
        data["teamId"] = this.teamId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        if (Array.isArray(this.phases)) {
            data["phases"] = [];
            for (let item of this.phases)
                data["phases"].push(item.toJSON());
        }
        return data;
    }
}

export class ImplementationPhase {
    name?: string | undefined;
    order?: number;
    tasks?: PhaseTask[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.order = _data["order"];
            if (Array.isArray(_data["tasks"])) {
                this.tasks = [] as any;
                for (let item of _data["tasks"])
                    this.tasks!.push(PhaseTask.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ImplementationPhase {
        data = typeof data === 'object' ? data : {};
        let result = new ImplementationPhase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["order"] = this.order;
        if (Array.isArray(this.tasks)) {
            data["tasks"] = [];
            for (let item of this.tasks)
                data["tasks"].push(item.toJSON());
        }
        return data;
    }
}

export class PhaseTask {
    id?: string | undefined;
    order?: number;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): PhaseTask {
        data = typeof data === 'object' ? data : {};
        let result = new PhaseTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["order"] = this.order;
        return data;
    }
}

export class UpdateImplementationSettings {
    name!: string;
    description?: string | undefined;
    phases?: ImplementationPhase[] | undefined;
    startDate?: Date | undefined;
    archived?: boolean;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["phases"])) {
                this.phases = [] as any;
                for (let item of _data["phases"])
                    this.phases!.push(ImplementationPhase.fromJS(item));
            }
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.archived = _data["archived"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateImplementationSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateImplementationSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.phases)) {
            data["phases"] = [];
            for (let item of this.phases)
                data["phases"].push(item.toJSON());
        }
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["archived"] = this.archived;
        data["version"] = this.version;
        return data;
    }
}

export class ListOfItemActivation {
    totalItemCount!: number;
    items!: ItemActivation[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ItemActivation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfItemActivation {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfItemActivation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class ItemActivation {
    id?: string | undefined;
    itemId?: string | undefined;
    itemType?: string | undefined;
    itemName?: string | undefined;
    programs?: ProgramInItemActivation[] | undefined;
    publisherId?: string | undefined;
    publisherName?: string | undefined;
    consumerOrganisationId?: string | undefined;
    consumerType?: string | undefined;
    consumerId?: string | undefined;
    consumerName?: string | undefined;
    activated?: boolean;
    version?: number;
    created?: Date;
    modified?: Date;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.itemId = _data["itemId"];
            this.itemType = _data["itemType"];
            this.itemName = _data["itemName"];
            if (Array.isArray(_data["programs"])) {
                this.programs = [] as any;
                for (let item of _data["programs"])
                    this.programs!.push(ProgramInItemActivation.fromJS(item));
            }
            this.publisherId = _data["publisherId"];
            this.publisherName = _data["publisherName"];
            this.consumerOrganisationId = _data["consumerOrganisationId"];
            this.consumerType = _data["consumerType"];
            this.consumerId = _data["consumerId"];
            this.consumerName = _data["consumerName"];
            this.activated = _data["activated"];
            this.version = _data["version"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ItemActivation {
        data = typeof data === 'object' ? data : {};
        let result = new ItemActivation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["itemId"] = this.itemId;
        data["itemType"] = this.itemType;
        data["itemName"] = this.itemName;
        if (Array.isArray(this.programs)) {
            data["programs"] = [];
            for (let item of this.programs)
                data["programs"].push(item.toJSON());
        }
        data["publisherId"] = this.publisherId;
        data["publisherName"] = this.publisherName;
        data["consumerOrganisationId"] = this.consumerOrganisationId;
        data["consumerType"] = this.consumerType;
        data["consumerId"] = this.consumerId;
        data["consumerName"] = this.consumerName;
        data["activated"] = this.activated;
        data["version"] = this.version;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        return data;
    }
}

export class ProgramInItemActivation {
    id?: string | undefined;
    name?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ProgramInItemActivation {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramInItemActivation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export class ListOfProgramActivation {
    totalItemCount!: number;
    items!: ProgramActivation[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProgramActivation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfProgramActivation {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfProgramActivation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class ProgramActivation {
    id?: string | undefined;
    programId?: string | undefined;
    consumerType?: string | undefined;
    consumerId?: string | undefined;
    consumerName?: string | undefined;
    launchedAt?: Date;
    sponsor?: string | undefined;
    currentPhaseId?: string | undefined;
    phaseActivations?: PhaseActivationInProgramActivation[] | undefined;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.programId = _data["programId"];
            this.consumerType = _data["consumerType"];
            this.consumerId = _data["consumerId"];
            this.consumerName = _data["consumerName"];
            this.launchedAt = _data["launchedAt"] ? new Date(_data["launchedAt"].toString()) : <any>undefined;
            this.sponsor = _data["sponsor"];
            this.currentPhaseId = _data["currentPhaseId"];
            if (Array.isArray(_data["phaseActivations"])) {
                this.phaseActivations = [] as any;
                for (let item of _data["phaseActivations"])
                    this.phaseActivations!.push(PhaseActivationInProgramActivation.fromJS(item));
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): ProgramActivation {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramActivation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["programId"] = this.programId;
        data["consumerType"] = this.consumerType;
        data["consumerId"] = this.consumerId;
        data["consumerName"] = this.consumerName;
        data["launchedAt"] = this.launchedAt ? this.launchedAt.toISOString() : <any>undefined;
        data["sponsor"] = this.sponsor;
        data["currentPhaseId"] = this.currentPhaseId;
        if (Array.isArray(this.phaseActivations)) {
            data["phaseActivations"] = [];
            for (let item of this.phaseActivations)
                data["phaseActivations"].push(item.toJSON());
        }
        data["version"] = this.version;
        return data;
    }
}

export class PhaseActivationInProgramActivation {
    id?: string | undefined;
    status?: ProgramPhaseActivationStatus;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): PhaseActivationInProgramActivation {
        data = typeof data === 'object' ? data : {};
        let result = new PhaseActivationInProgramActivation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        return data;
    }
}

/** 0 = NotActivated 1 = Requested 2 = Activated 3 = Deactivated */
export enum ProgramPhaseActivationStatus {
    NotActivated = 0,
    Requested = 1,
    Activated = 2,
    Deactivated = 3,
}

export class ActivateProgramPhaseSettings {
    consumerId!: string;
    programPhaseId!: string;
    sponsor?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.consumerId = _data["consumerId"];
            this.programPhaseId = _data["programPhaseId"];
            this.sponsor = _data["sponsor"];
        }
    }

    static fromJS(data: any): ActivateProgramPhaseSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateProgramPhaseSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consumerId"] = this.consumerId;
        data["programPhaseId"] = this.programPhaseId;
        data["sponsor"] = this.sponsor;
        return data;
    }
}

export class ListOfProgram {
    totalItemCount!: number;
    items!: Program[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Program.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfProgram {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfProgram();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class Program {
    id?: string | undefined;
    name?: string | undefined;
    logoUri?: string | undefined;
    bannerUri?: string | undefined;
    publisherId?: string | undefined;
    publisherName?: string | undefined;
    publisherLogoUri?: string | undefined;
    resources?: ProgramResource[] | undefined;
    phases?: ProgramPhaseInProgram[] | undefined;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.logoUri = _data["logoUri"];
            this.bannerUri = _data["bannerUri"];
            this.publisherId = _data["publisherId"];
            this.publisherName = _data["publisherName"];
            this.publisherLogoUri = _data["publisherLogoUri"];
            if (Array.isArray(_data["resources"])) {
                this.resources = [] as any;
                for (let item of _data["resources"])
                    this.resources!.push(ProgramResource.fromJS(item));
            }
            if (Array.isArray(_data["phases"])) {
                this.phases = [] as any;
                for (let item of _data["phases"])
                    this.phases!.push(ProgramPhaseInProgram.fromJS(item));
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): Program {
        data = typeof data === 'object' ? data : {};
        let result = new Program();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["logoUri"] = this.logoUri;
        data["bannerUri"] = this.bannerUri;
        data["publisherId"] = this.publisherId;
        data["publisherName"] = this.publisherName;
        data["publisherLogoUri"] = this.publisherLogoUri;
        if (Array.isArray(this.resources)) {
            data["resources"] = [];
            for (let item of this.resources)
                data["resources"].push(item.toJSON());
        }
        if (Array.isArray(this.phases)) {
            data["phases"] = [];
            for (let item of this.phases)
                data["phases"].push(item.toJSON());
        }
        data["version"] = this.version;
        return data;
    }
}

export class ProgramResource {
    id?: string | undefined;
    type?: ProgramResourceType;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ProgramResource {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        return data;
    }
}

/** 0 = Course 1 = ObservationDefinition 2 = Survey 3 = Implementation */
export enum ProgramResourceType {
    Course = 0,
    ObservationDefinition = 1,
    Survey = 2,
    Implementation = 3,
}

export class ProgramPhaseInProgram {
    id?: string | undefined;
    resources?: ProgramResource[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["resources"])) {
                this.resources = [] as any;
                for (let item of _data["resources"])
                    this.resources!.push(ProgramResource.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProgramPhaseInProgram {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramPhaseInProgram();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.resources)) {
            data["resources"] = [];
            for (let item of this.resources)
                data["resources"].push(item.toJSON());
        }
        return data;
    }
}

export class CreateProgramSettings {
    publisherId!: string;
    name!: string;
    bannerUri?: string | undefined;
    logoUri?: string | undefined;
    resources?: ProgramResource[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.publisherId = _data["publisherId"];
            this.name = _data["name"];
            this.bannerUri = _data["bannerUri"];
            this.logoUri = _data["logoUri"];
            if (Array.isArray(_data["resources"])) {
                this.resources = [] as any;
                for (let item of _data["resources"])
                    this.resources!.push(ProgramResource.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateProgramSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProgramSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["publisherId"] = this.publisherId;
        data["name"] = this.name;
        data["bannerUri"] = this.bannerUri;
        data["logoUri"] = this.logoUri;
        if (Array.isArray(this.resources)) {
            data["resources"] = [];
            for (let item of this.resources)
                data["resources"].push(item.toJSON());
        }
        return data;
    }
}

export class UpdateProgramSettings {
    name!: string;
    bannerUri?: string | undefined;
    logoUri?: string | undefined;
    resources?: ProgramResource[] | undefined;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.bannerUri = _data["bannerUri"];
            this.logoUri = _data["logoUri"];
            if (Array.isArray(_data["resources"])) {
                this.resources = [] as any;
                for (let item of _data["resources"])
                    this.resources!.push(ProgramResource.fromJS(item));
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateProgramSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProgramSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["bannerUri"] = this.bannerUri;
        data["logoUri"] = this.logoUri;
        if (Array.isArray(this.resources)) {
            data["resources"] = [];
            for (let item of this.resources)
                data["resources"].push(item.toJSON());
        }
        data["version"] = this.version;
        return data;
    }
}

export class ProgramPhase {
    id?: string | undefined;
    publisherId?: string | undefined;
    publisherName?: string | undefined;
    publisherLogoUri?: string | undefined;
    programId?: string | undefined;
    programName?: string | undefined;
    programLogoUri?: string | undefined;
    programBannerUri?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    resources?: ProgramResource[] | undefined;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.publisherId = _data["publisherId"];
            this.publisherName = _data["publisherName"];
            this.publisherLogoUri = _data["publisherLogoUri"];
            this.programId = _data["programId"];
            this.programName = _data["programName"];
            this.programLogoUri = _data["programLogoUri"];
            this.programBannerUri = _data["programBannerUri"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["resources"])) {
                this.resources = [] as any;
                for (let item of _data["resources"])
                    this.resources!.push(ProgramResource.fromJS(item));
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): ProgramPhase {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramPhase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["publisherId"] = this.publisherId;
        data["publisherName"] = this.publisherName;
        data["publisherLogoUri"] = this.publisherLogoUri;
        data["programId"] = this.programId;
        data["programName"] = this.programName;
        data["programLogoUri"] = this.programLogoUri;
        data["programBannerUri"] = this.programBannerUri;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.resources)) {
            data["resources"] = [];
            for (let item of this.resources)
                data["resources"].push(item.toJSON());
        }
        data["version"] = this.version;
        return data;
    }
}

export class CreateProgramPhaseSettings {
    programId!: string;
    name!: string;
    description?: string | undefined;
    resources?: ProgramResource[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.programId = _data["programId"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["resources"])) {
                this.resources = [] as any;
                for (let item of _data["resources"])
                    this.resources!.push(ProgramResource.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateProgramPhaseSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProgramPhaseSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["programId"] = this.programId;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.resources)) {
            data["resources"] = [];
            for (let item of this.resources)
                data["resources"].push(item.toJSON());
        }
        return data;
    }
}

export class UpdateProgramPhaseSettings {
    name!: string;
    description?: string | undefined;
    resources?: ProgramResource[] | undefined;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["resources"])) {
                this.resources = [] as any;
                for (let item of _data["resources"])
                    this.resources!.push(ProgramResource.fromJS(item));
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateProgramPhaseSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProgramPhaseSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.resources)) {
            data["resources"] = [];
            for (let item of this.resources)
                data["resources"].push(item.toJSON());
        }
        data["version"] = this.version;
        return data;
    }
}

export class ListOfComment {
    totalItemCount!: number;
    items!: Comment[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Comment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfComment {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfComment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class Comment {
    id?: string | undefined;
    rootId?: string | undefined;
    parentId?: string | undefined;
    content?: string | undefined;
    creatorId?: string | undefined;
    creatorName?: string | undefined;
    creatorImageUri?: string | undefined;
    creatorJobTypeId?: string | undefined;
    creatorJobTypeName?: string | undefined;
    created?: Date;
    modifierId?: string | undefined;
    modifierName?: string | undefined;
    modified?: Date;
    replyCount?: number;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.rootId = _data["rootId"];
            this.parentId = _data["parentId"];
            this.content = _data["content"];
            this.creatorId = _data["creatorId"];
            this.creatorName = _data["creatorName"];
            this.creatorImageUri = _data["creatorImageUri"];
            this.creatorJobTypeId = _data["creatorJobTypeId"];
            this.creatorJobTypeName = _data["creatorJobTypeName"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.modifierId = _data["modifierId"];
            this.modifierName = _data["modifierName"];
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
            this.replyCount = _data["replyCount"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): Comment {
        data = typeof data === 'object' ? data : {};
        let result = new Comment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["rootId"] = this.rootId;
        data["parentId"] = this.parentId;
        data["content"] = this.content;
        data["creatorId"] = this.creatorId;
        data["creatorName"] = this.creatorName;
        data["creatorImageUri"] = this.creatorImageUri;
        data["creatorJobTypeId"] = this.creatorJobTypeId;
        data["creatorJobTypeName"] = this.creatorJobTypeName;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["modifierId"] = this.modifierId;
        data["modifierName"] = this.modifierName;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        data["replyCount"] = this.replyCount;
        data["version"] = this.version;
        return data;
    }
}

export class CreateCommentSettings {
    parentId?: string | undefined;
    content!: string;

    init(_data?: any) {
        if (_data) {
            this.parentId = _data["parentId"];
            this.content = _data["content"];
        }
    }

    static fromJS(data: any): CreateCommentSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCommentSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["content"] = this.content;
        return data;
    }
}

export class UpdateCommentSettings {
    content!: string;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.content = _data["content"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateCommentSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCommentSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        data["version"] = this.version;
        return data;
    }
}

export class CreateTaskSettings {
    groupId!: string;
    templateId?: string | undefined;
    name!: string;
    description?: string | undefined;
    estimatedDuration?: string;
    due?: Date | undefined;
    subtasks?: TaskSubtask[] | undefined;
    assigneeIds?: string[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.groupId = _data["groupId"];
            this.templateId = _data["templateId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.estimatedDuration = _data["estimatedDuration"];
            this.due = _data["due"] ? new Date(_data["due"].toString()) : <any>undefined;
            if (Array.isArray(_data["subtasks"])) {
                this.subtasks = [] as any;
                for (let item of _data["subtasks"])
                    this.subtasks!.push(TaskSubtask.fromJS(item));
            }
            if (Array.isArray(_data["assigneeIds"])) {
                this.assigneeIds = [] as any;
                for (let item of _data["assigneeIds"])
                    this.assigneeIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateTaskSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTaskSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        data["templateId"] = this.templateId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["estimatedDuration"] = this.estimatedDuration;
        data["due"] = this.due ? this.due.toISOString() : <any>undefined;
        if (Array.isArray(this.subtasks)) {
            data["subtasks"] = [];
            for (let item of this.subtasks)
                data["subtasks"].push(item.toJSON());
        }
        if (Array.isArray(this.assigneeIds)) {
            data["assigneeIds"] = [];
            for (let item of this.assigneeIds)
                data["assigneeIds"].push(item);
        }
        return data;
    }
}

export class TaskSubtask {
    id?: string | undefined;
    order?: number;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): TaskSubtask {
        data = typeof data === 'object' ? data : {};
        let result = new TaskSubtask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["order"] = this.order;
        return data;
    }
}

export class UpdateTaskSettings {
    name!: string;
    description?: string | undefined;
    estimatedDuration?: string;
    status?: TaskStatus;
    due?: Date | undefined;
    subtasks?: TaskSubtask[] | undefined;
    assigneeIds?: string[] | undefined;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.estimatedDuration = _data["estimatedDuration"];
            this.status = _data["status"];
            this.due = _data["due"] ? new Date(_data["due"].toString()) : <any>undefined;
            if (Array.isArray(_data["subtasks"])) {
                this.subtasks = [] as any;
                for (let item of _data["subtasks"])
                    this.subtasks!.push(TaskSubtask.fromJS(item));
            }
            if (Array.isArray(_data["assigneeIds"])) {
                this.assigneeIds = [] as any;
                for (let item of _data["assigneeIds"])
                    this.assigneeIds!.push(item);
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateTaskSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTaskSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["estimatedDuration"] = this.estimatedDuration;
        data["status"] = this.status;
        data["due"] = this.due ? this.due.toISOString() : <any>undefined;
        if (Array.isArray(this.subtasks)) {
            data["subtasks"] = [];
            for (let item of this.subtasks)
                data["subtasks"].push(item.toJSON());
        }
        if (Array.isArray(this.assigneeIds)) {
            data["assigneeIds"] = [];
            for (let item of this.assigneeIds)
                data["assigneeIds"].push(item);
        }
        data["version"] = this.version;
        return data;
    }
}

export class Sharing {
    id?: string | undefined;
    aliasId?: string | undefined;
    note?: string | undefined;
    type?: SharingType;
    payload?: any | undefined;
    creatorId?: string | undefined;
    creatorType?: IdentityType;
    created?: Date;
    expires?: Date;
    disabled?: boolean;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.aliasId = _data["aliasId"];
            this.note = _data["note"];
            this.type = _data["type"];
            this.payload = _data["payload"];
            this.creatorId = _data["creatorId"];
            this.creatorType = _data["creatorType"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.expires = _data["expires"] ? new Date(_data["expires"].toString()) : <any>undefined;
            this.disabled = _data["disabled"];
        }
    }

    static fromJS(data: any): Sharing {
        data = typeof data === 'object' ? data : {};
        let result = new Sharing();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["aliasId"] = this.aliasId;
        data["note"] = this.note;
        data["type"] = this.type;
        data["payload"] = this.payload;
        data["creatorId"] = this.creatorId;
        data["creatorType"] = this.creatorType;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["expires"] = this.expires ? this.expires.toISOString() : <any>undefined;
        data["disabled"] = this.disabled;
        return data;
    }
}

export enum SharingType {
    GroupInvitation = "GroupInvitation",
}

/** 0 = None 1 = User 2 = Organisation */
export enum IdentityType {
    None = 0,
    User = 1,
    Organisation = 2,
}

export class ListOfSharing {
    totalItemCount!: number;
    items!: Sharing[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Sharing.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfSharing {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfSharing();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class CreateSharingSettingsBase {
    aliasId?: string | undefined;
    note?: string | undefined;
    duration?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.aliasId = _data["aliasId"];
            this.note = _data["note"];
            this.duration = _data["duration"];
        }
    }

    static fromJS(data: any): CreateSharingSettingsBase {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSharingSettingsBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["aliasId"] = this.aliasId;
        data["note"] = this.note;
        data["duration"] = this.duration;
        return data;
    }
}

export class CreateGroupInvitationSharingSettings extends CreateSharingSettingsBase {
    groupId!: string;
    roles?: string[] | undefined;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.groupId = _data["groupId"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateGroupInvitationSharingSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateGroupInvitationSharingSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export class ListOfTicket {
    totalItemCount!: number;
    items!: Ticket[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Ticket.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfTicket {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfTicket();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class Ticket {
    id?: string | undefined;
    version?: number;
    message?: string | undefined;
    ticketType?: TicketType;
    userId?: string | undefined;
    userEmail?: string | undefined;
    userName?: string | undefined;
    created?: Date;
    modified?: Date;
    status?: TicketStatus;
    statusReason?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.version = _data["version"];
            this.message = _data["message"];
            this.ticketType = _data["ticketType"];
            this.userId = _data["userId"];
            this.userEmail = _data["userEmail"];
            this.userName = _data["userName"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.statusReason = _data["statusReason"];
        }
    }

    static fromJS(data: any): Ticket {
        data = typeof data === 'object' ? data : {};
        let result = new Ticket();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["version"] = this.version;
        data["message"] = this.message;
        data["ticketType"] = this.ticketType;
        data["userId"] = this.userId;
        data["userEmail"] = this.userEmail;
        data["userName"] = this.userName;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["statusReason"] = this.statusReason;
        return data;
    }
}

/** 0 = None 1 = GeneralEnquiry */
export enum TicketType {
    None = 0,
    GeneralEnquiry = 1,
}

/** 0 = Open 1 = Resolved 2 = Rejected */
export enum TicketStatus {
    Open = 0,
    Resolved = 1,
    Rejected = 2,
}

export class CreateTicketSettings {
    userEmail!: string;
    userName!: string;
    message!: string;
    type?: TicketType;

    init(_data?: any) {
        if (_data) {
            this.userEmail = _data["userEmail"];
            this.userName = _data["userName"];
            this.message = _data["message"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CreateTicketSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTicketSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userEmail"] = this.userEmail;
        data["userName"] = this.userName;
        data["message"] = this.message;
        data["type"] = this.type;
        return data;
    }
}

export class UpdateTicketSettings {
    status?: TicketStatus;
    reason?: string | undefined;
    version!: number;

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.reason = _data["reason"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateTicketSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTicketSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["reason"] = this.reason;
        data["version"] = this.version;
        return data;
    }
}

export class ListOfSurveyContent {
    totalItemCount!: number;
    items!: SurveyContent[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SurveyContent.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfSurveyContent {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfSurveyContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class SurveyContent {
    id?: string | undefined;
    publisherId?: string | undefined;
    surveyId?: string | undefined;
    questions?: any[] | undefined;
    published?: boolean;
    created?: Date;
    modified?: Date;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.publisherId = _data["publisherId"];
            this.surveyId = _data["surveyId"];
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(item);
            }
            this.published = _data["published"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): SurveyContent {
        data = typeof data === 'object' ? data : {};
        let result = new SurveyContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["publisherId"] = this.publisherId;
        data["surveyId"] = this.surveyId;
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item);
        }
        data["published"] = this.published;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        data["version"] = this.version;
        return data;
    }
}

export class CreateSurveyContentSettings {
    questions!: any[];
    published?: boolean;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(item);
            }
            this.published = _data["published"];
        }
    }

    static fromJS(data: any): CreateSurveyContentSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSurveyContentSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item);
        }
        data["published"] = this.published;
        return data;
    }
}

export class UpdateSurveyContentSettings {
    questions!: any[];
    version?: number;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(item);
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateSurveyContentSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSurveyContentSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item);
        }
        data["version"] = this.version;
        return data;
    }
}

export class SurveyQuestionTypes {
    listQuestion?: ListQuestion | undefined;
    compositeQuestion?: CompositeQuestion | undefined;
    decimalQuestion?: DecimalQuestion | undefined;
    integerQuestion?: IntegerQuestion | undefined;
    multipleChoiceQuestion?: MultipleChoiceQuestion | undefined;
    stringQuestion?: StringQuestion | undefined;
    percentageQuestion?: PercentageQuestion | undefined;
    dateTimeQuestion?: DateTimeQuestion | undefined;
    timeSpanQuestion?: TimeSpanQuestion | undefined;
    userQuestion?: UserQuestion | undefined;
    groupQuestion?: GroupQuestion | undefined;
    fileQuestion?: FileQuestion | undefined;
    binaryQuestion?: BinaryQuestion | undefined;
    timeOfDayQuestion?: TimeOfDayQuestion | undefined;
    emailQuestion?: EmailQuestion | undefined;
    labelQuestion?: LabelQuestion | undefined;

    init(_data?: any) {
        if (_data) {
            this.listQuestion = _data["listQuestion"] ? ListQuestion.fromJS(_data["listQuestion"]) : <any>undefined;
            this.compositeQuestion = _data["compositeQuestion"] ? CompositeQuestion.fromJS(_data["compositeQuestion"]) : <any>undefined;
            this.decimalQuestion = _data["decimalQuestion"] ? DecimalQuestion.fromJS(_data["decimalQuestion"]) : <any>undefined;
            this.integerQuestion = _data["integerQuestion"] ? IntegerQuestion.fromJS(_data["integerQuestion"]) : <any>undefined;
            this.multipleChoiceQuestion = _data["multipleChoiceQuestion"] ? MultipleChoiceQuestion.fromJS(_data["multipleChoiceQuestion"]) : <any>undefined;
            this.stringQuestion = _data["stringQuestion"] ? StringQuestion.fromJS(_data["stringQuestion"]) : <any>undefined;
            this.percentageQuestion = _data["percentageQuestion"] ? PercentageQuestion.fromJS(_data["percentageQuestion"]) : <any>undefined;
            this.dateTimeQuestion = _data["dateTimeQuestion"] ? DateTimeQuestion.fromJS(_data["dateTimeQuestion"]) : <any>undefined;
            this.timeSpanQuestion = _data["timeSpanQuestion"] ? TimeSpanQuestion.fromJS(_data["timeSpanQuestion"]) : <any>undefined;
            this.userQuestion = _data["userQuestion"] ? UserQuestion.fromJS(_data["userQuestion"]) : <any>undefined;
            this.groupQuestion = _data["groupQuestion"] ? GroupQuestion.fromJS(_data["groupQuestion"]) : <any>undefined;
            this.fileQuestion = _data["fileQuestion"] ? FileQuestion.fromJS(_data["fileQuestion"]) : <any>undefined;
            this.binaryQuestion = _data["binaryQuestion"] ? BinaryQuestion.fromJS(_data["binaryQuestion"]) : <any>undefined;
            this.timeOfDayQuestion = _data["timeOfDayQuestion"] ? TimeOfDayQuestion.fromJS(_data["timeOfDayQuestion"]) : <any>undefined;
            this.emailQuestion = _data["emailQuestion"] ? EmailQuestion.fromJS(_data["emailQuestion"]) : <any>undefined;
            this.labelQuestion = _data["labelQuestion"] ? LabelQuestion.fromJS(_data["labelQuestion"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SurveyQuestionTypes {
        data = typeof data === 'object' ? data : {};
        let result = new SurveyQuestionTypes();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["listQuestion"] = this.listQuestion ? this.listQuestion.toJSON() : <any>undefined;
        data["compositeQuestion"] = this.compositeQuestion ? this.compositeQuestion.toJSON() : <any>undefined;
        data["decimalQuestion"] = this.decimalQuestion ? this.decimalQuestion.toJSON() : <any>undefined;
        data["integerQuestion"] = this.integerQuestion ? this.integerQuestion.toJSON() : <any>undefined;
        data["multipleChoiceQuestion"] = this.multipleChoiceQuestion ? this.multipleChoiceQuestion.toJSON() : <any>undefined;
        data["stringQuestion"] = this.stringQuestion ? this.stringQuestion.toJSON() : <any>undefined;
        data["percentageQuestion"] = this.percentageQuestion ? this.percentageQuestion.toJSON() : <any>undefined;
        data["dateTimeQuestion"] = this.dateTimeQuestion ? this.dateTimeQuestion.toJSON() : <any>undefined;
        data["timeSpanQuestion"] = this.timeSpanQuestion ? this.timeSpanQuestion.toJSON() : <any>undefined;
        data["userQuestion"] = this.userQuestion ? this.userQuestion.toJSON() : <any>undefined;
        data["groupQuestion"] = this.groupQuestion ? this.groupQuestion.toJSON() : <any>undefined;
        data["fileQuestion"] = this.fileQuestion ? this.fileQuestion.toJSON() : <any>undefined;
        data["binaryQuestion"] = this.binaryQuestion ? this.binaryQuestion.toJSON() : <any>undefined;
        data["timeOfDayQuestion"] = this.timeOfDayQuestion ? this.timeOfDayQuestion.toJSON() : <any>undefined;
        data["emailQuestion"] = this.emailQuestion ? this.emailQuestion.toJSON() : <any>undefined;
        data["labelQuestion"] = this.labelQuestion ? this.labelQuestion.toJSON() : <any>undefined;
        return data;
    }
}

export abstract class QuestionBase {
    type?: string | undefined;
    label?: string | undefined;
    note?: string | undefined;
    variable?: string | undefined;
    required?: boolean;
    enableIf?: string | undefined;
    customValidations?: CustomValidation[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.label = _data["label"];
            this.note = _data["note"];
            this.variable = _data["variable"];
            this.required = _data["required"];
            this.enableIf = _data["enableIf"];
            if (Array.isArray(_data["customValidations"])) {
                this.customValidations = [] as any;
                for (let item of _data["customValidations"])
                    this.customValidations!.push(CustomValidation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuestionBase {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'QuestionBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["label"] = this.label;
        data["note"] = this.note;
        data["variable"] = this.variable;
        data["required"] = this.required;
        data["enableIf"] = this.enableIf;
        if (Array.isArray(this.customValidations)) {
            data["customValidations"] = [];
            for (let item of this.customValidations)
                data["customValidations"].push(item.toJSON());
        }
        return data;
    }
}

export class ListQuestion extends QuestionBase {
    layout?: LayoutType;
    question?: any | undefined;
    minimumAnswers?: number | undefined;
    maximumAnswers?: number | undefined;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.layout = _data["layout"];
            this.question = _data["question"];
            this.minimumAnswers = _data["minimumAnswers"];
            this.maximumAnswers = _data["maximumAnswers"];
        }
    }

    static fromJS(data: any): ListQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new ListQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layout"] = this.layout;
        data["question"] = this.question;
        data["minimumAnswers"] = this.minimumAnswers;
        data["maximumAnswers"] = this.maximumAnswers;
        super.toJSON(data);
        return data;
    }
}

/** 0 = None 1 = Horizontal 2 = Vertical */
export enum LayoutType {
    None = 0,
    Horizontal = 1,
    Vertical = 2,
}

export class CustomValidation {
    expression?: string | undefined;
    errorMessage?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.expression = _data["expression"];
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): CustomValidation {
        data = typeof data === 'object' ? data : {};
        let result = new CustomValidation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expression"] = this.expression;
        data["errorMessage"] = this.errorMessage;
        return data;
    }
}

export class CompositeQuestion extends QuestionBase {
    layout?: LayoutType;
    questions?: any[] | undefined;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.layout = _data["layout"];
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(item);
            }
        }
    }

    static fromJS(data: any): CompositeQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new CompositeQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layout"] = this.layout;
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export class DecimalQuestion extends QuestionBase {
    minimum?: number | undefined;
    maximum?: number | undefined;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.minimum = _data["minimum"];
            this.maximum = _data["maximum"];
        }
    }

    static fromJS(data: any): DecimalQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new DecimalQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minimum"] = this.minimum;
        data["maximum"] = this.maximum;
        super.toJSON(data);
        return data;
    }
}

export class IntegerQuestion extends QuestionBase {
    display?: IntegerQuestionDisplayType;
    minimum?: number | undefined;
    maximum?: number | undefined;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.display = _data["display"];
            this.minimum = _data["minimum"];
            this.maximum = _data["maximum"];
        }
    }

    static fromJS(data: any): IntegerQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new IntegerQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["display"] = this.display;
        data["minimum"] = this.minimum;
        data["maximum"] = this.maximum;
        super.toJSON(data);
        return data;
    }
}

/** 0 = None 1 = Counter */
export enum IntegerQuestionDisplayType {
    None = 0,
    Counter = 1,
}

export class MultipleChoiceQuestion extends QuestionBase {
    options?: string[] | undefined;
    minimumResponses?: number | undefined;
    maximumResponses?: number | undefined;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["options"])) {
                this.options = [] as any;
                for (let item of _data["options"])
                    this.options!.push(item);
            }
            this.minimumResponses = _data["minimumResponses"];
            this.maximumResponses = _data["maximumResponses"];
        }
    }

    static fromJS(data: any): MultipleChoiceQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new MultipleChoiceQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item);
        }
        data["minimumResponses"] = this.minimumResponses;
        data["maximumResponses"] = this.maximumResponses;
        super.toJSON(data);
        return data;
    }
}

export class StringQuestion extends QuestionBase {
    lineType?: LineType;
    minimumLength?: number | undefined;
    maximumLength?: number | undefined;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.lineType = _data["lineType"];
            this.minimumLength = _data["minimumLength"];
            this.maximumLength = _data["maximumLength"];
        }
    }

    static fromJS(data: any): StringQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new StringQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lineType"] = this.lineType;
        data["minimumLength"] = this.minimumLength;
        data["maximumLength"] = this.maximumLength;
        super.toJSON(data);
        return data;
    }
}

/** 0 = None 1 = SingleLine 2 = MultiLine */
export enum LineType {
    None = 0,
    SingleLine = 1,
    MultiLine = 2,
}

export class PercentageQuestion extends QuestionBase {
    minimum?: number | undefined;
    maximum?: number | undefined;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.minimum = _data["minimum"];
            this.maximum = _data["maximum"];
        }
    }

    static fromJS(data: any): PercentageQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new PercentageQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minimum"] = this.minimum;
        data["maximum"] = this.maximum;
        super.toJSON(data);
        return data;
    }
}

export class DateTimeQuestion extends QuestionBase {
    constraint?: DateTimeConstraintType;
    minimum?: Date | undefined;
    maximum?: Date | undefined;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.constraint = _data["constraint"];
            this.minimum = _data["minimum"] ? new Date(_data["minimum"].toString()) : <any>undefined;
            this.maximum = _data["maximum"] ? new Date(_data["maximum"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DateTimeQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new DateTimeQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["constraint"] = this.constraint;
        data["minimum"] = this.minimum ? this.minimum.toISOString() : <any>undefined;
        data["maximum"] = this.maximum ? this.maximum.toISOString() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** 0 = None 1 = Date */
export enum DateTimeConstraintType {
    None = 0,
    Date = 1,
}

export class TimeSpanQuestion extends QuestionBase {
    constraint?: TimeSpanConstraintType;
    minimum?: string | undefined;
    maximum?: string | undefined;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.constraint = _data["constraint"];
            this.minimum = _data["minimum"];
            this.maximum = _data["maximum"];
        }
    }

    static fromJS(data: any): TimeSpanQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new TimeSpanQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["constraint"] = this.constraint;
        data["minimum"] = this.minimum;
        data["maximum"] = this.maximum;
        super.toJSON(data);
        return data;
    }
}

/** 0 = None 1 = Days 2 = Hours 3 = Minutes 4 = Seconds */
export enum TimeSpanConstraintType {
    None = 0,
    Days = 1,
    Hours = 2,
    Minutes = 3,
    Seconds = 4,
}

export class UserQuestion extends QuestionBase {
    jobTypeCategories?: string[] | undefined;
    jobTypeIds?: string[] | undefined;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["jobTypeCategories"])) {
                this.jobTypeCategories = [] as any;
                for (let item of _data["jobTypeCategories"])
                    this.jobTypeCategories!.push(item);
            }
            if (Array.isArray(_data["jobTypeIds"])) {
                this.jobTypeIds = [] as any;
                for (let item of _data["jobTypeIds"])
                    this.jobTypeIds!.push(item);
            }
        }
    }

    static fromJS(data: any): UserQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new UserQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.jobTypeCategories)) {
            data["jobTypeCategories"] = [];
            for (let item of this.jobTypeCategories)
                data["jobTypeCategories"].push(item);
        }
        if (Array.isArray(this.jobTypeIds)) {
            data["jobTypeIds"] = [];
            for (let item of this.jobTypeIds)
                data["jobTypeIds"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export class GroupQuestion extends QuestionBase {
    groupType?: string | undefined;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.groupType = _data["groupType"];
        }
    }

    static fromJS(data: any): GroupQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new GroupQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupType"] = this.groupType;
        super.toJSON(data);
        return data;
    }
}

export class FileQuestion extends QuestionBase {
    contentTypes?: string[] | undefined;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["contentTypes"])) {
                this.contentTypes = [] as any;
                for (let item of _data["contentTypes"])
                    this.contentTypes!.push(item);
            }
        }
    }

    static fromJS(data: any): FileQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new FileQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.contentTypes)) {
            data["contentTypes"] = [];
            for (let item of this.contentTypes)
                data["contentTypes"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export class BinaryQuestion extends QuestionBase {

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): BinaryQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new BinaryQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export class TimeOfDayQuestion extends QuestionBase {

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): TimeOfDayQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new TimeOfDayQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export class EmailQuestion extends QuestionBase {
    constraint?: DomainConstraint | undefined;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.constraint = _data["constraint"] ? DomainConstraint.fromJS(_data["constraint"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EmailQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new EmailQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["constraint"] = this.constraint ? this.constraint.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export class DomainConstraint {
    type?: DomainConstraintType;
    domains?: string[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            if (Array.isArray(_data["domains"])) {
                this.domains = [] as any;
                for (let item of _data["domains"])
                    this.domains!.push(item);
            }
        }
    }

    static fromJS(data: any): DomainConstraint {
        data = typeof data === 'object' ? data : {};
        let result = new DomainConstraint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        if (Array.isArray(this.domains)) {
            data["domains"] = [];
            for (let item of this.domains)
                data["domains"].push(item);
        }
        return data;
    }
}

/** 0 = Black 1 = White */
export enum DomainConstraintType {
    Black = 0,
    White = 1,
}

export class LabelQuestion extends QuestionBase {
    minimumResponses?: number | undefined;
    maximumResponses?: number | undefined;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.minimumResponses = _data["minimumResponses"];
            this.maximumResponses = _data["maximumResponses"];
        }
    }

    static fromJS(data: any): LabelQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new LabelQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minimumResponses"] = this.minimumResponses;
        data["maximumResponses"] = this.maximumResponses;
        super.toJSON(data);
        return data;
    }
}

export class SurveyAnswerTypes {
    listAnswer?: ListAnswer | undefined;
    compositeAnswer?: CompositeAnswer | undefined;
    decimalAnswer?: DecimalAnswer | undefined;
    integerAnswer?: IntegerAnswer | undefined;
    multipleChoiceAnswer?: MultipleChoiceAnswer | undefined;
    stringAnswer?: StringAnswer | undefined;
    percentageAnswer?: PercentageAnswer | undefined;
    dateTimeAnswer?: DateTimeAnswer | undefined;
    timeSpanAnswer?: TimeSpanAnswer | undefined;
    userAnswer?: UserAnswer | undefined;
    groupAnswer?: GroupAnswer | undefined;
    fileAnswer?: FileAnswer | undefined;
    binaryAnswer?: BinaryAnswer | undefined;
    timeOfDayAnswer?: TimeOfDayAnswer | undefined;
    emailAnswer?: EmailAnswer | undefined;
    labelAnswer?: LabelAnswer | undefined;

    init(_data?: any) {
        if (_data) {
            this.listAnswer = _data["listAnswer"] ? ListAnswer.fromJS(_data["listAnswer"]) : <any>undefined;
            this.compositeAnswer = _data["compositeAnswer"] ? CompositeAnswer.fromJS(_data["compositeAnswer"]) : <any>undefined;
            this.decimalAnswer = _data["decimalAnswer"] ? DecimalAnswer.fromJS(_data["decimalAnswer"]) : <any>undefined;
            this.integerAnswer = _data["integerAnswer"] ? IntegerAnswer.fromJS(_data["integerAnswer"]) : <any>undefined;
            this.multipleChoiceAnswer = _data["multipleChoiceAnswer"] ? MultipleChoiceAnswer.fromJS(_data["multipleChoiceAnswer"]) : <any>undefined;
            this.stringAnswer = _data["stringAnswer"] ? StringAnswer.fromJS(_data["stringAnswer"]) : <any>undefined;
            this.percentageAnswer = _data["percentageAnswer"] ? PercentageAnswer.fromJS(_data["percentageAnswer"]) : <any>undefined;
            this.dateTimeAnswer = _data["dateTimeAnswer"] ? DateTimeAnswer.fromJS(_data["dateTimeAnswer"]) : <any>undefined;
            this.timeSpanAnswer = _data["timeSpanAnswer"] ? TimeSpanAnswer.fromJS(_data["timeSpanAnswer"]) : <any>undefined;
            this.userAnswer = _data["userAnswer"] ? UserAnswer.fromJS(_data["userAnswer"]) : <any>undefined;
            this.groupAnswer = _data["groupAnswer"] ? GroupAnswer.fromJS(_data["groupAnswer"]) : <any>undefined;
            this.fileAnswer = _data["fileAnswer"] ? FileAnswer.fromJS(_data["fileAnswer"]) : <any>undefined;
            this.binaryAnswer = _data["binaryAnswer"] ? BinaryAnswer.fromJS(_data["binaryAnswer"]) : <any>undefined;
            this.timeOfDayAnswer = _data["timeOfDayAnswer"] ? TimeOfDayAnswer.fromJS(_data["timeOfDayAnswer"]) : <any>undefined;
            this.emailAnswer = _data["emailAnswer"] ? EmailAnswer.fromJS(_data["emailAnswer"]) : <any>undefined;
            this.labelAnswer = _data["labelAnswer"] ? LabelAnswer.fromJS(_data["labelAnswer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SurveyAnswerTypes {
        data = typeof data === 'object' ? data : {};
        let result = new SurveyAnswerTypes();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["listAnswer"] = this.listAnswer ? this.listAnswer.toJSON() : <any>undefined;
        data["compositeAnswer"] = this.compositeAnswer ? this.compositeAnswer.toJSON() : <any>undefined;
        data["decimalAnswer"] = this.decimalAnswer ? this.decimalAnswer.toJSON() : <any>undefined;
        data["integerAnswer"] = this.integerAnswer ? this.integerAnswer.toJSON() : <any>undefined;
        data["multipleChoiceAnswer"] = this.multipleChoiceAnswer ? this.multipleChoiceAnswer.toJSON() : <any>undefined;
        data["stringAnswer"] = this.stringAnswer ? this.stringAnswer.toJSON() : <any>undefined;
        data["percentageAnswer"] = this.percentageAnswer ? this.percentageAnswer.toJSON() : <any>undefined;
        data["dateTimeAnswer"] = this.dateTimeAnswer ? this.dateTimeAnswer.toJSON() : <any>undefined;
        data["timeSpanAnswer"] = this.timeSpanAnswer ? this.timeSpanAnswer.toJSON() : <any>undefined;
        data["userAnswer"] = this.userAnswer ? this.userAnswer.toJSON() : <any>undefined;
        data["groupAnswer"] = this.groupAnswer ? this.groupAnswer.toJSON() : <any>undefined;
        data["fileAnswer"] = this.fileAnswer ? this.fileAnswer.toJSON() : <any>undefined;
        data["binaryAnswer"] = this.binaryAnswer ? this.binaryAnswer.toJSON() : <any>undefined;
        data["timeOfDayAnswer"] = this.timeOfDayAnswer ? this.timeOfDayAnswer.toJSON() : <any>undefined;
        data["emailAnswer"] = this.emailAnswer ? this.emailAnswer.toJSON() : <any>undefined;
        data["labelAnswer"] = this.labelAnswer ? this.labelAnswer.toJSON() : <any>undefined;
        return data;
    }
}

export abstract class AnswerBaseOfObjectOf {
    type?: string | undefined;
    questionIndex?: number;
    value?: any[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.questionIndex = _data["questionIndex"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(item);
            }
        }
    }

    static fromJS(data: any): AnswerBaseOfObjectOf {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'AnswerBaseOfObjectOf' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["questionIndex"] = this.questionIndex;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        return data;
    }
}

export class ListAnswer extends AnswerBaseOfObjectOf {

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): ListAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new ListAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export class CompositeAnswer extends AnswerBaseOfObjectOf {

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): CompositeAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new CompositeAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export abstract class AnswerBaseOfNullableDouble {
    type?: string | undefined;
    questionIndex?: number;
    value?: number | undefined;

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.questionIndex = _data["questionIndex"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): AnswerBaseOfNullableDouble {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'AnswerBaseOfNullableDouble' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["questionIndex"] = this.questionIndex;
        data["value"] = this.value;
        return data;
    }
}

export class DecimalAnswer extends AnswerBaseOfNullableDouble {

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): DecimalAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new DecimalAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export abstract class AnswerBaseOfNullableInteger {
    type?: string | undefined;
    questionIndex?: number;
    value?: number | undefined;

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.questionIndex = _data["questionIndex"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): AnswerBaseOfNullableInteger {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'AnswerBaseOfNullableInteger' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["questionIndex"] = this.questionIndex;
        data["value"] = this.value;
        return data;
    }
}

export class IntegerAnswer extends AnswerBaseOfNullableInteger {

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): IntegerAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new IntegerAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export abstract class AnswerBaseOfInt32Of {
    type?: string | undefined;
    questionIndex?: number;
    value?: number[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.questionIndex = _data["questionIndex"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(item);
            }
        }
    }

    static fromJS(data: any): AnswerBaseOfInt32Of {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'AnswerBaseOfInt32Of' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["questionIndex"] = this.questionIndex;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        return data;
    }
}

export class MultipleChoiceAnswer extends AnswerBaseOfInt32Of {

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): MultipleChoiceAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new MultipleChoiceAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export abstract class AnswerBaseOfString {
    type?: string | undefined;
    questionIndex?: number;
    value?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.questionIndex = _data["questionIndex"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): AnswerBaseOfString {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'AnswerBaseOfString' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["questionIndex"] = this.questionIndex;
        data["value"] = this.value;
        return data;
    }
}

export class StringAnswer extends AnswerBaseOfString {

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): StringAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new StringAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export class PercentageAnswer extends AnswerBaseOfNullableDouble {

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): PercentageAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new PercentageAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export abstract class AnswerBaseOfNullableDateTime {
    type?: string | undefined;
    questionIndex?: number;
    value?: Date | undefined;

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.questionIndex = _data["questionIndex"];
            this.value = _data["value"] ? new Date(_data["value"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AnswerBaseOfNullableDateTime {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'AnswerBaseOfNullableDateTime' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["questionIndex"] = this.questionIndex;
        data["value"] = this.value ? this.value.toISOString() : <any>undefined;
        return data;
    }
}

export class DateTimeAnswer extends AnswerBaseOfNullableDateTime {

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): DateTimeAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new DateTimeAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export abstract class AnswerBaseOfNullableTimeSpan {
    type?: string | undefined;
    questionIndex?: number;
    value?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.questionIndex = _data["questionIndex"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): AnswerBaseOfNullableTimeSpan {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'AnswerBaseOfNullableTimeSpan' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["questionIndex"] = this.questionIndex;
        data["value"] = this.value;
        return data;
    }
}

export class TimeSpanAnswer extends AnswerBaseOfNullableTimeSpan {

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): TimeSpanAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new TimeSpanAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export abstract class AnswerBaseOfUserAnswerValue {
    type?: string | undefined;
    questionIndex?: number;
    value?: UserAnswerValue | undefined;

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.questionIndex = _data["questionIndex"];
            this.value = _data["value"] ? UserAnswerValue.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AnswerBaseOfUserAnswerValue {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'AnswerBaseOfUserAnswerValue' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["questionIndex"] = this.questionIndex;
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data;
    }
}

export class UserAnswer extends AnswerBaseOfUserAnswerValue {

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): UserAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new UserAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export class UserAnswerValue {
    valueType?: UserValueType;
    value?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.valueType = _data["valueType"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): UserAnswerValue {
        data = typeof data === 'object' ? data : {};
        let result = new UserAnswerValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["valueType"] = this.valueType;
        data["value"] = this.value;
        return data;
    }
}

/** 0 = Id 1 = Name */
export enum UserValueType {
    Id = 0,
    Name = 1,
}

export class GroupAnswer extends AnswerBaseOfString {

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): GroupAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new GroupAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export class FileAnswer extends AnswerBaseOfString {

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): FileAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new FileAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export abstract class AnswerBaseOfBoolean {
    type?: string | undefined;
    questionIndex?: number;
    value?: boolean;

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.questionIndex = _data["questionIndex"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): AnswerBaseOfBoolean {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'AnswerBaseOfBoolean' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["questionIndex"] = this.questionIndex;
        data["value"] = this.value;
        return data;
    }
}

export class BinaryAnswer extends AnswerBaseOfBoolean {

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): BinaryAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new BinaryAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export class TimeOfDayAnswer extends AnswerBaseOfNullableTimeSpan {

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): TimeOfDayAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new TimeOfDayAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export class EmailAnswer extends AnswerBaseOfString {

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): EmailAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new EmailAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export abstract class AnswerBaseOfStringOf {
    type?: string | undefined;
    questionIndex?: number;
    value?: string[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.questionIndex = _data["questionIndex"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(item);
            }
        }
    }

    static fromJS(data: any): AnswerBaseOfStringOf {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'AnswerBaseOfStringOf' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["questionIndex"] = this.questionIndex;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        return data;
    }
}

export class LabelAnswer extends AnswerBaseOfStringOf {

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): LabelAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new LabelAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export class SurveySettings {
    questions?: any[] | undefined;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(item);
            }
        }
    }

    static fromJS(data: any): SurveySettings {
        data = typeof data === 'object' ? data : {};
        let result = new SurveySettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item);
        }
        return data;
    }
}

export class ListOfSurvey {
    totalItemCount!: number;
    items!: Survey[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Survey.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfSurvey {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfSurvey();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class Survey {
    id?: string | undefined;
    publisherId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    isPublic?: boolean;
    published?: boolean;
    publishedContentId?: string | undefined;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.publisherId = _data["publisherId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.isPublic = _data["isPublic"];
            this.published = _data["published"];
            this.publishedContentId = _data["publishedContentId"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): Survey {
        data = typeof data === 'object' ? data : {};
        let result = new Survey();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["publisherId"] = this.publisherId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["isPublic"] = this.isPublic;
        data["published"] = this.published;
        data["publishedContentId"] = this.publishedContentId;
        data["version"] = this.version;
        return data;
    }
}

export class CreateSurveySettings {
    publisherId!: string;
    name!: string;
    description?: string | undefined;
    isPublic?: boolean;

    init(_data?: any) {
        if (_data) {
            this.publisherId = _data["publisherId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.isPublic = _data["isPublic"];
        }
    }

    static fromJS(data: any): CreateSurveySettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSurveySettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["publisherId"] = this.publisherId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["isPublic"] = this.isPublic;
        return data;
    }
}

export class UpdateSurveySettings {
    name!: string;
    description?: string | undefined;
    isPublic?: boolean;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.isPublic = _data["isPublic"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateSurveySettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSurveySettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["isPublic"] = this.isPublic;
        data["version"] = this.version;
        return data;
    }
}

export class ListOfSurveyRequest {
    totalItemCount!: number;
    items!: SurveyRequest[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SurveyRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfSurveyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfSurveyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class SurveyRequest {
    id?: string | undefined;
    surveyId?: string | undefined;
    surveyName?: string | undefined;
    surveyPublisherId?: string | undefined;
    groupId?: string | undefined;
    respondentId?: string | undefined;
    respondentName?: string | undefined;
    creatorId?: string | undefined;
    creatorName?: string | undefined;
    token?: string | undefined;
    created?: Date;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.surveyId = _data["surveyId"];
            this.surveyName = _data["surveyName"];
            this.surveyPublisherId = _data["surveyPublisherId"];
            this.groupId = _data["groupId"];
            this.respondentId = _data["respondentId"];
            this.respondentName = _data["respondentName"];
            this.creatorId = _data["creatorId"];
            this.creatorName = _data["creatorName"];
            this.token = _data["token"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): SurveyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SurveyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["surveyId"] = this.surveyId;
        data["surveyName"] = this.surveyName;
        data["surveyPublisherId"] = this.surveyPublisherId;
        data["groupId"] = this.groupId;
        data["respondentId"] = this.respondentId;
        data["respondentName"] = this.respondentName;
        data["creatorId"] = this.creatorId;
        data["creatorName"] = this.creatorName;
        data["token"] = this.token;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["version"] = this.version;
        return data;
    }
}

export class Token {
    value?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Token {
        data = typeof data === 'object' ? data : {};
        let result = new Token();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        return data;
    }
}

export class CreateSurveyRequestSettings {
    surveyId!: string;
    groupId!: string;
    respondentId!: string;
    message?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.surveyId = _data["surveyId"];
            this.groupId = _data["groupId"];
            this.respondentId = _data["respondentId"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): CreateSurveyRequestSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSurveyRequestSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["surveyId"] = this.surveyId;
        data["groupId"] = this.groupId;
        data["respondentId"] = this.respondentId;
        data["message"] = this.message;
        return data;
    }
}

export class ListOfSurveyResponse {
    totalItemCount!: number;
    items!: SurveyResponse[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SurveyResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfSurveyResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfSurveyResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class SurveyResponse {
    id?: string | undefined;
    surveyId?: string | undefined;
    surveyName?: string | undefined;
    surveyPublisherId?: string | undefined;
    surveyContentId?: string | undefined;
    surveyRequestId?: string | undefined;
    groupId?: string | undefined;
    parentGroupIds?: string[] | undefined;
    respondentId?: string | undefined;
    respondentName?: string | undefined;
    respondentIPAddress?: string | undefined;
    respondentUserAgent?: string | undefined;
    respondentJobTypeId?: string | undefined;
    answers?: any[] | undefined;
    started?: Date;
    submitted?: Date | undefined;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.surveyId = _data["surveyId"];
            this.surveyName = _data["surveyName"];
            this.surveyPublisherId = _data["surveyPublisherId"];
            this.surveyContentId = _data["surveyContentId"];
            this.surveyRequestId = _data["surveyRequestId"];
            this.groupId = _data["groupId"];
            if (Array.isArray(_data["parentGroupIds"])) {
                this.parentGroupIds = [] as any;
                for (let item of _data["parentGroupIds"])
                    this.parentGroupIds!.push(item);
            }
            this.respondentId = _data["respondentId"];
            this.respondentName = _data["respondentName"];
            this.respondentIPAddress = _data["respondentIPAddress"];
            this.respondentUserAgent = _data["respondentUserAgent"];
            this.respondentJobTypeId = _data["respondentJobTypeId"];
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(item);
            }
            this.started = _data["started"] ? new Date(_data["started"].toString()) : <any>undefined;
            this.submitted = _data["submitted"] ? new Date(_data["submitted"].toString()) : <any>undefined;
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): SurveyResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SurveyResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["surveyId"] = this.surveyId;
        data["surveyName"] = this.surveyName;
        data["surveyPublisherId"] = this.surveyPublisherId;
        data["surveyContentId"] = this.surveyContentId;
        data["surveyRequestId"] = this.surveyRequestId;
        data["groupId"] = this.groupId;
        if (Array.isArray(this.parentGroupIds)) {
            data["parentGroupIds"] = [];
            for (let item of this.parentGroupIds)
                data["parentGroupIds"].push(item);
        }
        data["respondentId"] = this.respondentId;
        data["respondentName"] = this.respondentName;
        data["respondentIPAddress"] = this.respondentIPAddress;
        data["respondentUserAgent"] = this.respondentUserAgent;
        data["respondentJobTypeId"] = this.respondentJobTypeId;
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item);
        }
        data["started"] = this.started ? this.started.toISOString() : <any>undefined;
        data["submitted"] = this.submitted ? this.submitted.toISOString() : <any>undefined;
        data["version"] = this.version;
        return data;
    }
}

export class CreateSurveyResponseSettings {
    surveyContentId!: string;
    groupId!: string;
    surveyRequestId?: string | undefined;
    answers?: any[] | undefined;
    submitted?: boolean;

    init(_data?: any) {
        if (_data) {
            this.surveyContentId = _data["surveyContentId"];
            this.groupId = _data["groupId"];
            this.surveyRequestId = _data["surveyRequestId"];
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(item);
            }
            this.submitted = _data["submitted"];
        }
    }

    static fromJS(data: any): CreateSurveyResponseSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSurveyResponseSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["surveyContentId"] = this.surveyContentId;
        data["groupId"] = this.groupId;
        data["surveyRequestId"] = this.surveyRequestId;
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item);
        }
        data["submitted"] = this.submitted;
        return data;
    }
}

export class UpdateSurveyResponseSettings {
    answers?: any[] | undefined;
    submitted?: boolean;
    version!: number;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(item);
            }
            this.submitted = _data["submitted"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateSurveyResponseSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSurveyResponseSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item);
        }
        data["submitted"] = this.submitted;
        data["version"] = this.version;
        return data;
    }
}

export class Actor {
    id?: string | undefined;
    name?: string | undefined;
    imageUri?: string | undefined;
    type?: ActorType;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.imageUri = _data["imageUri"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): Actor {
        data = typeof data === 'object' ? data : {};
        let result = new Actor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["imageUri"] = this.imageUri;
        data["type"] = this.type;
        return data;
    }
}

/** 0 = None 1 = User 2 = TrainingSession 3 = Team */
export enum ActorType {
    None = 0,
    User = 1,
    TrainingSession = 2,
    Team = 3,
}

export class ListOfModuleAttemptOfBookResult {
    totalItemCount!: number;
    items!: ModuleAttemptOfBookResult[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ModuleAttemptOfBookResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfModuleAttemptOfBookResult {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfModuleAttemptOfBookResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class ModuleAttempt {
    id?: string | undefined;
    actorId?: string | undefined;
    actorType?: ActorType;
    actorName?: string | undefined;
    actorImageUri?: string | undefined;
    creatorId?: string | undefined;
    creatorName?: string | undefined;
    publisherId?: string | undefined;
    publisherName?: string | undefined;
    publisherLogoUri?: string | undefined;
    moduleId?: string | undefined;
    moduleName?: string | undefined;
    moduleContentId?: string | undefined;
    moduleType?: string | undefined;
    result?: any | undefined;
    calculatedResult?: CalculatedModuleResult;
    classIds?: string[] | undefined;
    trainingSessionId?: string | undefined;
    trainingSessionModuleAttemptId?: string | undefined;
    created?: Date;
    modified?: Date;
    passed?: Date | undefined;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.actorId = _data["actorId"];
            this.actorType = _data["actorType"];
            this.actorName = _data["actorName"];
            this.actorImageUri = _data["actorImageUri"];
            this.creatorId = _data["creatorId"];
            this.creatorName = _data["creatorName"];
            this.publisherId = _data["publisherId"];
            this.publisherName = _data["publisherName"];
            this.publisherLogoUri = _data["publisherLogoUri"];
            this.moduleId = _data["moduleId"];
            this.moduleName = _data["moduleName"];
            this.moduleContentId = _data["moduleContentId"];
            this.moduleType = _data["moduleType"];
            this.result = _data["result"];
            this.calculatedResult = _data["calculatedResult"] ? CalculatedModuleResult.fromJS(_data["calculatedResult"]) : <any>undefined;
            if (Array.isArray(_data["classIds"])) {
                this.classIds = [] as any;
                for (let item of _data["classIds"])
                    this.classIds!.push(item);
            }
            this.trainingSessionId = _data["trainingSessionId"];
            this.trainingSessionModuleAttemptId = _data["trainingSessionModuleAttemptId"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
            this.passed = _data["passed"] ? new Date(_data["passed"].toString()) : <any>undefined;
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): ModuleAttempt {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleAttempt();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["actorId"] = this.actorId;
        data["actorType"] = this.actorType;
        data["actorName"] = this.actorName;
        data["actorImageUri"] = this.actorImageUri;
        data["creatorId"] = this.creatorId;
        data["creatorName"] = this.creatorName;
        data["publisherId"] = this.publisherId;
        data["publisherName"] = this.publisherName;
        data["publisherLogoUri"] = this.publisherLogoUri;
        data["moduleId"] = this.moduleId;
        data["moduleName"] = this.moduleName;
        data["moduleContentId"] = this.moduleContentId;
        data["moduleType"] = this.moduleType;
        data["result"] = this.result;
        data["calculatedResult"] = this.calculatedResult ? this.calculatedResult.toJSON() : <any>undefined;
        if (Array.isArray(this.classIds)) {
            data["classIds"] = [];
            for (let item of this.classIds)
                data["classIds"].push(item);
        }
        data["trainingSessionId"] = this.trainingSessionId;
        data["trainingSessionModuleAttemptId"] = this.trainingSessionModuleAttemptId;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        data["passed"] = this.passed ? this.passed.toISOString() : <any>undefined;
        data["version"] = this.version;
        return data;
    }
}

export class ModuleAttemptOfBookResult extends ModuleAttempt {
    result?: BookResult | undefined;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.result = _data["result"] ? BookResult.fromJS(_data["result"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ModuleAttemptOfBookResult {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleAttemptOfBookResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export class BookResult {
    bookmark?: Bookmark | undefined;
    maxBookmark?: Bookmark | undefined;

    init(_data?: any) {
        if (_data) {
            this.bookmark = _data["bookmark"] ? Bookmark.fromJS(_data["bookmark"]) : <any>undefined;
            this.maxBookmark = _data["maxBookmark"] ? Bookmark.fromJS(_data["maxBookmark"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BookResult {
        data = typeof data === 'object' ? data : {};
        let result = new BookResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bookmark"] = this.bookmark ? this.bookmark.toJSON() : <any>undefined;
        data["maxBookmark"] = this.maxBookmark ? this.maxBookmark.toJSON() : <any>undefined;
        return data;
    }
}

export class Bookmark {
    percentage?: number;

    init(_data?: any) {
        if (_data) {
            this.percentage = _data["percentage"];
        }
    }

    static fromJS(data: any): Bookmark {
        data = typeof data === 'object' ? data : {};
        let result = new Bookmark();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["percentage"] = this.percentage;
        return data;
    }
}

export class CalculatedModuleResult {
    passed?: boolean;
    progress?: number;
    score?: number;

    init(_data?: any) {
        if (_data) {
            this.passed = _data["passed"];
            this.progress = _data["progress"];
            this.score = _data["score"];
        }
    }

    static fromJS(data: any): CalculatedModuleResult {
        data = typeof data === 'object' ? data : {};
        let result = new CalculatedModuleResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["passed"] = this.passed;
        data["progress"] = this.progress;
        data["score"] = this.score;
        return data;
    }
}

export class CreateModuleAttemptSettingsOfBookResult {
    /** Id of the actor of ActorType being assessed */
    actorId!: string;
    moduleContentId!: string;
    result!: BookResult;

    init(_data?: any) {
        if (_data) {
            this.actorId = _data["actorId"];
            this.moduleContentId = _data["moduleContentId"];
            this.result = _data["result"] ? BookResult.fromJS(_data["result"]) : new BookResult();
        }
    }

    static fromJS(data: any): CreateModuleAttemptSettingsOfBookResult {
        data = typeof data === 'object' ? data : {};
        let result = new CreateModuleAttemptSettingsOfBookResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actorId"] = this.actorId;
        data["moduleContentId"] = this.moduleContentId;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export class UpdateModuleAttemptSettingsOfBookResult {
    result!: BookResult;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? BookResult.fromJS(_data["result"]) : new BookResult();
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateModuleAttemptSettingsOfBookResult {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateModuleAttemptSettingsOfBookResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["version"] = this.version;
        return data;
    }
}

export class ListOfModuleContentOfBookSettings {
    totalItemCount!: number;
    items!: ModuleContentOfBookSettings[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ModuleContentOfBookSettings.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfModuleContentOfBookSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfModuleContentOfBookSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class ModuleContent {
    id?: string | undefined;
    publisherId?: string | undefined;
    moduleId?: string | undefined;
    type?: string | undefined;
    settings?: any | undefined;
    published?: boolean;
    created?: Date;
    modified?: Date;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.publisherId = _data["publisherId"];
            this.moduleId = _data["moduleId"];
            this.type = _data["type"];
            this.settings = _data["settings"];
            this.published = _data["published"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): ModuleContent {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["publisherId"] = this.publisherId;
        data["moduleId"] = this.moduleId;
        data["type"] = this.type;
        data["settings"] = this.settings;
        data["published"] = this.published;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        data["version"] = this.version;
        return data;
    }
}

export class ModuleContentOfBookSettings extends ModuleContent {
    settings?: BookSettings | undefined;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.settings = _data["settings"] ? BookSettings.fromJS(_data["settings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ModuleContentOfBookSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleContentOfBookSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export class BookSettings {
    chapters!: Chapter[];

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["chapters"])) {
                this.chapters = [] as any;
                for (let item of _data["chapters"])
                    this.chapters!.push(Chapter.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BookSettings {
        data = typeof data === 'object' ? data : {};
        let result = new BookSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.chapters)) {
            data["chapters"] = [];
            for (let item of this.chapters)
                data["chapters"].push(item.toJSON());
        }
        return data;
    }
}

export class Chapter {
    title?: string | undefined;
    body?: string | undefined;
    slides?: string[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.body = _data["body"];
            if (Array.isArray(_data["slides"])) {
                this.slides = [] as any;
                for (let item of _data["slides"])
                    this.slides!.push(item);
            }
        }
    }

    static fromJS(data: any): Chapter {
        data = typeof data === 'object' ? data : {};
        let result = new Chapter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["body"] = this.body;
        if (Array.isArray(this.slides)) {
            data["slides"] = [];
            for (let item of this.slides)
                data["slides"].push(item);
        }
        return data;
    }
}

export class ModuleContentSettingsOfBookSettings {
    settings!: BookSettings;
    files?: ModuleContentFileSettings[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.settings = _data["settings"] ? BookSettings.fromJS(_data["settings"]) : new BookSettings();
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(ModuleContentFileSettings.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ModuleContentSettingsOfBookSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleContentSettingsOfBookSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data;
    }
}

export class CreateModuleContentSettingsOfBookSettings extends ModuleContentSettingsOfBookSettings {
    published?: boolean;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.published = _data["published"];
        }
    }

    static fromJS(data: any): CreateModuleContentSettingsOfBookSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateModuleContentSettingsOfBookSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["published"] = this.published;
        super.toJSON(data);
        return data;
    }
}

export class ModuleContentFileSettings {
    name!: string;
    dataUri!: string;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.dataUri = _data["dataUri"];
        }
    }

    static fromJS(data: any): ModuleContentFileSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleContentFileSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["dataUri"] = this.dataUri;
        return data;
    }
}

export class UpdateModuleContentSettingsOfBookSettings extends ModuleContentSettingsOfBookSettings {
    version?: number;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateModuleContentSettingsOfBookSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateModuleContentSettingsOfBookSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        super.toJSON(data);
        return data;
    }
}

export class ListOfCertificate {
    totalItemCount!: number;
    items!: Certificate[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Certificate.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfCertificate {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfCertificate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class Certificate {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    logoUri?: string | undefined;
    publisherId?: string | undefined;
    publisherName?: string | undefined;
    publisherLogoUri?: string | undefined;
    validityPeriod?: string;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.logoUri = _data["logoUri"];
            this.publisherId = _data["publisherId"];
            this.publisherName = _data["publisherName"];
            this.publisherLogoUri = _data["publisherLogoUri"];
            this.validityPeriod = _data["validityPeriod"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): Certificate {
        data = typeof data === 'object' ? data : {};
        let result = new Certificate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["logoUri"] = this.logoUri;
        data["publisherId"] = this.publisherId;
        data["publisherName"] = this.publisherName;
        data["publisherLogoUri"] = this.publisherLogoUri;
        data["validityPeriod"] = this.validityPeriod;
        data["version"] = this.version;
        return data;
    }
}

export class CreateCertificateSettings {
    publisherId!: string;
    name!: string;
    description?: string | undefined;
    logoUri?: string | undefined;
    validityPeriod?: string;

    init(_data?: any) {
        if (_data) {
            this.publisherId = _data["publisherId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.logoUri = _data["logoUri"];
            this.validityPeriod = _data["validityPeriod"];
        }
    }

    static fromJS(data: any): CreateCertificateSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCertificateSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["publisherId"] = this.publisherId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["logoUri"] = this.logoUri;
        data["validityPeriod"] = this.validityPeriod;
        return data;
    }
}

export class UpdateCertificateSettings {
    name!: string;
    description?: string | undefined;
    logoUri?: string | undefined;
    validityPeriod?: string;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.logoUri = _data["logoUri"];
            this.validityPeriod = _data["validityPeriod"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateCertificateSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCertificateSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["logoUri"] = this.logoUri;
        data["validityPeriod"] = this.validityPeriod;
        data["version"] = this.version;
        return data;
    }
}

export class ListOfCertification {
    totalItemCount!: number;
    items!: Certification[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Certification.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfCertification {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfCertification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class Certification {
    id?: string | undefined;
    certificateId?: string | undefined;
    certificateName?: string | undefined;
    certificateLogoUri?: string | undefined;
    traineeId?: string | undefined;
    traineeName?: string | undefined;
    started?: Date;
    certified?: Date | undefined;
    expires?: Date | undefined;
    validityPeriod?: string;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.certificateId = _data["certificateId"];
            this.certificateName = _data["certificateName"];
            this.certificateLogoUri = _data["certificateLogoUri"];
            this.traineeId = _data["traineeId"];
            this.traineeName = _data["traineeName"];
            this.started = _data["started"] ? new Date(_data["started"].toString()) : <any>undefined;
            this.certified = _data["certified"] ? new Date(_data["certified"].toString()) : <any>undefined;
            this.expires = _data["expires"] ? new Date(_data["expires"].toString()) : <any>undefined;
            this.validityPeriod = _data["validityPeriod"];
        }
    }

    static fromJS(data: any): Certification {
        data = typeof data === 'object' ? data : {};
        let result = new Certification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["certificateId"] = this.certificateId;
        data["certificateName"] = this.certificateName;
        data["certificateLogoUri"] = this.certificateLogoUri;
        data["traineeId"] = this.traineeId;
        data["traineeName"] = this.traineeName;
        data["started"] = this.started ? this.started.toISOString() : <any>undefined;
        data["certified"] = this.certified ? this.certified.toISOString() : <any>undefined;
        data["expires"] = this.expires ? this.expires.toISOString() : <any>undefined;
        data["validityPeriod"] = this.validityPeriod;
        return data;
    }
}

export class ListOfCertificationFact {
    totalItemCount!: number;
    items!: CertificationFact[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CertificationFact.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfCertificationFact {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfCertificationFact();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class CertificationFact {
    id?: string | undefined;
    certificationId?: string | undefined;
    certificateId?: string | undefined;
    traineeId?: string | undefined;
    created?: Date;
    started?: Date | undefined;
    certified?: Date | undefined;
    validityPeriod?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.certificationId = _data["certificationId"];
            this.certificateId = _data["certificateId"];
            this.traineeId = _data["traineeId"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.started = _data["started"] ? new Date(_data["started"].toString()) : <any>undefined;
            this.certified = _data["certified"] ? new Date(_data["certified"].toString()) : <any>undefined;
            this.validityPeriod = _data["validityPeriod"];
        }
    }

    static fromJS(data: any): CertificationFact {
        data = typeof data === 'object' ? data : {};
        let result = new CertificationFact();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["certificationId"] = this.certificationId;
        data["certificateId"] = this.certificateId;
        data["traineeId"] = this.traineeId;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["started"] = this.started ? this.started.toISOString() : <any>undefined;
        data["certified"] = this.certified ? this.certified.toISOString() : <any>undefined;
        data["validityPeriod"] = this.validityPeriod;
        return data;
    }
}

/** 0 = None 1 = Left 2 = Requested 3 = Joined 4 = Banned */
export enum MemberStatus {
    None = 0,
    Left = 1,
    Requested = 2,
    Joined = 3,
    Banned = 4,
}

export class ListOfClass {
    totalItemCount!: number;
    items!: Class[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Class.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfClass {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfClass();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class Class {
    id?: string | undefined;
    description?: string | undefined;
    gracePeriod?: string;
    allowAssessmentRequests?: boolean;
    teamId?: string | undefined;
    teamName?: string | undefined;
    teamCourseActivationId?: string | undefined;
    teamCourseActivated?: boolean;
    organisationId?: string | undefined;
    organisationName?: string | undefined;
    organisationLogoUri?: string | undefined;
    organisationCourseActivationId?: string | undefined;
    organisationCourseActivated?: boolean;
    publisherId?: string | undefined;
    publisherName?: string | undefined;
    publisherLogoUri?: string | undefined;
    courseId?: string | undefined;
    courseName?: string | undefined;
    courseDescription?: string | undefined;
    courseBannerUri?: string | undefined;
    courseLogoUri?: string | undefined;
    programs?: ProgramInClass[] | undefined;
    courseRecommendedJobTypeIds?: string[] | undefined;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.gracePeriod = _data["gracePeriod"];
            this.allowAssessmentRequests = _data["allowAssessmentRequests"];
            this.teamId = _data["teamId"];
            this.teamName = _data["teamName"];
            this.teamCourseActivationId = _data["teamCourseActivationId"];
            this.teamCourseActivated = _data["teamCourseActivated"];
            this.organisationId = _data["organisationId"];
            this.organisationName = _data["organisationName"];
            this.organisationLogoUri = _data["organisationLogoUri"];
            this.organisationCourseActivationId = _data["organisationCourseActivationId"];
            this.organisationCourseActivated = _data["organisationCourseActivated"];
            this.publisherId = _data["publisherId"];
            this.publisherName = _data["publisherName"];
            this.publisherLogoUri = _data["publisherLogoUri"];
            this.courseId = _data["courseId"];
            this.courseName = _data["courseName"];
            this.courseDescription = _data["courseDescription"];
            this.courseBannerUri = _data["courseBannerUri"];
            this.courseLogoUri = _data["courseLogoUri"];
            if (Array.isArray(_data["programs"])) {
                this.programs = [] as any;
                for (let item of _data["programs"])
                    this.programs!.push(ProgramInClass.fromJS(item));
            }
            if (Array.isArray(_data["courseRecommendedJobTypeIds"])) {
                this.courseRecommendedJobTypeIds = [] as any;
                for (let item of _data["courseRecommendedJobTypeIds"])
                    this.courseRecommendedJobTypeIds!.push(item);
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): Class {
        data = typeof data === 'object' ? data : {};
        let result = new Class();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["gracePeriod"] = this.gracePeriod;
        data["allowAssessmentRequests"] = this.allowAssessmentRequests;
        data["teamId"] = this.teamId;
        data["teamName"] = this.teamName;
        data["teamCourseActivationId"] = this.teamCourseActivationId;
        data["teamCourseActivated"] = this.teamCourseActivated;
        data["organisationId"] = this.organisationId;
        data["organisationName"] = this.organisationName;
        data["organisationLogoUri"] = this.organisationLogoUri;
        data["organisationCourseActivationId"] = this.organisationCourseActivationId;
        data["organisationCourseActivated"] = this.organisationCourseActivated;
        data["publisherId"] = this.publisherId;
        data["publisherName"] = this.publisherName;
        data["publisherLogoUri"] = this.publisherLogoUri;
        data["courseId"] = this.courseId;
        data["courseName"] = this.courseName;
        data["courseDescription"] = this.courseDescription;
        data["courseBannerUri"] = this.courseBannerUri;
        data["courseLogoUri"] = this.courseLogoUri;
        if (Array.isArray(this.programs)) {
            data["programs"] = [];
            for (let item of this.programs)
                data["programs"].push(item.toJSON());
        }
        if (Array.isArray(this.courseRecommendedJobTypeIds)) {
            data["courseRecommendedJobTypeIds"] = [];
            for (let item of this.courseRecommendedJobTypeIds)
                data["courseRecommendedJobTypeIds"].push(item);
        }
        data["version"] = this.version;
        return data;
    }
}

export class ProgramInClass {
    id?: string | undefined;
    name?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ProgramInClass {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramInClass();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export class CreateClassSettings {
    teamId!: string;
    courseId!: string;
    description?: string | undefined;
    gracePeriod?: string;
    allowAssessmentRequests?: boolean;

    init(_data?: any) {
        if (_data) {
            this.teamId = _data["teamId"];
            this.courseId = _data["courseId"];
            this.description = _data["description"];
            this.gracePeriod = _data["gracePeriod"];
            this.allowAssessmentRequests = _data["allowAssessmentRequests"];
        }
    }

    static fromJS(data: any): CreateClassSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateClassSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["teamId"] = this.teamId;
        data["courseId"] = this.courseId;
        data["description"] = this.description;
        data["gracePeriod"] = this.gracePeriod;
        data["allowAssessmentRequests"] = this.allowAssessmentRequests;
        return data;
    }
}

export class UpdateClassSettings {
    description?: string | undefined;
    gracePeriod?: string;
    allowAssessmentRequests?: boolean;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.gracePeriod = _data["gracePeriod"];
            this.allowAssessmentRequests = _data["allowAssessmentRequests"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateClassSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateClassSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["gracePeriod"] = this.gracePeriod;
        data["allowAssessmentRequests"] = this.allowAssessmentRequests;
        data["version"] = this.version;
        return data;
    }
}

export class NotifyAssessorsSettings {
    enrolmentId!: string;
    assessmentId!: string;
    traineeId!: string;

    init(_data?: any) {
        if (_data) {
            this.enrolmentId = _data["enrolmentId"];
            this.assessmentId = _data["assessmentId"];
            this.traineeId = _data["traineeId"];
        }
    }

    static fromJS(data: any): NotifyAssessorsSettings {
        data = typeof data === 'object' ? data : {};
        let result = new NotifyAssessorsSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enrolmentId"] = this.enrolmentId;
        data["assessmentId"] = this.assessmentId;
        data["traineeId"] = this.traineeId;
        return data;
    }
}

export class ListOfCourse {
    totalItemCount!: number;
    items!: Course[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Course.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfCourse {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfCourse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class Course {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    bannerUri?: string | undefined;
    logoUri?: string | undefined;
    mediaUris?: string[] | undefined;
    publisherId?: string | undefined;
    publisherName?: string | undefined;
    publisherLogoUri?: string | undefined;
    programs?: ProgramInCourse[] | undefined;
    sections?: SectionInCourse[] | undefined;
    certificates?: CertificateInCourse[] | undefined;
    recommendedJobTypeIds?: string[] | undefined;
    processReports?: ProcessReportInCourse[] | undefined;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.bannerUri = _data["bannerUri"];
            this.logoUri = _data["logoUri"];
            if (Array.isArray(_data["mediaUris"])) {
                this.mediaUris = [] as any;
                for (let item of _data["mediaUris"])
                    this.mediaUris!.push(item);
            }
            this.publisherId = _data["publisherId"];
            this.publisherName = _data["publisherName"];
            this.publisherLogoUri = _data["publisherLogoUri"];
            if (Array.isArray(_data["programs"])) {
                this.programs = [] as any;
                for (let item of _data["programs"])
                    this.programs!.push(ProgramInCourse.fromJS(item));
            }
            if (Array.isArray(_data["sections"])) {
                this.sections = [] as any;
                for (let item of _data["sections"])
                    this.sections!.push(SectionInCourse.fromJS(item));
            }
            if (Array.isArray(_data["certificates"])) {
                this.certificates = [] as any;
                for (let item of _data["certificates"])
                    this.certificates!.push(CertificateInCourse.fromJS(item));
            }
            if (Array.isArray(_data["recommendedJobTypeIds"])) {
                this.recommendedJobTypeIds = [] as any;
                for (let item of _data["recommendedJobTypeIds"])
                    this.recommendedJobTypeIds!.push(item);
            }
            if (Array.isArray(_data["processReports"])) {
                this.processReports = [] as any;
                for (let item of _data["processReports"])
                    this.processReports!.push(ProcessReportInCourse.fromJS(item));
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): Course {
        data = typeof data === 'object' ? data : {};
        let result = new Course();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["bannerUri"] = this.bannerUri;
        data["logoUri"] = this.logoUri;
        if (Array.isArray(this.mediaUris)) {
            data["mediaUris"] = [];
            for (let item of this.mediaUris)
                data["mediaUris"].push(item);
        }
        data["publisherId"] = this.publisherId;
        data["publisherName"] = this.publisherName;
        data["publisherLogoUri"] = this.publisherLogoUri;
        if (Array.isArray(this.programs)) {
            data["programs"] = [];
            for (let item of this.programs)
                data["programs"].push(item.toJSON());
        }
        if (Array.isArray(this.sections)) {
            data["sections"] = [];
            for (let item of this.sections)
                data["sections"].push(item.toJSON());
        }
        if (Array.isArray(this.certificates)) {
            data["certificates"] = [];
            for (let item of this.certificates)
                data["certificates"].push(item.toJSON());
        }
        if (Array.isArray(this.recommendedJobTypeIds)) {
            data["recommendedJobTypeIds"] = [];
            for (let item of this.recommendedJobTypeIds)
                data["recommendedJobTypeIds"].push(item);
        }
        if (Array.isArray(this.processReports)) {
            data["processReports"] = [];
            for (let item of this.processReports)
                data["processReports"].push(item.toJSON());
        }
        data["version"] = this.version;
        return data;
    }
}

export class ProgramInCourse {
    id?: string | undefined;
    name?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ProgramInCourse {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramInCourse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export class SectionInCourse {
    name?: string | undefined;
    required?: boolean;
    items?: ItemInCourse[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.required = _data["required"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ItemInCourse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SectionInCourse {
        data = typeof data === 'object' ? data : {};
        let result = new SectionInCourse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["required"] = this.required;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class ItemInCourse {
    category?: CourseItemCategory;
    id?: string | undefined;
    type?: string | undefined;
    name?: string | undefined;
    imageUri?: string | undefined;
    open?: boolean;

    init(_data?: any) {
        if (_data) {
            this.category = _data["category"];
            this.id = _data["id"];
            this.type = _data["type"];
            this.name = _data["name"];
            this.imageUri = _data["imageUri"];
            this.open = _data["open"];
        }
    }

    static fromJS(data: any): ItemInCourse {
        data = typeof data === 'object' ? data : {};
        let result = new ItemInCourse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        data["id"] = this.id;
        data["type"] = this.type;
        data["name"] = this.name;
        data["imageUri"] = this.imageUri;
        data["open"] = this.open;
        return data;
    }
}

export enum CourseItemCategory {
    Module = "Module",
    Survey = "Survey",
}

export class CertificateInCourse {
    id?: string | undefined;
    name?: string | undefined;
    logoUri?: string | undefined;
    validityPeriod?: string;
    items?: CertificateItemInCourse[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.logoUri = _data["logoUri"];
            this.validityPeriod = _data["validityPeriod"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CertificateItemInCourse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CertificateInCourse {
        data = typeof data === 'object' ? data : {};
        let result = new CertificateInCourse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["logoUri"] = this.logoUri;
        data["validityPeriod"] = this.validityPeriod;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class CertificateItemInCourse {
    category?: CourseItemCategory;
    id?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.category = _data["category"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CertificateItemInCourse {
        data = typeof data === 'object' ? data : {};
        let result = new CertificateItemInCourse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        data["id"] = this.id;
        return data;
    }
}

export class ProcessReportInCourse {
    id?: string | undefined;
    name?: string | undefined;
    type?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ProcessReportInCourse {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessReportInCourse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["type"] = this.type;
        return data;
    }
}

export class CreateCourseSettings {
    publisherId!: string;
    name!: string;
    /** A base64 encoded image or a URL of existing image
             */
    bannerUri?: string | undefined;
    /** A base64 encoded image or a URL of existing image
             */
    logoUri?: string | undefined;
    /** A list of promotional medias. Elements can be: 
    - base64 encoded image
    - uri of image
    - url of video (i.e. video has to be hosted elsewhere, at least for now) */
    mediaUris?: string[] | undefined;
    description?: string | undefined;
    sections?: CourseSection[] | undefined;
    recommendedJobTypeIds?: string[] | undefined;
    processReportIds?: string[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.publisherId = _data["publisherId"];
            this.name = _data["name"];
            this.bannerUri = _data["bannerUri"];
            this.logoUri = _data["logoUri"];
            if (Array.isArray(_data["mediaUris"])) {
                this.mediaUris = [] as any;
                for (let item of _data["mediaUris"])
                    this.mediaUris!.push(item);
            }
            this.description = _data["description"];
            if (Array.isArray(_data["sections"])) {
                this.sections = [] as any;
                for (let item of _data["sections"])
                    this.sections!.push(CourseSection.fromJS(item));
            }
            if (Array.isArray(_data["recommendedJobTypeIds"])) {
                this.recommendedJobTypeIds = [] as any;
                for (let item of _data["recommendedJobTypeIds"])
                    this.recommendedJobTypeIds!.push(item);
            }
            if (Array.isArray(_data["processReportIds"])) {
                this.processReportIds = [] as any;
                for (let item of _data["processReportIds"])
                    this.processReportIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateCourseSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCourseSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["publisherId"] = this.publisherId;
        data["name"] = this.name;
        data["bannerUri"] = this.bannerUri;
        data["logoUri"] = this.logoUri;
        if (Array.isArray(this.mediaUris)) {
            data["mediaUris"] = [];
            for (let item of this.mediaUris)
                data["mediaUris"].push(item);
        }
        data["description"] = this.description;
        if (Array.isArray(this.sections)) {
            data["sections"] = [];
            for (let item of this.sections)
                data["sections"].push(item.toJSON());
        }
        if (Array.isArray(this.recommendedJobTypeIds)) {
            data["recommendedJobTypeIds"] = [];
            for (let item of this.recommendedJobTypeIds)
                data["recommendedJobTypeIds"].push(item);
        }
        if (Array.isArray(this.processReportIds)) {
            data["processReportIds"] = [];
            for (let item of this.processReportIds)
                data["processReportIds"].push(item);
        }
        return data;
    }
}

export class CourseSection {
    name?: string | undefined;
    required?: boolean;
    items?: CourseItem[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.required = _data["required"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CourseItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CourseSection {
        data = typeof data === 'object' ? data : {};
        let result = new CourseSection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["required"] = this.required;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class CourseItem {
    category?: CourseItemCategory;
    id?: string | undefined;
    open?: boolean;
    certificateIds?: string[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.category = _data["category"];
            this.id = _data["id"];
            this.open = _data["open"];
            if (Array.isArray(_data["certificateIds"])) {
                this.certificateIds = [] as any;
                for (let item of _data["certificateIds"])
                    this.certificateIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CourseItem {
        data = typeof data === 'object' ? data : {};
        let result = new CourseItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        data["id"] = this.id;
        data["open"] = this.open;
        if (Array.isArray(this.certificateIds)) {
            data["certificateIds"] = [];
            for (let item of this.certificateIds)
                data["certificateIds"].push(item);
        }
        return data;
    }
}

export class UpdateCourseSettings {
    name!: string;
    bannerUri?: string | undefined;
    logoUri?: string | undefined;
    mediaUris?: string[] | undefined;
    description?: string | undefined;
    open?: boolean;
    sections?: CourseSection[] | undefined;
    recommendedJobTypeIds?: string[] | undefined;
    processReportIds?: string[] | undefined;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.bannerUri = _data["bannerUri"];
            this.logoUri = _data["logoUri"];
            if (Array.isArray(_data["mediaUris"])) {
                this.mediaUris = [] as any;
                for (let item of _data["mediaUris"])
                    this.mediaUris!.push(item);
            }
            this.description = _data["description"];
            this.open = _data["open"];
            if (Array.isArray(_data["sections"])) {
                this.sections = [] as any;
                for (let item of _data["sections"])
                    this.sections!.push(CourseSection.fromJS(item));
            }
            if (Array.isArray(_data["recommendedJobTypeIds"])) {
                this.recommendedJobTypeIds = [] as any;
                for (let item of _data["recommendedJobTypeIds"])
                    this.recommendedJobTypeIds!.push(item);
            }
            if (Array.isArray(_data["processReportIds"])) {
                this.processReportIds = [] as any;
                for (let item of _data["processReportIds"])
                    this.processReportIds!.push(item);
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateCourseSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCourseSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["bannerUri"] = this.bannerUri;
        data["logoUri"] = this.logoUri;
        if (Array.isArray(this.mediaUris)) {
            data["mediaUris"] = [];
            for (let item of this.mediaUris)
                data["mediaUris"].push(item);
        }
        data["description"] = this.description;
        data["open"] = this.open;
        if (Array.isArray(this.sections)) {
            data["sections"] = [];
            for (let item of this.sections)
                data["sections"].push(item.toJSON());
        }
        if (Array.isArray(this.recommendedJobTypeIds)) {
            data["recommendedJobTypeIds"] = [];
            for (let item of this.recommendedJobTypeIds)
                data["recommendedJobTypeIds"].push(item);
        }
        if (Array.isArray(this.processReportIds)) {
            data["processReportIds"] = [];
            for (let item of this.processReportIds)
                data["processReportIds"].push(item);
        }
        data["version"] = this.version;
        return data;
    }
}

export class ListOfEnrolment {
    totalItemCount!: number;
    items!: Enrolment[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Enrolment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfEnrolment {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfEnrolment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class Enrolment2 {
    id?: string | undefined;
    traineeId?: string | undefined;
    traineeName?: string | undefined;
    traineeImageUri?: string | undefined;
    traineeJobTypeId?: string | undefined;
    traineeJobTypeName?: string | undefined;
    traineeCourseActivationId?: string | undefined;
    traineeCourseActivated?: boolean;
    publisherId?: string | undefined;
    publisherName?: string | undefined;
    publisherLogoUri?: string | undefined;
    programs?: ProgramInEnrolment[] | undefined;
    courseId?: string | undefined;
    courseName?: string | undefined;
    courseBannerUri?: string | undefined;
    courseLogoUri?: string | undefined;
    classes?: ClassInEnrolment[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.traineeId = _data["traineeId"];
            this.traineeName = _data["traineeName"];
            this.traineeImageUri = _data["traineeImageUri"];
            this.traineeJobTypeId = _data["traineeJobTypeId"];
            this.traineeJobTypeName = _data["traineeJobTypeName"];
            this.traineeCourseActivationId = _data["traineeCourseActivationId"];
            this.traineeCourseActivated = _data["traineeCourseActivated"];
            this.publisherId = _data["publisherId"];
            this.publisherName = _data["publisherName"];
            this.publisherLogoUri = _data["publisherLogoUri"];
            if (Array.isArray(_data["programs"])) {
                this.programs = [] as any;
                for (let item of _data["programs"])
                    this.programs!.push(ProgramInEnrolment.fromJS(item));
            }
            this.courseId = _data["courseId"];
            this.courseName = _data["courseName"];
            this.courseBannerUri = _data["courseBannerUri"];
            this.courseLogoUri = _data["courseLogoUri"];
            if (Array.isArray(_data["classes"])) {
                this.classes = [] as any;
                for (let item of _data["classes"])
                    this.classes!.push(ClassInEnrolment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Enrolment2 {
        data = typeof data === 'object' ? data : {};
        let result = new Enrolment2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["traineeId"] = this.traineeId;
        data["traineeName"] = this.traineeName;
        data["traineeImageUri"] = this.traineeImageUri;
        data["traineeJobTypeId"] = this.traineeJobTypeId;
        data["traineeJobTypeName"] = this.traineeJobTypeName;
        data["traineeCourseActivationId"] = this.traineeCourseActivationId;
        data["traineeCourseActivated"] = this.traineeCourseActivated;
        data["publisherId"] = this.publisherId;
        data["publisherName"] = this.publisherName;
        data["publisherLogoUri"] = this.publisherLogoUri;
        if (Array.isArray(this.programs)) {
            data["programs"] = [];
            for (let item of this.programs)
                data["programs"].push(item.toJSON());
        }
        data["courseId"] = this.courseId;
        data["courseName"] = this.courseName;
        data["courseBannerUri"] = this.courseBannerUri;
        data["courseLogoUri"] = this.courseLogoUri;
        if (Array.isArray(this.classes)) {
            data["classes"] = [];
            for (let item of this.classes)
                data["classes"].push(item.toJSON());
        }
        return data;
    }
}

export class Enrolment extends Enrolment2 {
    courseSections?: CourseSectionInEnrolment[] | undefined;
    certifications?: CertificationInEnrolment[] | undefined;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["courseSections"])) {
                this.courseSections = [] as any;
                for (let item of _data["courseSections"])
                    this.courseSections!.push(CourseSectionInEnrolment.fromJS(item));
            }
            if (Array.isArray(_data["certifications"])) {
                this.certifications = [] as any;
                for (let item of _data["certifications"])
                    this.certifications!.push(CertificationInEnrolment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Enrolment {
        data = typeof data === 'object' ? data : {};
        let result = new Enrolment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.courseSections)) {
            data["courseSections"] = [];
            for (let item of this.courseSections)
                data["courseSections"].push(item.toJSON());
        }
        if (Array.isArray(this.certifications)) {
            data["certifications"] = [];
            for (let item of this.certifications)
                data["certifications"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export class CourseSectionInEnrolment {
    name?: string | undefined;
    required?: boolean;
    items?: any[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.required = _data["required"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(item);
            }
        }
    }

    static fromJS(data: any): CourseSectionInEnrolment {
        data = typeof data === 'object' ? data : {};
        let result = new CourseSectionInEnrolment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["required"] = this.required;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item);
        }
        return data;
    }
}

export class CertificationInEnrolment {
    id?: string | undefined;
    certificateId?: string | undefined;
    certificateName?: string | undefined;
    certificateLogoUri?: string | undefined;
    certificateModuleIds?: string[] | undefined;
    certificateSurveyIds?: string[] | undefined;
    started?: Date | undefined;
    certified?: Date | undefined;
    expires?: Date | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.certificateId = _data["certificateId"];
            this.certificateName = _data["certificateName"];
            this.certificateLogoUri = _data["certificateLogoUri"];
            if (Array.isArray(_data["certificateModuleIds"])) {
                this.certificateModuleIds = [] as any;
                for (let item of _data["certificateModuleIds"])
                    this.certificateModuleIds!.push(item);
            }
            if (Array.isArray(_data["certificateSurveyIds"])) {
                this.certificateSurveyIds = [] as any;
                for (let item of _data["certificateSurveyIds"])
                    this.certificateSurveyIds!.push(item);
            }
            this.started = _data["started"] ? new Date(_data["started"].toString()) : <any>undefined;
            this.certified = _data["certified"] ? new Date(_data["certified"].toString()) : <any>undefined;
            this.expires = _data["expires"] ? new Date(_data["expires"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CertificationInEnrolment {
        data = typeof data === 'object' ? data : {};
        let result = new CertificationInEnrolment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["certificateId"] = this.certificateId;
        data["certificateName"] = this.certificateName;
        data["certificateLogoUri"] = this.certificateLogoUri;
        if (Array.isArray(this.certificateModuleIds)) {
            data["certificateModuleIds"] = [];
            for (let item of this.certificateModuleIds)
                data["certificateModuleIds"].push(item);
        }
        if (Array.isArray(this.certificateSurveyIds)) {
            data["certificateSurveyIds"] = [];
            for (let item of this.certificateSurveyIds)
                data["certificateSurveyIds"].push(item);
        }
        data["started"] = this.started ? this.started.toISOString() : <any>undefined;
        data["certified"] = this.certified ? this.certified.toISOString() : <any>undefined;
        data["expires"] = this.expires ? this.expires.toISOString() : <any>undefined;
        return data;
    }
}

export class ProgramInEnrolment {
    id?: string | undefined;
    name?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ProgramInEnrolment {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramInEnrolment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export class ClassInEnrolment {
    id?: string | undefined;
    teamId?: string | undefined;
    teamName?: string | undefined;
    teamCourseActivationId?: string | undefined;
    teamCourseActivated?: boolean;
    organisationId?: string | undefined;
    organisationName?: string | undefined;
    organisationCourseActivationId?: string | undefined;
    organisationCourseActivated?: boolean;
    joined?: Date;
    gracePeriod?: string;
    description?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.teamId = _data["teamId"];
            this.teamName = _data["teamName"];
            this.teamCourseActivationId = _data["teamCourseActivationId"];
            this.teamCourseActivated = _data["teamCourseActivated"];
            this.organisationId = _data["organisationId"];
            this.organisationName = _data["organisationName"];
            this.organisationCourseActivationId = _data["organisationCourseActivationId"];
            this.organisationCourseActivated = _data["organisationCourseActivated"];
            this.joined = _data["joined"] ? new Date(_data["joined"].toString()) : <any>undefined;
            this.gracePeriod = _data["gracePeriod"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ClassInEnrolment {
        data = typeof data === 'object' ? data : {};
        let result = new ClassInEnrolment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["teamId"] = this.teamId;
        data["teamName"] = this.teamName;
        data["teamCourseActivationId"] = this.teamCourseActivationId;
        data["teamCourseActivated"] = this.teamCourseActivated;
        data["organisationId"] = this.organisationId;
        data["organisationName"] = this.organisationName;
        data["organisationCourseActivationId"] = this.organisationCourseActivationId;
        data["organisationCourseActivated"] = this.organisationCourseActivated;
        data["joined"] = this.joined ? this.joined.toISOString() : <any>undefined;
        data["gracePeriod"] = this.gracePeriod;
        data["description"] = this.description;
        return data;
    }
}

export class ListOfModuleAttempt {
    totalItemCount!: number;
    items!: ModuleAttempt[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ModuleAttempt.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfModuleAttempt {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfModuleAttempt();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class ListOfModule {
    totalItemCount!: number;
    items!: Module[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Module.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfModule {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfModule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class Module {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    imageUri?: string | undefined;
    publisherId?: string | undefined;
    publisherName?: string | undefined;
    publisherLogoUri?: string | undefined;
    type?: string | undefined;
    published?: boolean;
    publishedContentId?: string | undefined;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.imageUri = _data["imageUri"];
            this.publisherId = _data["publisherId"];
            this.publisherName = _data["publisherName"];
            this.publisherLogoUri = _data["publisherLogoUri"];
            this.type = _data["type"];
            this.published = _data["published"];
            this.publishedContentId = _data["publishedContentId"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): Module {
        data = typeof data === 'object' ? data : {};
        let result = new Module();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["imageUri"] = this.imageUri;
        data["publisherId"] = this.publisherId;
        data["publisherName"] = this.publisherName;
        data["publisherLogoUri"] = this.publisherLogoUri;
        data["type"] = this.type;
        data["published"] = this.published;
        data["publishedContentId"] = this.publishedContentId;
        data["version"] = this.version;
        return data;
    }
}

export class CreateModuleSettings {
    publisherId!: string;
    type!: string;
    name!: string;
    description?: string | undefined;
    imageUri?: string | undefined;
    files?: CreateFileSettings[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.publisherId = _data["publisherId"];
            this.type = _data["type"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.imageUri = _data["imageUri"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(CreateFileSettings.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateModuleSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateModuleSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["publisherId"] = this.publisherId;
        data["type"] = this.type;
        data["name"] = this.name;
        data["description"] = this.description;
        data["imageUri"] = this.imageUri;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data;
    }
}

export class UpdateModuleSettings {
    name!: string;
    description?: string | undefined;
    imageUri?: string | undefined;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.imageUri = _data["imageUri"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateModuleSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateModuleSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["imageUri"] = this.imageUri;
        data["version"] = this.version;
        return data;
    }
}

export class ListOfModuleNps {
    totalItemCount!: number;
    items!: ModuleNps[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ModuleNps.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfModuleNps {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfModuleNps();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class ModuleNps {
    id?: string | undefined;
    score?: number;
    comments?: string | undefined;
    dismissed?: boolean;
    created?: Date;
    creatorId?: string | undefined;
    creatorName?: string | undefined;
    creatorImageUri?: string | undefined;
    creatorJobTypeId?: string | undefined;
    creatorJobTypeName?: string | undefined;
    moduleId?: string | undefined;
    moduleName?: string | undefined;
    moduleType?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.score = _data["score"];
            this.comments = _data["comments"];
            this.dismissed = _data["dismissed"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.creatorId = _data["creatorId"];
            this.creatorName = _data["creatorName"];
            this.creatorImageUri = _data["creatorImageUri"];
            this.creatorJobTypeId = _data["creatorJobTypeId"];
            this.creatorJobTypeName = _data["creatorJobTypeName"];
            this.moduleId = _data["moduleId"];
            this.moduleName = _data["moduleName"];
            this.moduleType = _data["moduleType"];
        }
    }

    static fromJS(data: any): ModuleNps {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleNps();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["score"] = this.score;
        data["comments"] = this.comments;
        data["dismissed"] = this.dismissed;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["creatorId"] = this.creatorId;
        data["creatorName"] = this.creatorName;
        data["creatorImageUri"] = this.creatorImageUri;
        data["creatorJobTypeId"] = this.creatorJobTypeId;
        data["creatorJobTypeName"] = this.creatorJobTypeName;
        data["moduleId"] = this.moduleId;
        data["moduleName"] = this.moduleName;
        data["moduleType"] = this.moduleType;
        return data;
    }
}

export class Nps {
    id?: string | undefined;
    itemId?: string | undefined;
    score?: number;
    comments?: string | undefined;
    dismissed?: boolean;
    created?: Date;
    creatorId?: string | undefined;
    creatorName?: string | undefined;
    creatorImageUri?: string | undefined;
    creatorJobTypeId?: string | undefined;
    creatorJobTypeName?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.itemId = _data["itemId"];
            this.score = _data["score"];
            this.comments = _data["comments"];
            this.dismissed = _data["dismissed"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.creatorId = _data["creatorId"];
            this.creatorName = _data["creatorName"];
            this.creatorImageUri = _data["creatorImageUri"];
            this.creatorJobTypeId = _data["creatorJobTypeId"];
            this.creatorJobTypeName = _data["creatorJobTypeName"];
        }
    }

    static fromJS(data: any): Nps {
        data = typeof data === 'object' ? data : {};
        let result = new Nps();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["itemId"] = this.itemId;
        data["score"] = this.score;
        data["comments"] = this.comments;
        data["dismissed"] = this.dismissed;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["creatorId"] = this.creatorId;
        data["creatorName"] = this.creatorName;
        data["creatorImageUri"] = this.creatorImageUri;
        data["creatorJobTypeId"] = this.creatorJobTypeId;
        data["creatorJobTypeName"] = this.creatorJobTypeName;
        return data;
    }
}

export class CreateNpsSettings {
    moduleId!: string;
    comments?: string | undefined;
    score?: number;
    dismissed?: boolean;

    init(_data?: any) {
        if (_data) {
            this.moduleId = _data["moduleId"];
            this.comments = _data["comments"];
            this.score = _data["score"];
            this.dismissed = _data["dismissed"];
        }
    }

    static fromJS(data: any): CreateNpsSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateNpsSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["moduleId"] = this.moduleId;
        data["comments"] = this.comments;
        data["score"] = this.score;
        data["dismissed"] = this.dismissed;
        return data;
    }
}

export class ListOfModuleAttemptOfQuizResult {
    totalItemCount!: number;
    items!: ModuleAttemptOfQuizResult[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ModuleAttemptOfQuizResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfModuleAttemptOfQuizResult {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfModuleAttemptOfQuizResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class ModuleAttemptOfQuizResult extends ModuleAttempt {
    result?: QuizResult | undefined;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.result = _data["result"] ? QuizResult.fromJS(_data["result"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ModuleAttemptOfQuizResult {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleAttemptOfQuizResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export class QuizResult {
    sections?: QuizSectionResult[] | undefined;
    submitted?: boolean;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["sections"])) {
                this.sections = [] as any;
                for (let item of _data["sections"])
                    this.sections!.push(QuizSectionResult.fromJS(item));
            }
            this.submitted = _data["submitted"];
        }
    }

    static fromJS(data: any): QuizResult {
        data = typeof data === 'object' ? data : {};
        let result = new QuizResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.sections)) {
            data["sections"] = [];
            for (let item of this.sections)
                data["sections"].push(item.toJSON());
        }
        data["submitted"] = this.submitted;
        return data;
    }
}

export class QuizSectionResult {
    index?: number;
    questions?: QuizQuestionResult[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.index = _data["index"];
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(QuizQuestionResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuizSectionResult {
        data = typeof data === 'object' ? data : {};
        let result = new QuizSectionResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["index"] = this.index;
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        return data;
    }
}

export class QuizQuestionResult {
    index?: number;
    answers?: number[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.index = _data["index"];
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(item);
            }
        }
    }

    static fromJS(data: any): QuizQuestionResult {
        data = typeof data === 'object' ? data : {};
        let result = new QuizQuestionResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["index"] = this.index;
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item);
        }
        return data;
    }
}

export class CreateModuleAttemptSettingsOfQuizResult {
    /** Id of the actor of ActorType being assessed */
    actorId!: string;
    moduleContentId!: string;
    result!: QuizResult;

    init(_data?: any) {
        if (_data) {
            this.actorId = _data["actorId"];
            this.moduleContentId = _data["moduleContentId"];
            this.result = _data["result"] ? QuizResult.fromJS(_data["result"]) : new QuizResult();
        }
    }

    static fromJS(data: any): CreateModuleAttemptSettingsOfQuizResult {
        data = typeof data === 'object' ? data : {};
        let result = new CreateModuleAttemptSettingsOfQuizResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actorId"] = this.actorId;
        data["moduleContentId"] = this.moduleContentId;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export class UpdateModuleAttemptSettingsOfQuizResult {
    result!: QuizResult;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? QuizResult.fromJS(_data["result"]) : new QuizResult();
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateModuleAttemptSettingsOfQuizResult {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateModuleAttemptSettingsOfQuizResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["version"] = this.version;
        return data;
    }
}

export class ListOfModuleContentOfQuizSettings {
    totalItemCount!: number;
    items!: ModuleContentOfQuizSettings[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ModuleContentOfQuizSettings.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfModuleContentOfQuizSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfModuleContentOfQuizSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class ModuleContentOfQuizSettings extends ModuleContent {
    settings?: QuizSettings | undefined;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.settings = _data["settings"] ? QuizSettings.fromJS(_data["settings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ModuleContentOfQuizSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleContentOfQuizSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export class QuizSettings {
    sections!: QuizSection[];
    /** The percentage required to pass the module. */
    passScore!: number;
    /** If true, will cause the quiz to keep looping until participant passes all questions. */
    loop?: boolean;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["sections"])) {
                this.sections = [] as any;
                for (let item of _data["sections"])
                    this.sections!.push(QuizSection.fromJS(item));
            }
            this.passScore = _data["passScore"];
            this.loop = _data["loop"];
        }
    }

    static fromJS(data: any): QuizSettings {
        data = typeof data === 'object' ? data : {};
        let result = new QuizSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.sections)) {
            data["sections"] = [];
            for (let item of this.sections)
                data["sections"].push(item.toJSON());
        }
        data["passScore"] = this.passScore;
        data["loop"] = this.loop;
        return data;
    }
}

export class QuizSection {
    title?: string | undefined;
    questions?: QuizQuestion[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(QuizQuestion.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuizSection {
        data = typeof data === 'object' ? data : {};
        let result = new QuizSection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        return data;
    }
}

export class QuizQuestion {
    label?: string | undefined;
    body?: string | undefined;
    answers?: QuizAnswer[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            this.body = _data["body"];
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(QuizAnswer.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuizQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new QuizQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["body"] = this.body;
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        return data;
    }
}

export class QuizAnswer {
    label?: string | undefined;
    body?: string | undefined;
    correct?: boolean;

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            this.body = _data["body"];
            this.correct = _data["correct"];
        }
    }

    static fromJS(data: any): QuizAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new QuizAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["body"] = this.body;
        data["correct"] = this.correct;
        return data;
    }
}

export class ModuleContentSettingsOfQuizSettings {
    settings!: QuizSettings;
    files?: ModuleContentFileSettings[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.settings = _data["settings"] ? QuizSettings.fromJS(_data["settings"]) : new QuizSettings();
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(ModuleContentFileSettings.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ModuleContentSettingsOfQuizSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleContentSettingsOfQuizSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data;
    }
}

export class CreateModuleContentSettingsOfQuizSettings extends ModuleContentSettingsOfQuizSettings {
    published?: boolean;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.published = _data["published"];
        }
    }

    static fromJS(data: any): CreateModuleContentSettingsOfQuizSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateModuleContentSettingsOfQuizSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["published"] = this.published;
        super.toJSON(data);
        return data;
    }
}

export class UpdateModuleContentSettingsOfQuizSettings extends ModuleContentSettingsOfQuizSettings {
    version?: number;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateModuleContentSettingsOfQuizSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateModuleContentSettingsOfQuizSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        super.toJSON(data);
        return data;
    }
}

export class ListOfModuleAttemptOfRevisionResult {
    totalItemCount!: number;
    items!: ModuleAttemptOfRevisionResult[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ModuleAttemptOfRevisionResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfModuleAttemptOfRevisionResult {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfModuleAttemptOfRevisionResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class ModuleAttemptOfRevisionResult extends ModuleAttempt {
    result?: RevisionResult | undefined;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.result = _data["result"] ? RevisionResult.fromJS(_data["result"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ModuleAttemptOfRevisionResult {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleAttemptOfRevisionResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export class RevisionResult {
    topics?: RevisionTopicResult[] | undefined;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["topics"])) {
                this.topics = [] as any;
                for (let item of _data["topics"])
                    this.topics!.push(RevisionTopicResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RevisionResult {
        data = typeof data === 'object' ? data : {};
        let result = new RevisionResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.topics)) {
            data["topics"] = [];
            for (let item of this.topics)
                data["topics"].push(item.toJSON());
        }
        return data;
    }
}

export class RevisionTopicResult {
    index?: number;
    attempts?: TopicAttempt[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.index = _data["index"];
            if (Array.isArray(_data["attempts"])) {
                this.attempts = [] as any;
                for (let item of _data["attempts"])
                    this.attempts!.push(TopicAttempt.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RevisionTopicResult {
        data = typeof data === 'object' ? data : {};
        let result = new RevisionTopicResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["index"] = this.index;
        if (Array.isArray(this.attempts)) {
            data["attempts"] = [];
            for (let item of this.attempts)
                data["attempts"].push(item.toJSON());
        }
        return data;
    }
}

export class TopicAttempt {
    form?: TopicForm;
    correct?: boolean;

    init(_data?: any) {
        if (_data) {
            this.form = _data["form"];
            this.correct = _data["correct"];
        }
    }

    static fromJS(data: any): TopicAttempt {
        data = typeof data === 'object' ? data : {};
        let result = new TopicAttempt();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["form"] = this.form;
        data["correct"] = this.correct;
        return data;
    }
}

/** 0 = Flipcard 1 = TrueOrFalse 2 = MultipleChoices */
export enum TopicForm {
    Flipcard = 0,
    TrueOrFalse = 1,
    MultipleChoices = 2,
}

export class CreateModuleAttemptSettingsOfRevisionResult {
    /** Id of the actor of ActorType being assessed */
    actorId!: string;
    moduleContentId!: string;
    result!: RevisionResult;

    init(_data?: any) {
        if (_data) {
            this.actorId = _data["actorId"];
            this.moduleContentId = _data["moduleContentId"];
            this.result = _data["result"] ? RevisionResult.fromJS(_data["result"]) : new RevisionResult();
        }
    }

    static fromJS(data: any): CreateModuleAttemptSettingsOfRevisionResult {
        data = typeof data === 'object' ? data : {};
        let result = new CreateModuleAttemptSettingsOfRevisionResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actorId"] = this.actorId;
        data["moduleContentId"] = this.moduleContentId;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export class UpdateModuleAttemptSettingsOfRevisionResult {
    result!: RevisionResult;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? RevisionResult.fromJS(_data["result"]) : new RevisionResult();
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateModuleAttemptSettingsOfRevisionResult {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateModuleAttemptSettingsOfRevisionResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["version"] = this.version;
        return data;
    }
}

export class ListOfModuleContentOfRevisionSettings {
    totalItemCount!: number;
    items!: ModuleContentOfRevisionSettings[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ModuleContentOfRevisionSettings.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfModuleContentOfRevisionSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfModuleContentOfRevisionSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class ModuleContentOfRevisionSettings extends ModuleContent {
    settings?: RevisionSettings | undefined;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.settings = _data["settings"] ? RevisionSettings.fromJS(_data["settings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ModuleContentOfRevisionSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleContentOfRevisionSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export class RevisionSettings {
    topics!: Topic[];
    /** The percentage required to pass the module. */
    passScore!: number;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["topics"])) {
                this.topics = [] as any;
                for (let item of _data["topics"])
                    this.topics!.push(Topic.fromJS(item));
            }
            this.passScore = _data["passScore"];
        }
    }

    static fromJS(data: any): RevisionSettings {
        data = typeof data === 'object' ? data : {};
        let result = new RevisionSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.topics)) {
            data["topics"] = [];
            for (let item of this.topics)
                data["topics"].push(item.toJSON());
        }
        data["passScore"] = this.passScore;
        return data;
    }
}

export class Topic {
    term!: string;
    definition!: string;
    hint?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.term = _data["term"];
            this.definition = _data["definition"];
            this.hint = _data["hint"];
        }
    }

    static fromJS(data: any): Topic {
        data = typeof data === 'object' ? data : {};
        let result = new Topic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["term"] = this.term;
        data["definition"] = this.definition;
        data["hint"] = this.hint;
        return data;
    }
}

export class ModuleContentSettingsOfRevisionSettings {
    settings!: RevisionSettings;
    files?: ModuleContentFileSettings[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.settings = _data["settings"] ? RevisionSettings.fromJS(_data["settings"]) : new RevisionSettings();
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(ModuleContentFileSettings.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ModuleContentSettingsOfRevisionSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleContentSettingsOfRevisionSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data;
    }
}

export class CreateModuleContentSettingsOfRevisionSettings extends ModuleContentSettingsOfRevisionSettings {
    published?: boolean;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.published = _data["published"];
        }
    }

    static fromJS(data: any): CreateModuleContentSettingsOfRevisionSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateModuleContentSettingsOfRevisionSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["published"] = this.published;
        super.toJSON(data);
        return data;
    }
}

export class UpdateModuleContentSettingsOfRevisionSettings extends ModuleContentSettingsOfRevisionSettings {
    version?: number;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateModuleContentSettingsOfRevisionSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateModuleContentSettingsOfRevisionSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        super.toJSON(data);
        return data;
    }
}

export class ListOfTrainingSession {
    totalItemCount!: number;
    items!: TrainingSession[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TrainingSession.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfTrainingSession {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfTrainingSession();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class TrainingSession {
    id?: string | undefined;
    groupId?: string | undefined;
    groupName?: string | undefined;
    organisationId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    location?: Location;
    modules?: ModuleInTrainingSession[] | undefined;
    start?: Date | undefined;
    end?: Date | undefined;
    status?: TrainingSessionStatus;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.groupId = _data["groupId"];
            this.groupName = _data["groupName"];
            this.organisationId = _data["organisationId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.location = _data["location"] ? Location.fromJS(_data["location"]) : <any>undefined;
            if (Array.isArray(_data["modules"])) {
                this.modules = [] as any;
                for (let item of _data["modules"])
                    this.modules!.push(ModuleInTrainingSession.fromJS(item));
            }
            this.start = _data["start"] ? new Date(_data["start"].toString()) : <any>undefined;
            this.end = _data["end"] ? new Date(_data["end"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): TrainingSession {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingSession();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["groupId"] = this.groupId;
        data["groupName"] = this.groupName;
        data["organisationId"] = this.organisationId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        if (Array.isArray(this.modules)) {
            data["modules"] = [];
            for (let item of this.modules)
                data["modules"].push(item.toJSON());
        }
        data["start"] = this.start ? this.start.toISOString() : <any>undefined;
        data["end"] = this.end ? this.end.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["version"] = this.version;
        return data;
    }
}

export class ModuleInTrainingSession {
    id?: string | undefined;
    name?: string | undefined;
    type?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ModuleInTrainingSession {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleInTrainingSession();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["type"] = this.type;
        return data;
    }
}

/** 0 = None 1 = NotStarted 2 = Started 3 = Complete */
export enum TrainingSessionStatus {
    None = 0,
    NotStarted = 1,
    Started = 2,
    Complete = 3,
}

export class CreateTrainingSessionSettings {
    /** The organisation or team id of the training session */
    groupId!: string;
    name!: string;
    description?: string | undefined;
    start?: Date | undefined;
    end?: Date | undefined;
    location?: LocationBuilder | undefined;
    modules?: TrainingSessionModule[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.groupId = _data["groupId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.start = _data["start"] ? new Date(_data["start"].toString()) : <any>undefined;
            this.end = _data["end"] ? new Date(_data["end"].toString()) : <any>undefined;
            this.location = _data["location"] ? LocationBuilder.fromJS(_data["location"]) : <any>undefined;
            if (Array.isArray(_data["modules"])) {
                this.modules = [] as any;
                for (let item of _data["modules"])
                    this.modules!.push(TrainingSessionModule.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateTrainingSessionSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTrainingSessionSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["start"] = this.start ? this.start.toISOString() : <any>undefined;
        data["end"] = this.end ? this.end.toISOString() : <any>undefined;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        if (Array.isArray(this.modules)) {
            data["modules"] = [];
            for (let item of this.modules)
                data["modules"].push(item.toJSON());
        }
        return data;
    }
}

export class TrainingSessionModule {
    id?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TrainingSessionModule {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingSessionModule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export class UpdateTrainingSessionSettings {
    name!: string;
    description?: string | undefined;
    start?: Date | undefined;
    end?: Date | undefined;
    location?: LocationBuilder | undefined;
    modules?: TrainingSessionModule[] | undefined;
    status?: TrainingSessionStatus;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.start = _data["start"] ? new Date(_data["start"].toString()) : <any>undefined;
            this.end = _data["end"] ? new Date(_data["end"].toString()) : <any>undefined;
            this.location = _data["location"] ? LocationBuilder.fromJS(_data["location"]) : <any>undefined;
            if (Array.isArray(_data["modules"])) {
                this.modules = [] as any;
                for (let item of _data["modules"])
                    this.modules!.push(TrainingSessionModule.fromJS(item));
            }
            this.status = _data["status"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateTrainingSessionSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTrainingSessionSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["start"] = this.start ? this.start.toISOString() : <any>undefined;
        data["end"] = this.end ? this.end.toISOString() : <any>undefined;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        if (Array.isArray(this.modules)) {
            data["modules"] = [];
            for (let item of this.modules)
                data["modules"].push(item.toJSON());
        }
        data["status"] = this.status;
        data["version"] = this.version;
        return data;
    }
}

export class ListOfModuleAttemptOfVideoResult {
    totalItemCount!: number;
    items!: ModuleAttemptOfVideoResult[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ModuleAttemptOfVideoResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfModuleAttemptOfVideoResult {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfModuleAttemptOfVideoResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class ModuleAttemptOfVideoResult extends ModuleAttempt {
    result?: VideoResult | undefined;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.result = _data["result"] ? VideoResult.fromJS(_data["result"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ModuleAttemptOfVideoResult {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleAttemptOfVideoResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export class VideoResult {
    position?: string;
    maxPosition?: string;
    duration?: string;

    init(_data?: any) {
        if (_data) {
            this.position = _data["position"];
            this.maxPosition = _data["maxPosition"];
            this.duration = _data["duration"];
        }
    }

    static fromJS(data: any): VideoResult {
        data = typeof data === 'object' ? data : {};
        let result = new VideoResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["position"] = this.position;
        data["maxPosition"] = this.maxPosition;
        data["duration"] = this.duration;
        return data;
    }
}

export class CreateModuleAttemptSettingsOfVideoResult {
    /** Id of the actor of ActorType being assessed */
    actorId!: string;
    moduleContentId!: string;
    result!: VideoResult;

    init(_data?: any) {
        if (_data) {
            this.actorId = _data["actorId"];
            this.moduleContentId = _data["moduleContentId"];
            this.result = _data["result"] ? VideoResult.fromJS(_data["result"]) : new VideoResult();
        }
    }

    static fromJS(data: any): CreateModuleAttemptSettingsOfVideoResult {
        data = typeof data === 'object' ? data : {};
        let result = new CreateModuleAttemptSettingsOfVideoResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actorId"] = this.actorId;
        data["moduleContentId"] = this.moduleContentId;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export class UpdateModuleAttemptSettingsOfVideoResult {
    result!: VideoResult;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? VideoResult.fromJS(_data["result"]) : new VideoResult();
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateModuleAttemptSettingsOfVideoResult {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateModuleAttemptSettingsOfVideoResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["version"] = this.version;
        return data;
    }
}

export class ListOfModuleContentOfVideoSettings {
    totalItemCount!: number;
    items!: ModuleContentOfVideoSettings[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ModuleContentOfVideoSettings.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfModuleContentOfVideoSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfModuleContentOfVideoSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class ModuleContentOfVideoSettings extends ModuleContent {
    settings?: VideoSettings | undefined;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.settings = _data["settings"] ? VideoSettings.fromJS(_data["settings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ModuleContentOfVideoSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleContentOfVideoSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export class VideoSettings {
    type!: VideoType;
    /** A URI for the video. */
    source!: string;
    /** The duration of the video */
    duration?: string;

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.source = _data["source"];
            this.duration = _data["duration"];
        }
    }

    static fromJS(data: any): VideoSettings {
        data = typeof data === 'object' ? data : {};
        let result = new VideoSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["source"] = this.source;
        data["duration"] = this.duration;
        return data;
    }
}

/** 0 = None 1 = Vimeo 2 = Youtube 3 = Azure 4 = Wistia */
export enum VideoType {
    None = 0,
    Vimeo = 1,
    Youtube = 2,
    Azure = 3,
    Wistia = 4,
}

export class ModuleContentSettingsOfVideoSettings {
    settings!: VideoSettings;
    files?: ModuleContentFileSettings[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.settings = _data["settings"] ? VideoSettings.fromJS(_data["settings"]) : new VideoSettings();
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(ModuleContentFileSettings.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ModuleContentSettingsOfVideoSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleContentSettingsOfVideoSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data;
    }
}

export class CreateModuleContentSettingsOfVideoSettings extends ModuleContentSettingsOfVideoSettings {
    published?: boolean;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.published = _data["published"];
        }
    }

    static fromJS(data: any): CreateModuleContentSettingsOfVideoSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateModuleContentSettingsOfVideoSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["published"] = this.published;
        super.toJSON(data);
        return data;
    }
}

export class UpdateModuleContentSettingsOfVideoSettings extends ModuleContentSettingsOfVideoSettings {
    version?: number;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateModuleContentSettingsOfVideoSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateModuleContentSettingsOfVideoSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        super.toJSON(data);
        return data;
    }
}

export class ListOfModuleAttemptOfAssessmentResult {
    totalItemCount!: number;
    items!: ModuleAttemptOfAssessmentResult[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ModuleAttemptOfAssessmentResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfModuleAttemptOfAssessmentResult {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfModuleAttemptOfAssessmentResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class ModuleAttemptOfAssessmentResult extends ModuleAttempt {
    result?: AssessmentResult | undefined;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.result = _data["result"] ? AssessmentResult.fromJS(_data["result"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ModuleAttemptOfAssessmentResult {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleAttemptOfAssessmentResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export class AssessmentResult {
    attempts?: AssessmentAttempt[] | undefined;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["attempts"])) {
                this.attempts = [] as any;
                for (let item of _data["attempts"])
                    this.attempts!.push(AssessmentAttempt.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AssessmentResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssessmentResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.attempts)) {
            data["attempts"] = [];
            for (let item of this.attempts)
                data["attempts"].push(item.toJSON());
        }
        return data;
    }
}

export class AssessmentAttempt {
    id?: string | undefined;
    assessorId?: string | undefined;
    sections?: AssessmentSectionResult[] | undefined;
    performed?: Date;
    notes?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.assessorId = _data["assessorId"];
            if (Array.isArray(_data["sections"])) {
                this.sections = [] as any;
                for (let item of _data["sections"])
                    this.sections!.push(AssessmentSectionResult.fromJS(item));
            }
            this.performed = _data["performed"] ? new Date(_data["performed"].toString()) : <any>undefined;
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): AssessmentAttempt {
        data = typeof data === 'object' ? data : {};
        let result = new AssessmentAttempt();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["assessorId"] = this.assessorId;
        if (Array.isArray(this.sections)) {
            data["sections"] = [];
            for (let item of this.sections)
                data["sections"].push(item.toJSON());
        }
        data["performed"] = this.performed ? this.performed.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        return data;
    }
}

export class AssessmentSectionResult {
    index?: number;
    selectedCriteria?: number[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.index = _data["index"];
            if (Array.isArray(_data["selectedCriteria"])) {
                this.selectedCriteria = [] as any;
                for (let item of _data["selectedCriteria"])
                    this.selectedCriteria!.push(item);
            }
        }
    }

    static fromJS(data: any): AssessmentSectionResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssessmentSectionResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["index"] = this.index;
        if (Array.isArray(this.selectedCriteria)) {
            data["selectedCriteria"] = [];
            for (let item of this.selectedCriteria)
                data["selectedCriteria"].push(item);
        }
        return data;
    }
}

export class CreateModuleAttemptSettingsOfAssessmentResult {
    /** Id of the actor of ActorType being assessed */
    actorId!: string;
    moduleContentId!: string;
    result!: AssessmentResult;

    init(_data?: any) {
        if (_data) {
            this.actorId = _data["actorId"];
            this.moduleContentId = _data["moduleContentId"];
            this.result = _data["result"] ? AssessmentResult.fromJS(_data["result"]) : new AssessmentResult();
        }
    }

    static fromJS(data: any): CreateModuleAttemptSettingsOfAssessmentResult {
        data = typeof data === 'object' ? data : {};
        let result = new CreateModuleAttemptSettingsOfAssessmentResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actorId"] = this.actorId;
        data["moduleContentId"] = this.moduleContentId;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export class UpdateModuleAttemptSettingsOfAssessmentResult {
    result!: AssessmentResult;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? AssessmentResult.fromJS(_data["result"]) : new AssessmentResult();
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateModuleAttemptSettingsOfAssessmentResult {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateModuleAttemptSettingsOfAssessmentResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["version"] = this.version;
        return data;
    }
}

export class ListOfModuleContentOfAssessmentSettings {
    totalItemCount!: number;
    items!: ModuleContentOfAssessmentSettings[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ModuleContentOfAssessmentSettings.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfModuleContentOfAssessmentSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfModuleContentOfAssessmentSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class ModuleContentOfAssessmentSettings extends ModuleContent {
    settings?: AssessmentSettings | undefined;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.settings = _data["settings"] ? AssessmentSettings.fromJS(_data["settings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ModuleContentOfAssessmentSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleContentOfAssessmentSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export class AssessmentSettings {
    /** The number of times the assessment must be passed for the module to be considered passed. */
    requiredPasses!: number;
    /** The number of times the assessment must be passed, after the initial pass, for the module to be considered passed. */
    subsequentRequiredPasses?: number | undefined;
    /** The percentage required to pass the assessment. */
    passScore!: number;
    sections!: AssessmentSection[];

    init(_data?: any) {
        if (_data) {
            this.requiredPasses = _data["requiredPasses"];
            this.subsequentRequiredPasses = _data["subsequentRequiredPasses"];
            this.passScore = _data["passScore"];
            if (Array.isArray(_data["sections"])) {
                this.sections = [] as any;
                for (let item of _data["sections"])
                    this.sections!.push(AssessmentSection.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AssessmentSettings {
        data = typeof data === 'object' ? data : {};
        let result = new AssessmentSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requiredPasses"] = this.requiredPasses;
        data["subsequentRequiredPasses"] = this.subsequentRequiredPasses;
        data["passScore"] = this.passScore;
        if (Array.isArray(this.sections)) {
            data["sections"] = [];
            for (let item of this.sections)
                data["sections"].push(item.toJSON());
        }
        return data;
    }
}

export class AssessmentSection {
    title?: string | undefined;
    criteria!: Criterion[];

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            if (Array.isArray(_data["criteria"])) {
                this.criteria = [] as any;
                for (let item of _data["criteria"])
                    this.criteria!.push(Criterion.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AssessmentSection {
        data = typeof data === 'object' ? data : {};
        let result = new AssessmentSection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        if (Array.isArray(this.criteria)) {
            data["criteria"] = [];
            for (let item of this.criteria)
                data["criteria"].push(item.toJSON());
        }
        return data;
    }
}

export class Criterion {
    body!: string;

    init(_data?: any) {
        if (_data) {
            this.body = _data["body"];
        }
    }

    static fromJS(data: any): Criterion {
        data = typeof data === 'object' ? data : {};
        let result = new Criterion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["body"] = this.body;
        return data;
    }
}

export class ModuleContentSettingsOfAssessmentSettings {
    settings!: AssessmentSettings;
    files?: ModuleContentFileSettings[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.settings = _data["settings"] ? AssessmentSettings.fromJS(_data["settings"]) : new AssessmentSettings();
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(ModuleContentFileSettings.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ModuleContentSettingsOfAssessmentSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleContentSettingsOfAssessmentSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data;
    }
}

export class CreateModuleContentSettingsOfAssessmentSettings extends ModuleContentSettingsOfAssessmentSettings {
    published?: boolean;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.published = _data["published"];
        }
    }

    static fromJS(data: any): CreateModuleContentSettingsOfAssessmentSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateModuleContentSettingsOfAssessmentSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["published"] = this.published;
        super.toJSON(data);
        return data;
    }
}

export class UpdateModuleContentSettingsOfAssessmentSettings extends ModuleContentSettingsOfAssessmentSettings {
    version?: number;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateModuleContentSettingsOfAssessmentSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateModuleContentSettingsOfAssessmentSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        super.toJSON(data);
        return data;
    }
}

export class ListOfAssessmentSubAttempt {
    totalItemCount!: number;
    items!: AssessmentSubAttempt[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AssessmentSubAttempt.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfAssessmentSubAttempt {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfAssessmentSubAttempt();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class AssessmentSubAttempt {
    id?: string | undefined;
    attemptId?: string | undefined;
    actorId?: string | undefined;
    actorName?: string | undefined;
    actorType?: ActorType;
    assessorId?: string | undefined;
    assessorName?: string | undefined;
    sections?: AssessmentSectionResult[] | undefined;
    created?: Date;
    modified?: Date;
    performed?: Date;
    notes?: string | undefined;
    assessmentId?: string | undefined;
    assessmentName?: string | undefined;
    assessmentContentId?: string | undefined;
    passScore?: number;
    score?: number;
    passed?: boolean;
    publisherId?: string | undefined;
    classIds?: string[] | undefined;
    trainingSessionId?: string | undefined;
    trainingSessionModuleAttemptId?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.attemptId = _data["attemptId"];
            this.actorId = _data["actorId"];
            this.actorName = _data["actorName"];
            this.actorType = _data["actorType"];
            this.assessorId = _data["assessorId"];
            this.assessorName = _data["assessorName"];
            if (Array.isArray(_data["sections"])) {
                this.sections = [] as any;
                for (let item of _data["sections"])
                    this.sections!.push(AssessmentSectionResult.fromJS(item));
            }
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
            this.performed = _data["performed"] ? new Date(_data["performed"].toString()) : <any>undefined;
            this.notes = _data["notes"];
            this.assessmentId = _data["assessmentId"];
            this.assessmentName = _data["assessmentName"];
            this.assessmentContentId = _data["assessmentContentId"];
            this.passScore = _data["passScore"];
            this.score = _data["score"];
            this.passed = _data["passed"];
            this.publisherId = _data["publisherId"];
            if (Array.isArray(_data["classIds"])) {
                this.classIds = [] as any;
                for (let item of _data["classIds"])
                    this.classIds!.push(item);
            }
            this.trainingSessionId = _data["trainingSessionId"];
            this.trainingSessionModuleAttemptId = _data["trainingSessionModuleAttemptId"];
        }
    }

    static fromJS(data: any): AssessmentSubAttempt {
        data = typeof data === 'object' ? data : {};
        let result = new AssessmentSubAttempt();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["attemptId"] = this.attemptId;
        data["actorId"] = this.actorId;
        data["actorName"] = this.actorName;
        data["actorType"] = this.actorType;
        data["assessorId"] = this.assessorId;
        data["assessorName"] = this.assessorName;
        if (Array.isArray(this.sections)) {
            data["sections"] = [];
            for (let item of this.sections)
                data["sections"].push(item.toJSON());
        }
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        data["performed"] = this.performed ? this.performed.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        data["assessmentId"] = this.assessmentId;
        data["assessmentName"] = this.assessmentName;
        data["assessmentContentId"] = this.assessmentContentId;
        data["passScore"] = this.passScore;
        data["score"] = this.score;
        data["passed"] = this.passed;
        data["publisherId"] = this.publisherId;
        if (Array.isArray(this.classIds)) {
            data["classIds"] = [];
            for (let item of this.classIds)
                data["classIds"].push(item);
        }
        data["trainingSessionId"] = this.trainingSessionId;
        data["trainingSessionModuleAttemptId"] = this.trainingSessionModuleAttemptId;
        return data;
    }
}

export class CreateAssessmentSubAttemptSettings {
    /** Id of the actor of ActorType being assessed */
    actorId!: string;
    assessorId!: string;
    moduleId!: string;
    moduleContentId!: string;
    sections!: AssessmentSectionResult[];
    performed!: Date;
    notes?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.actorId = _data["actorId"];
            this.assessorId = _data["assessorId"];
            this.moduleId = _data["moduleId"];
            this.moduleContentId = _data["moduleContentId"];
            if (Array.isArray(_data["sections"])) {
                this.sections = [] as any;
                for (let item of _data["sections"])
                    this.sections!.push(AssessmentSectionResult.fromJS(item));
            }
            this.performed = _data["performed"] ? new Date(_data["performed"].toString()) : <any>undefined;
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): CreateAssessmentSubAttemptSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAssessmentSubAttemptSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actorId"] = this.actorId;
        data["assessorId"] = this.assessorId;
        data["moduleId"] = this.moduleId;
        data["moduleContentId"] = this.moduleContentId;
        if (Array.isArray(this.sections)) {
            data["sections"] = [];
            for (let item of this.sections)
                data["sections"].push(item.toJSON());
        }
        data["performed"] = this.performed ? this.performed.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        return data;
    }
}

export class UpdateAssessmentSubAttemptSettings {
    assessorId!: string;
    sections!: AssessmentSectionResult[];
    performed!: Date;
    notes?: string | undefined;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.assessorId = _data["assessorId"];
            if (Array.isArray(_data["sections"])) {
                this.sections = [] as any;
                for (let item of _data["sections"])
                    this.sections!.push(AssessmentSectionResult.fromJS(item));
            }
            this.performed = _data["performed"] ? new Date(_data["performed"].toString()) : <any>undefined;
            this.notes = _data["notes"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateAssessmentSubAttemptSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAssessmentSubAttemptSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assessorId"] = this.assessorId;
        if (Array.isArray(this.sections)) {
            data["sections"] = [];
            for (let item of this.sections)
                data["sections"].push(item.toJSON());
        }
        data["performed"] = this.performed ? this.performed.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        data["version"] = this.version;
        return data;
    }
}

export class AuthenticationSettings {
    method?: AuthenticationMethod;
    email!: string;
    /** This will be the password if using password to login, or the one-time passcode if using one-time passcode
to login. */
    password?: string | undefined;
    /** Optional 2FA code. */
    twoFactorAuthenticationCode?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.method = _data["method"] !== undefined ? _data["method"] : AuthenticationMethod.Password;
            this.email = _data["email"];
            this.password = _data["password"] !== undefined ? _data["password"] : "";
            this.twoFactorAuthenticationCode = _data["twoFactorAuthenticationCode"];
        }
    }

    static fromJS(data: any): AuthenticationSettings {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticationSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["method"] = this.method;
        data["email"] = this.email;
        data["password"] = this.password;
        data["twoFactorAuthenticationCode"] = this.twoFactorAuthenticationCode;
        return data;
    }
}

/** 0 = Password 1 = OneTimePasscode */
export enum AuthenticationMethod {
    Password = 0,
    OneTimePasscode = 1,
}

export class ChallengeToken extends Token {
    success?: boolean;
    twoFactorAuthenticationChallenge?: TwoFactorAuthenticationType;
    rateLimit?: string;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.success = _data["success"];
            this.twoFactorAuthenticationChallenge = _data["twoFactorAuthenticationChallenge"];
            this.rateLimit = _data["rateLimit"];
        }
    }

    static fromJS(data: any): ChallengeToken {
        data = typeof data === 'object' ? data : {};
        let result = new ChallengeToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["twoFactorAuthenticationChallenge"] = this.twoFactorAuthenticationChallenge;
        data["rateLimit"] = this.rateLimit;
        super.toJSON(data);
        return data;
    }
}

/** 0 = None 1 = Sms 2 = Email */
export enum TwoFactorAuthenticationType {
    None = 0,
    Sms = 1,
    Email = 2,
}

export class Identity {
    id?: string | undefined;
    type?: IdentityType;
    name?: string | undefined;
    email?: string | undefined;
    description?: string | undefined;
    imageUri?: string | undefined;
    groups?: IdentityGroup[] | undefined;
    impersonatorId?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.description = _data["description"];
            this.imageUri = _data["imageUri"];
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(IdentityGroup.fromJS(item));
            }
            this.impersonatorId = _data["impersonatorId"];
        }
    }

    static fromJS(data: any): Identity {
        data = typeof data === 'object' ? data : {};
        let result = new Identity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["name"] = this.name;
        data["email"] = this.email;
        data["description"] = this.description;
        data["imageUri"] = this.imageUri;
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item.toJSON());
        }
        data["impersonatorId"] = this.impersonatorId;
        return data;
    }
}

export class IdentityGroup {
    groupId?: string | undefined;
    groupType?: string | undefined;
    parentGroups?: GroupIdAndType[] | undefined;
    displayId?: string | undefined;
    labelIds?: string[] | undefined;
    roles?: string[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.groupId = _data["groupId"];
            this.groupType = _data["groupType"];
            if (Array.isArray(_data["parentGroups"])) {
                this.parentGroups = [] as any;
                for (let item of _data["parentGroups"])
                    this.parentGroups!.push(GroupIdAndType.fromJS(item));
            }
            this.displayId = _data["displayId"];
            if (Array.isArray(_data["labelIds"])) {
                this.labelIds = [] as any;
                for (let item of _data["labelIds"])
                    this.labelIds!.push(item);
            }
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): IdentityGroup {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        data["groupType"] = this.groupType;
        if (Array.isArray(this.parentGroups)) {
            data["parentGroups"] = [];
            for (let item of this.parentGroups)
                data["parentGroups"].push(item.toJSON());
        }
        data["displayId"] = this.displayId;
        if (Array.isArray(this.labelIds)) {
            data["labelIds"] = [];
            for (let item of this.labelIds)
                data["labelIds"].push(item);
        }
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export class GroupIdAndType {
    type?: string | undefined;
    id?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GroupIdAndType {
        data = typeof data === 'object' ? data : {};
        let result = new GroupIdAndType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["id"] = this.id;
        return data;
    }
}

export class CommunicationPreferences {
    userId?: string | undefined;
    emails?: EmailPreference[] | undefined;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            if (Array.isArray(_data["emails"])) {
                this.emails = [] as any;
                for (let item of _data["emails"])
                    this.emails!.push(EmailPreference.fromJS(item));
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): CommunicationPreferences {
        data = typeof data === 'object' ? data : {};
        let result = new CommunicationPreferences();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        if (Array.isArray(this.emails)) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item.toJSON());
        }
        data["version"] = this.version;
        return data;
    }
}

export class EmailPreference2 {
    type?: string | undefined;
    ignore?: boolean;

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.ignore = _data["ignore"];
        }
    }

    static fromJS(data: any): EmailPreference2 {
        data = typeof data === 'object' ? data : {};
        let result = new EmailPreference2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["ignore"] = this.ignore;
        return data;
    }
}

export class EmailPreference extends EmailPreference2 {
    category?: string | undefined;
    reason?: string | undefined;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.category = _data["category"];
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): EmailPreference {
        data = typeof data === 'object' ? data : {};
        let result = new EmailPreference();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        data["reason"] = this.reason;
        super.toJSON(data);
        return data;
    }
}

export class UpdateCommunicationPreferencesSettings {
    emails?: EmailPreference2[] | undefined;
    version?: number;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["emails"])) {
                this.emails = [] as any;
                for (let item of _data["emails"])
                    this.emails!.push(EmailPreference2.fromJS(item));
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateCommunicationPreferencesSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCommunicationPreferencesSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.emails)) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item.toJSON());
        }
        data["version"] = this.version;
        return data;
    }
}

export class UnsubscribeToken {
    userId?: string | undefined;
    emailType?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.emailType = _data["emailType"];
        }
    }

    static fromJS(data: any): UnsubscribeToken {
        data = typeof data === 'object' ? data : {};
        let result = new UnsubscribeToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["emailType"] = this.emailType;
        return data;
    }
}

export class EmailSettings {
    email!: string;

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): EmailSettings {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export class ListOfGroupComment {
    totalItemCount!: number;
    items!: GroupComment[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GroupComment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfGroupComment {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfGroupComment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class GroupComment extends Comment {
    groupName?: string | undefined;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.groupName = _data["groupName"];
        }
    }

    static fromJS(data: any): GroupComment {
        data = typeof data === 'object' ? data : {};
        let result = new GroupComment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupName"] = this.groupName;
        super.toJSON(data);
        return data;
    }
}

export class Group {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    type?: string | undefined;
    organisationId?: string | undefined;
    teamId?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.type = _data["type"];
            this.organisationId = _data["organisationId"];
            this.teamId = _data["teamId"];
        }
    }

    static fromJS(data: any): Group {
        data = typeof data === 'object' ? data : {};
        let result = new Group();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["type"] = this.type;
        data["organisationId"] = this.organisationId;
        data["teamId"] = this.teamId;
        return data;
    }
}

export class ListOfGroupFile {
    totalItemCount!: number;
    items!: GroupFile[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GroupFile.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfGroupFile {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfGroupFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class GroupFile extends File {
    groupName?: string | undefined;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.groupName = _data["groupName"];
        }
    }

    static fromJS(data: any): GroupFile {
        data = typeof data === 'object' ? data : {};
        let result = new GroupFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupName"] = this.groupName;
        super.toJSON(data);
        return data;
    }
}

export class ListOfJobType {
    totalItemCount!: number;
    items!: JobType[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(JobType.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfJobType {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfJobType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class JobType {
    id?: string | undefined;
    name?: string | undefined;
    category?: string | undefined;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.category = _data["category"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): JobType {
        data = typeof data === 'object' ? data : {};
        let result = new JobType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["category"] = this.category;
        data["version"] = this.version;
        return data;
    }
}

export class CreateJobTypeSettings {
    name!: string;
    category?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.category = _data["category"];
        }
    }

    static fromJS(data: any): CreateJobTypeSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateJobTypeSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["category"] = this.category;
        return data;
    }
}

export class UpdateJobTypeSettings {
    name!: string;
    category?: string | undefined;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.category = _data["category"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateJobTypeSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateJobTypeSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["category"] = this.category;
        data["version"] = this.version;
        return data;
    }
}

export class ListOfLabel {
    totalItemCount!: number;
    items!: Label[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Label.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfLabel {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfLabel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class Label {
    id?: string | undefined;
    version?: number;
    groupId?: string | undefined;
    groupType?: string | undefined;
    groupName?: string | undefined;
    name?: string | undefined;
    colour?: Colour;
    inactive?: boolean;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.version = _data["version"];
            this.groupId = _data["groupId"];
            this.groupType = _data["groupType"];
            this.groupName = _data["groupName"];
            this.name = _data["name"];
            this.colour = _data["colour"] ? Colour.fromJS(_data["colour"]) : <any>undefined;
            this.inactive = _data["inactive"];
        }
    }

    static fromJS(data: any): Label {
        data = typeof data === 'object' ? data : {};
        let result = new Label();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["version"] = this.version;
        data["groupId"] = this.groupId;
        data["groupType"] = this.groupType;
        data["groupName"] = this.groupName;
        data["name"] = this.name;
        data["colour"] = this.colour ? this.colour.toJSON() : <any>undefined;
        data["inactive"] = this.inactive;
        return data;
    }
}

export class Colour {
    red?: number;
    green?: number;
    blue?: number;
    alpha?: number;

    init(_data?: any) {
        if (_data) {
            this.red = _data["red"];
            this.green = _data["green"];
            this.blue = _data["blue"];
            this.alpha = _data["alpha"];
        }
    }

    static fromJS(data: any): Colour {
        data = typeof data === 'object' ? data : {};
        let result = new Colour();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["red"] = this.red;
        data["green"] = this.green;
        data["blue"] = this.blue;
        data["alpha"] = this.alpha;
        return data;
    }
}

export class CreateLabelSettings {
    groupId!: string;
    name!: string;
    colour?: Colour;

    init(_data?: any) {
        if (_data) {
            this.groupId = _data["groupId"];
            this.name = _data["name"];
            this.colour = _data["colour"] ? Colour.fromJS(_data["colour"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateLabelSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLabelSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        data["name"] = this.name;
        data["colour"] = this.colour ? this.colour.toJSON() : <any>undefined;
        return data;
    }
}

export class UpdateLabelSettings {
    name!: string;
    colour?: Colour;
    inactive?: boolean;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.colour = _data["colour"] ? Colour.fromJS(_data["colour"]) : <any>undefined;
            this.inactive = _data["inactive"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateLabelSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLabelSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["colour"] = this.colour ? this.colour.toJSON() : <any>undefined;
        data["inactive"] = this.inactive;
        data["version"] = this.version;
        return data;
    }
}

export class ListOfMember {
    totalItemCount!: number;
    items!: Member[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Member.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfMember {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfMember();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class Member {
    id?: string | undefined;
    groupId?: string | undefined;
    groupType?: string | undefined;
    groupName?: string | undefined;
    parentGroups?: GroupIdAndType[] | undefined;
    templateId?: string | undefined;
    templateParentIds?: string[] | undefined;
    userId?: string | undefined;
    userName?: string | undefined;
    userImageUri?: string | undefined;
    userEmail?: string | undefined;
    userJobTypeId?: string | undefined;
    userJobTypeName?: string | undefined;
    userJobTypeCategory?: string | undefined;
    userQualifications?: string | undefined;
    userActivated?: boolean;
    userLastActive?: Date | undefined;
    displayId?: string | undefined;
    status?: MemberStatus;
    roles?: string[] | undefined;
    labelIds?: string[] | undefined;
    version?: number;
    created?: Date;
    modified?: Date;
    joined?: Date;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.groupId = _data["groupId"];
            this.groupType = _data["groupType"];
            this.groupName = _data["groupName"];
            if (Array.isArray(_data["parentGroups"])) {
                this.parentGroups = [] as any;
                for (let item of _data["parentGroups"])
                    this.parentGroups!.push(GroupIdAndType.fromJS(item));
            }
            this.templateId = _data["templateId"];
            if (Array.isArray(_data["templateParentIds"])) {
                this.templateParentIds = [] as any;
                for (let item of _data["templateParentIds"])
                    this.templateParentIds!.push(item);
            }
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.userImageUri = _data["userImageUri"];
            this.userEmail = _data["userEmail"];
            this.userJobTypeId = _data["userJobTypeId"];
            this.userJobTypeName = _data["userJobTypeName"];
            this.userJobTypeCategory = _data["userJobTypeCategory"];
            this.userQualifications = _data["userQualifications"];
            this.userActivated = _data["userActivated"];
            this.userLastActive = _data["userLastActive"] ? new Date(_data["userLastActive"].toString()) : <any>undefined;
            this.displayId = _data["displayId"];
            this.status = _data["status"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
            if (Array.isArray(_data["labelIds"])) {
                this.labelIds = [] as any;
                for (let item of _data["labelIds"])
                    this.labelIds!.push(item);
            }
            this.version = _data["version"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
            this.joined = _data["joined"] ? new Date(_data["joined"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Member {
        data = typeof data === 'object' ? data : {};
        let result = new Member();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["groupId"] = this.groupId;
        data["groupType"] = this.groupType;
        data["groupName"] = this.groupName;
        if (Array.isArray(this.parentGroups)) {
            data["parentGroups"] = [];
            for (let item of this.parentGroups)
                data["parentGroups"].push(item.toJSON());
        }
        data["templateId"] = this.templateId;
        if (Array.isArray(this.templateParentIds)) {
            data["templateParentIds"] = [];
            for (let item of this.templateParentIds)
                data["templateParentIds"].push(item);
        }
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["userImageUri"] = this.userImageUri;
        data["userEmail"] = this.userEmail;
        data["userJobTypeId"] = this.userJobTypeId;
        data["userJobTypeName"] = this.userJobTypeName;
        data["userJobTypeCategory"] = this.userJobTypeCategory;
        data["userQualifications"] = this.userQualifications;
        data["userActivated"] = this.userActivated;
        data["userLastActive"] = this.userLastActive ? this.userLastActive.toISOString() : <any>undefined;
        data["displayId"] = this.displayId;
        data["status"] = this.status;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        if (Array.isArray(this.labelIds)) {
            data["labelIds"] = [];
            for (let item of this.labelIds)
                data["labelIds"].push(item);
        }
        data["version"] = this.version;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        data["joined"] = this.joined ? this.joined.toISOString() : <any>undefined;
        return data;
    }
}

export class MemberHistory {
    id?: string | undefined;
    userId?: string | undefined;
    status?: MemberStatus;
    roles?: string[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.status = _data["status"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): MemberHistory {
        data = typeof data === 'object' ? data : {};
        let result = new MemberHistory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["status"] = this.status;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export class AddGroupMemberSettings {
    displayId?: string | undefined;
    additionalRoles?: string[] | undefined;
    labelIds?: string[] | undefined;
    notify?: boolean;
    message?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.displayId = _data["displayId"];
            if (Array.isArray(_data["additionalRoles"])) {
                this.additionalRoles = [] as any;
                for (let item of _data["additionalRoles"])
                    this.additionalRoles!.push(item);
            }
            if (Array.isArray(_data["labelIds"])) {
                this.labelIds = [] as any;
                for (let item of _data["labelIds"])
                    this.labelIds!.push(item);
            }
            this.notify = _data["notify"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): AddGroupMemberSettings {
        data = typeof data === 'object' ? data : {};
        let result = new AddGroupMemberSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayId"] = this.displayId;
        if (Array.isArray(this.additionalRoles)) {
            data["additionalRoles"] = [];
            for (let item of this.additionalRoles)
                data["additionalRoles"].push(item);
        }
        if (Array.isArray(this.labelIds)) {
            data["labelIds"] = [];
            for (let item of this.labelIds)
                data["labelIds"].push(item);
        }
        data["notify"] = this.notify;
        data["message"] = this.message;
        return data;
    }
}

export class UpdateGroupMemberSettings {
    displayId?: string | undefined;
    additionalRoles?: string[] | undefined;
    labelIds?: string[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.displayId = _data["displayId"];
            if (Array.isArray(_data["additionalRoles"])) {
                this.additionalRoles = [] as any;
                for (let item of _data["additionalRoles"])
                    this.additionalRoles!.push(item);
            }
            if (Array.isArray(_data["labelIds"])) {
                this.labelIds = [] as any;
                for (let item of _data["labelIds"])
                    this.labelIds!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateGroupMemberSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGroupMemberSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayId"] = this.displayId;
        if (Array.isArray(this.additionalRoles)) {
            data["additionalRoles"] = [];
            for (let item of this.additionalRoles)
                data["additionalRoles"].push(item);
        }
        if (Array.isArray(this.labelIds)) {
            data["labelIds"] = [];
            for (let item of this.labelIds)
                data["labelIds"].push(item);
        }
        return data;
    }
}

export class ListOfOrganisationAccessToken {
    totalItemCount!: number;
    items!: OrganisationAccessToken[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrganisationAccessToken.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfOrganisationAccessToken {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfOrganisationAccessToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class OrganisationAccessToken {
    id?: string | undefined;
    name?: string | undefined;
    organisationId?: string | undefined;
    roles?: string[] | undefined;
    created?: Date;
    creatorId?: string | undefined;
    creatorName?: string | undefined;
    lastUsed?: Date | undefined;
    /** Only available at time of creation */
    token?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.organisationId = _data["organisationId"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.creatorId = _data["creatorId"];
            this.creatorName = _data["creatorName"];
            this.lastUsed = _data["lastUsed"] ? new Date(_data["lastUsed"].toString()) : <any>undefined;
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): OrganisationAccessToken {
        data = typeof data === 'object' ? data : {};
        let result = new OrganisationAccessToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["organisationId"] = this.organisationId;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["creatorId"] = this.creatorId;
        data["creatorName"] = this.creatorName;
        data["lastUsed"] = this.lastUsed ? this.lastUsed.toISOString() : <any>undefined;
        data["token"] = this.token;
        return data;
    }
}

export class CreateOrganisationAccessTokenSettings {
    name!: string;
    organisationId!: string;
    roles!: string[];

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.organisationId = _data["organisationId"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrganisationAccessTokenSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganisationAccessTokenSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["organisationId"] = this.organisationId;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export class ListOfOrganisation {
    totalItemCount!: number;
    items!: Organisation[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Organisation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfOrganisation {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfOrganisation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class Organisation {
    id?: string | undefined;
    name?: string | undefined;
    shortName?: string | undefined;
    alternativeNames?: string[] | undefined;
    description?: string | undefined;
    contactEmail?: string | undefined;
    bannerUri?: string | undefined;
    logoUri?: string | undefined;
    location?: Location;
    privacy?: PrivacyLevel;
    website?: string | undefined;
    cultureCode?: string | undefined;
    timeZoneId?: string | undefined;
    portalUri?: string | undefined;
    colour?: Colour;
    registrationWhitelist?: string[] | undefined;
    publishingApproved?: boolean;
    shifts?: Shift[] | undefined;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.shortName = _data["shortName"];
            if (Array.isArray(_data["alternativeNames"])) {
                this.alternativeNames = [] as any;
                for (let item of _data["alternativeNames"])
                    this.alternativeNames!.push(item);
            }
            this.description = _data["description"];
            this.contactEmail = _data["contactEmail"];
            this.bannerUri = _data["bannerUri"];
            this.logoUri = _data["logoUri"];
            this.location = _data["location"] ? Location.fromJS(_data["location"]) : <any>undefined;
            this.privacy = _data["privacy"];
            this.website = _data["website"];
            this.cultureCode = _data["cultureCode"];
            this.timeZoneId = _data["timeZoneId"];
            this.portalUri = _data["portalUri"];
            this.colour = _data["colour"] ? Colour.fromJS(_data["colour"]) : <any>undefined;
            if (Array.isArray(_data["registrationWhitelist"])) {
                this.registrationWhitelist = [] as any;
                for (let item of _data["registrationWhitelist"])
                    this.registrationWhitelist!.push(item);
            }
            this.publishingApproved = _data["publishingApproved"];
            if (Array.isArray(_data["shifts"])) {
                this.shifts = [] as any;
                for (let item of _data["shifts"])
                    this.shifts!.push(Shift.fromJS(item));
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): Organisation {
        data = typeof data === 'object' ? data : {};
        let result = new Organisation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["shortName"] = this.shortName;
        if (Array.isArray(this.alternativeNames)) {
            data["alternativeNames"] = [];
            for (let item of this.alternativeNames)
                data["alternativeNames"].push(item);
        }
        data["description"] = this.description;
        data["contactEmail"] = this.contactEmail;
        data["bannerUri"] = this.bannerUri;
        data["logoUri"] = this.logoUri;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["privacy"] = this.privacy;
        data["website"] = this.website;
        data["cultureCode"] = this.cultureCode;
        data["timeZoneId"] = this.timeZoneId;
        data["portalUri"] = this.portalUri;
        data["colour"] = this.colour ? this.colour.toJSON() : <any>undefined;
        if (Array.isArray(this.registrationWhitelist)) {
            data["registrationWhitelist"] = [];
            for (let item of this.registrationWhitelist)
                data["registrationWhitelist"].push(item);
        }
        data["publishingApproved"] = this.publishingApproved;
        if (Array.isArray(this.shifts)) {
            data["shifts"] = [];
            for (let item of this.shifts)
                data["shifts"].push(item.toJSON());
        }
        data["version"] = this.version;
        return data;
    }
}

export class Shift {
    start?: string;
    end?: string;

    init(_data?: any) {
        if (_data) {
            this.start = _data["start"];
            this.end = _data["end"];
        }
    }

    static fromJS(data: any): Shift {
        data = typeof data === 'object' ? data : {};
        let result = new Shift();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["start"] = this.start;
        data["end"] = this.end;
        return data;
    }
}

export class CreateOrganisationSettings {
    name!: string;
    shortName?: string | undefined;
    alternativeNames?: string[];
    description?: string | undefined;
    contactEmail?: string | undefined;
    bannerUri?: string | undefined;
    logoUri?: string | undefined;
    colour?: Colour;
    location?: LocationBuilder | undefined;
    website?: string | undefined;
    portalUri?: string | undefined;
    cultureCode?: string | undefined;
    timeZoneId?: string | undefined;
    privacy?: PrivacyLevel;
    registrationWhitelist?: string[] | undefined;
    shifts?: Shift[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.shortName = _data["shortName"];
            if (Array.isArray(_data["alternativeNames"])) {
                this.alternativeNames = [] as any;
                for (let item of _data["alternativeNames"])
                    this.alternativeNames!.push(item);
            }
            this.description = _data["description"];
            this.contactEmail = _data["contactEmail"];
            this.bannerUri = _data["bannerUri"];
            this.logoUri = _data["logoUri"];
            this.colour = _data["colour"] ? Colour.fromJS(_data["colour"]) : <any>undefined;
            this.location = _data["location"] ? LocationBuilder.fromJS(_data["location"]) : <any>undefined;
            this.website = _data["website"];
            this.portalUri = _data["portalUri"];
            this.cultureCode = _data["cultureCode"];
            this.timeZoneId = _data["timeZoneId"];
            this.privacy = _data["privacy"];
            if (Array.isArray(_data["registrationWhitelist"])) {
                this.registrationWhitelist = [] as any;
                for (let item of _data["registrationWhitelist"])
                    this.registrationWhitelist!.push(item);
            }
            if (Array.isArray(_data["shifts"])) {
                this.shifts = [] as any;
                for (let item of _data["shifts"])
                    this.shifts!.push(Shift.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateOrganisationSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganisationSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["shortName"] = this.shortName;
        if (Array.isArray(this.alternativeNames)) {
            data["alternativeNames"] = [];
            for (let item of this.alternativeNames)
                data["alternativeNames"].push(item);
        }
        data["description"] = this.description;
        data["contactEmail"] = this.contactEmail;
        data["bannerUri"] = this.bannerUri;
        data["logoUri"] = this.logoUri;
        data["colour"] = this.colour ? this.colour.toJSON() : <any>undefined;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["website"] = this.website;
        data["portalUri"] = this.portalUri;
        data["cultureCode"] = this.cultureCode;
        data["timeZoneId"] = this.timeZoneId;
        data["privacy"] = this.privacy;
        if (Array.isArray(this.registrationWhitelist)) {
            data["registrationWhitelist"] = [];
            for (let item of this.registrationWhitelist)
                data["registrationWhitelist"].push(item);
        }
        if (Array.isArray(this.shifts)) {
            data["shifts"] = [];
            for (let item of this.shifts)
                data["shifts"].push(item.toJSON());
        }
        return data;
    }
}

export class UpdateOrganisationSettings {
    name!: string;
    shortName?: string | undefined;
    alternativeNames?: string[];
    description?: string | undefined;
    contactEmail?: string | undefined;
    bannerUri?: string | undefined;
    logoUri?: string | undefined;
    colour?: Colour;
    location?: LocationBuilder | undefined;
    website?: string | undefined;
    portalUri?: string | undefined;
    privacy?: PrivacyLevel;
    timeZoneId?: string | undefined;
    cultureCode?: string | undefined;
    registrationWhitelist?: string[] | undefined;
    shifts?: Shift[] | undefined;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.shortName = _data["shortName"];
            if (Array.isArray(_data["alternativeNames"])) {
                this.alternativeNames = [] as any;
                for (let item of _data["alternativeNames"])
                    this.alternativeNames!.push(item);
            }
            this.description = _data["description"];
            this.contactEmail = _data["contactEmail"];
            this.bannerUri = _data["bannerUri"];
            this.logoUri = _data["logoUri"];
            this.colour = _data["colour"] ? Colour.fromJS(_data["colour"]) : <any>undefined;
            this.location = _data["location"] ? LocationBuilder.fromJS(_data["location"]) : <any>undefined;
            this.website = _data["website"];
            this.portalUri = _data["portalUri"];
            this.privacy = _data["privacy"];
            this.timeZoneId = _data["timeZoneId"];
            this.cultureCode = _data["cultureCode"];
            if (Array.isArray(_data["registrationWhitelist"])) {
                this.registrationWhitelist = [] as any;
                for (let item of _data["registrationWhitelist"])
                    this.registrationWhitelist!.push(item);
            }
            if (Array.isArray(_data["shifts"])) {
                this.shifts = [] as any;
                for (let item of _data["shifts"])
                    this.shifts!.push(Shift.fromJS(item));
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateOrganisationSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrganisationSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["shortName"] = this.shortName;
        if (Array.isArray(this.alternativeNames)) {
            data["alternativeNames"] = [];
            for (let item of this.alternativeNames)
                data["alternativeNames"].push(item);
        }
        data["description"] = this.description;
        data["contactEmail"] = this.contactEmail;
        data["bannerUri"] = this.bannerUri;
        data["logoUri"] = this.logoUri;
        data["colour"] = this.colour ? this.colour.toJSON() : <any>undefined;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["website"] = this.website;
        data["portalUri"] = this.portalUri;
        data["privacy"] = this.privacy;
        data["timeZoneId"] = this.timeZoneId;
        data["cultureCode"] = this.cultureCode;
        if (Array.isArray(this.registrationWhitelist)) {
            data["registrationWhitelist"] = [];
            for (let item of this.registrationWhitelist)
                data["registrationWhitelist"].push(item);
        }
        if (Array.isArray(this.shifts)) {
            data["shifts"] = [];
            for (let item of this.shifts)
                data["shifts"].push(item.toJSON());
        }
        data["version"] = this.version;
        return data;
    }
}

export class Password {
    version?: number;
    exists?: boolean;
    twoFactorAuthentication?: TwoFactorAuthenticationType;

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.exists = _data["exists"];
            this.twoFactorAuthentication = _data["twoFactorAuthentication"];
        }
    }

    static fromJS(data: any): Password {
        data = typeof data === 'object' ? data : {};
        let result = new Password();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["exists"] = this.exists;
        data["twoFactorAuthentication"] = this.twoFactorAuthentication;
        return data;
    }
}

export class UpdatePasswordSettings {
    password!: string;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.password = _data["password"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdatePasswordSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePasswordSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        data["version"] = this.version;
        return data;
    }
}

export class UpdateTwoFactorAuthenticationSettings {
    type?: TwoFactorAuthenticationType;
    userVersion?: number;

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.userVersion = _data["userVersion"];
        }
    }

    static fromJS(data: any): UpdateTwoFactorAuthenticationSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTwoFactorAuthenticationSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["userVersion"] = this.userVersion;
        return data;
    }
}

export class RequestResetPasswordSettings {
    email!: string;

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): RequestResetPasswordSettings {
        data = typeof data === 'object' ? data : {};
        let result = new RequestResetPasswordSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export class ResetPasswordSettings {
    token!: string;
    password!: string;

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): ResetPasswordSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["password"] = this.password;
        return data;
    }
}

export class ListOfRole {
    totalItemCount!: number;
    items!: Role[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Role.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfRole {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class Role {
    name?: string | undefined;
    groupType?: string | undefined;
    owner?: boolean;
    default?: boolean;
    fallback?: boolean;
    description?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.groupType = _data["groupType"];
            this.owner = _data["owner"];
            this.default = _data["default"];
            this.fallback = _data["fallback"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): Role {
        data = typeof data === 'object' ? data : {};
        let result = new Role();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["groupType"] = this.groupType;
        data["owner"] = this.owner;
        data["default"] = this.default;
        data["fallback"] = this.fallback;
        data["description"] = this.description;
        return data;
    }
}

export class ListOfTeam {
    totalItemCount!: number;
    items!: Team[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Team.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfTeam {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfTeam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class Team {
    id?: string | undefined;
    shortName?: string | undefined;
    alternativeNames?: string[] | undefined;
    name?: string | undefined;
    description?: string | undefined;
    bannerUri?: string | undefined;
    privacy?: PrivacyLevel;
    tags?: string[] | undefined;
    organisationId?: string | undefined;
    organisationName?: string | undefined;
    organisationLogoUri?: string | undefined;
    organisationPrivacy?: PrivacyLevel;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.shortName = _data["shortName"];
            if (Array.isArray(_data["alternativeNames"])) {
                this.alternativeNames = [] as any;
                for (let item of _data["alternativeNames"])
                    this.alternativeNames!.push(item);
            }
            this.name = _data["name"];
            this.description = _data["description"];
            this.bannerUri = _data["bannerUri"];
            this.privacy = _data["privacy"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            this.organisationId = _data["organisationId"];
            this.organisationName = _data["organisationName"];
            this.organisationLogoUri = _data["organisationLogoUri"];
            this.organisationPrivacy = _data["organisationPrivacy"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): Team {
        data = typeof data === 'object' ? data : {};
        let result = new Team();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["shortName"] = this.shortName;
        if (Array.isArray(this.alternativeNames)) {
            data["alternativeNames"] = [];
            for (let item of this.alternativeNames)
                data["alternativeNames"].push(item);
        }
        data["name"] = this.name;
        data["description"] = this.description;
        data["bannerUri"] = this.bannerUri;
        data["privacy"] = this.privacy;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["organisationId"] = this.organisationId;
        data["organisationName"] = this.organisationName;
        data["organisationLogoUri"] = this.organisationLogoUri;
        data["organisationPrivacy"] = this.organisationPrivacy;
        data["version"] = this.version;
        return data;
    }
}

export class CreateTeamSettings {
    organisationId!: string;
    name!: string;
    shortName?: string | undefined;
    alternativeNames?: string[];
    description?: string | undefined;
    bannerUri?: string | undefined;
    privacy?: PrivacyLevel;
    tags?: string[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.organisationId = _data["organisationId"];
            this.name = _data["name"];
            this.shortName = _data["shortName"];
            if (Array.isArray(_data["alternativeNames"])) {
                this.alternativeNames = [] as any;
                for (let item of _data["alternativeNames"])
                    this.alternativeNames!.push(item);
            }
            this.description = _data["description"];
            this.bannerUri = _data["bannerUri"];
            this.privacy = _data["privacy"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateTeamSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTeamSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organisationId"] = this.organisationId;
        data["name"] = this.name;
        data["shortName"] = this.shortName;
        if (Array.isArray(this.alternativeNames)) {
            data["alternativeNames"] = [];
            for (let item of this.alternativeNames)
                data["alternativeNames"].push(item);
        }
        data["description"] = this.description;
        data["bannerUri"] = this.bannerUri;
        data["privacy"] = this.privacy;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data;
    }
}

export class UpdateTeamSettings {
    name!: string;
    shortName?: string | undefined;
    alternativeNames?: string[];
    description?: string | undefined;
    bannerUri?: string | undefined;
    privacy?: PrivacyLevel;
    tags?: string[] | undefined;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.shortName = _data["shortName"];
            if (Array.isArray(_data["alternativeNames"])) {
                this.alternativeNames = [] as any;
                for (let item of _data["alternativeNames"])
                    this.alternativeNames!.push(item);
            }
            this.description = _data["description"];
            this.bannerUri = _data["bannerUri"];
            this.privacy = _data["privacy"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateTeamSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTeamSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["shortName"] = this.shortName;
        if (Array.isArray(this.alternativeNames)) {
            data["alternativeNames"] = [];
            for (let item of this.alternativeNames)
                data["alternativeNames"].push(item);
        }
        data["description"] = this.description;
        data["bannerUri"] = this.bannerUri;
        data["privacy"] = this.privacy;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["version"] = this.version;
        return data;
    }
}

export class ListOfUserActivity {
    totalItemCount!: number;
    items!: UserActivity[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserActivity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfUserActivity {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfUserActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class UserActivity {
    id?: string | undefined;
    trackId?: string | undefined;
    activityType?: UserActivityType;
    userId?: string | undefined;
    creatorId?: string | undefined;
    creatorType?: IdentityType;
    payload?: any | undefined;
    created?: Date;
    modified?: Date;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.trackId = _data["trackId"];
            this.activityType = _data["activityType"];
            this.userId = _data["userId"];
            this.creatorId = _data["creatorId"];
            this.creatorType = _data["creatorType"];
            this.payload = _data["payload"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserActivity {
        data = typeof data === 'object' ? data : {};
        let result = new UserActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["trackId"] = this.trackId;
        data["activityType"] = this.activityType;
        data["userId"] = this.userId;
        data["creatorId"] = this.creatorId;
        data["creatorType"] = this.creatorType;
        data["payload"] = this.payload;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        return data;
    }
}

export enum UserActivityType {
    Unknown = "Unknown",
    Joined = "Joined",
    Left = "Left",
    Banned = "Banned",
    RolesAdded = "RolesAdded",
    RolesRemoved = "RolesRemoved",
    ModuleAttempt = "ModuleAttempt",
    SurveyResponse = "SurveyResponse",
}

export class ListOfUser {
    totalItemCount!: number;
    items!: User[];

    init(_data?: any) {
        if (_data) {
            this.totalItemCount = _data["totalItemCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(User.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfUser {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemCount"] = this.totalItemCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class User {
    id?: string | undefined;
    name?: string | undefined;
    alternativeNames?: string[] | undefined;
    imageUri?: string | undefined;
    description?: string | undefined;
    qualifications?: string | undefined;
    jobTypeId?: string | undefined;
    jobTypeName?: string | undefined;
    jobTypeCategory?: string | undefined;
    verified?: boolean;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["alternativeNames"])) {
                this.alternativeNames = [] as any;
                for (let item of _data["alternativeNames"])
                    this.alternativeNames!.push(item);
            }
            this.imageUri = _data["imageUri"];
            this.description = _data["description"];
            this.qualifications = _data["qualifications"];
            this.jobTypeId = _data["jobTypeId"];
            this.jobTypeName = _data["jobTypeName"];
            this.jobTypeCategory = _data["jobTypeCategory"];
            this.verified = _data["verified"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.alternativeNames)) {
            data["alternativeNames"] = [];
            for (let item of this.alternativeNames)
                data["alternativeNames"].push(item);
        }
        data["imageUri"] = this.imageUri;
        data["description"] = this.description;
        data["qualifications"] = this.qualifications;
        data["jobTypeId"] = this.jobTypeId;
        data["jobTypeName"] = this.jobTypeName;
        data["jobTypeCategory"] = this.jobTypeCategory;
        data["verified"] = this.verified;
        data["version"] = this.version;
        return data;
    }
}

export class CreateUserSettings {
    name!: string;
    alternativeNames?: string[] | undefined;
    email!: string;
    password!: string;
    reCaptchaResponse?: string | undefined;
    redirect?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["alternativeNames"])) {
                this.alternativeNames = [] as any;
                for (let item of _data["alternativeNames"])
                    this.alternativeNames!.push(item);
            }
            this.email = _data["email"];
            this.password = _data["password"];
            this.reCaptchaResponse = _data["reCaptchaResponse"];
            this.redirect = _data["redirect"];
        }
    }

    static fromJS(data: any): CreateUserSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.alternativeNames)) {
            data["alternativeNames"] = [];
            for (let item of this.alternativeNames)
                data["alternativeNames"].push(item);
        }
        data["email"] = this.email;
        data["password"] = this.password;
        data["reCaptchaResponse"] = this.reCaptchaResponse;
        data["redirect"] = this.redirect;
        return data;
    }
}

export class OnboardUserSettings {
    name?: string | undefined;
    email!: string;
    groupId!: string;
    displayId?: string | undefined;
    jobTypeId?: string | undefined;
    additionalRoles?: string[] | undefined;
    labelIds?: string[] | undefined;
    notify?: boolean;
    message?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.email = _data["email"];
            this.groupId = _data["groupId"];
            this.displayId = _data["displayId"];
            this.jobTypeId = _data["jobTypeId"];
            if (Array.isArray(_data["additionalRoles"])) {
                this.additionalRoles = [] as any;
                for (let item of _data["additionalRoles"])
                    this.additionalRoles!.push(item);
            }
            if (Array.isArray(_data["labelIds"])) {
                this.labelIds = [] as any;
                for (let item of _data["labelIds"])
                    this.labelIds!.push(item);
            }
            this.notify = _data["notify"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): OnboardUserSettings {
        data = typeof data === 'object' ? data : {};
        let result = new OnboardUserSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["email"] = this.email;
        data["groupId"] = this.groupId;
        data["displayId"] = this.displayId;
        data["jobTypeId"] = this.jobTypeId;
        if (Array.isArray(this.additionalRoles)) {
            data["additionalRoles"] = [];
            for (let item of this.additionalRoles)
                data["additionalRoles"].push(item);
        }
        if (Array.isArray(this.labelIds)) {
            data["labelIds"] = [];
            for (let item of this.labelIds)
                data["labelIds"].push(item);
        }
        data["notify"] = this.notify;
        data["message"] = this.message;
        return data;
    }
}

export class UpdateUserSettings {
    name!: string;
    alternativeNames?: string[];
    qualifications?: string | undefined;
    description?: string | undefined;
    jobTypeId?: string | undefined;
    imageUri?: string | undefined;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["alternativeNames"])) {
                this.alternativeNames = [] as any;
                for (let item of _data["alternativeNames"])
                    this.alternativeNames!.push(item);
            }
            this.qualifications = _data["qualifications"];
            this.description = _data["description"];
            this.jobTypeId = _data["jobTypeId"];
            this.imageUri = _data["imageUri"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateUserSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.alternativeNames)) {
            data["alternativeNames"] = [];
            for (let item of this.alternativeNames)
                data["alternativeNames"].push(item);
        }
        data["qualifications"] = this.qualifications;
        data["description"] = this.description;
        data["jobTypeId"] = this.jobTypeId;
        data["imageUri"] = this.imageUri;
        data["version"] = this.version;
        return data;
    }
}

export class MergeUserSettings {
    primaryUserId!: string;
    secondaryUserId!: string;

    init(_data?: any) {
        if (_data) {
            this.primaryUserId = _data["primaryUserId"];
            this.secondaryUserId = _data["secondaryUserId"];
        }
    }

    static fromJS(data: any): MergeUserSettings {
        data = typeof data === 'object' ? data : {};
        let result = new MergeUserSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["primaryUserId"] = this.primaryUserId;
        data["secondaryUserId"] = this.secondaryUserId;
        return data;
    }
}

export class SendWelcomeEmailSettings {
    groupId?: string | undefined;
    message?: string | undefined;
    redirect?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.groupId = _data["groupId"];
            this.message = _data["message"];
            this.redirect = _data["redirect"];
        }
    }

    static fromJS(data: any): SendWelcomeEmailSettings {
        data = typeof data === 'object' ? data : {};
        let result = new SendWelcomeEmailSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        data["message"] = this.message;
        data["redirect"] = this.redirect;
        return data;
    }
}

export class UserEmails {
    id?: string | undefined;
    emails?: UserEmail[] | undefined;
    primaryEmail?: string | undefined;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["emails"])) {
                this.emails = [] as any;
                for (let item of _data["emails"])
                    this.emails!.push(UserEmail.fromJS(item));
            }
            this.primaryEmail = _data["primaryEmail"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UserEmails {
        data = typeof data === 'object' ? data : {};
        let result = new UserEmails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.emails)) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item.toJSON());
        }
        data["primaryEmail"] = this.primaryEmail;
        data["version"] = this.version;
        return data;
    }
}

export class UserEmail {
    email?: string | undefined;
    verified?: boolean;

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.verified = _data["verified"];
        }
    }

    static fromJS(data: any): UserEmail {
        data = typeof data === 'object' ? data : {};
        let result = new UserEmail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["verified"] = this.verified;
        return data;
    }
}

export class UserEmailSettings {
    email!: string;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UserEmailSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UserEmailSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["version"] = this.version;
        return data;
    }
}

export class UserEmailVerificationToken extends Token {
    /** If is verifying the primary email. */
    primary?: boolean;
    /** If the email has been already been verified. */
    regression?: boolean;

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.primary = _data["primary"];
            this.regression = _data["regression"];
        }
    }

    static fromJS(data: any): UserEmailVerificationToken {
        data = typeof data === 'object' ? data : {};
        let result = new UserEmailVerificationToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["primary"] = this.primary;
        data["regression"] = this.regression;
        super.toJSON(data);
        return data;
    }
}

export class UserPhoneNumber {
    id?: string | undefined;
    number?: string | undefined;
    verified?: boolean;
    version?: number;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.number = _data["number"];
            this.verified = _data["verified"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UserPhoneNumber {
        data = typeof data === 'object' ? data : {};
        let result = new UserPhoneNumber();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["number"] = this.number;
        data["verified"] = this.verified;
        data["version"] = this.version;
        return data;
    }
}

export class UpdateUserPhoneNumberSettings {
    userVersion?: number;
    phoneNumber?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.userVersion = _data["userVersion"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): UpdateUserPhoneNumberSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserPhoneNumberSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userVersion"] = this.userVersion;
        data["phoneNumber"] = this.phoneNumber;
        return data;
    }
}

export class VerificationRequestResult {
    sent?: boolean;
    waitSeconds?: number;

    init(_data?: any) {
        if (_data) {
            this.sent = _data["sent"];
            this.waitSeconds = _data["waitSeconds"];
        }
    }

    static fromJS(data: any): VerificationRequestResult {
        data = typeof data === 'object' ? data : {};
        let result = new VerificationRequestResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sent"] = this.sent;
        data["waitSeconds"] = this.waitSeconds;
        return data;
    }
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}